[
{"categories:":["RADIUS_AAA"],"eventName":"RADIUS_AAA_AUTH_REQUEST","profiles:":["RADIUS_AAA"],"description":"\nThis event is raised when an authentication request is about to be sent out.\n    ","examples":"\nwhen HTTP_REQUEST_DATA {\n    AAA::auth_send $internal_radius_aaa_vip $username $password\n}\nwhen RADIUS_AAA_AUTH_REQUEST {\n        log local0, \"in RADIUS_AAA_AUTH_REQUEST\"\n}\n    "},
{"categories:":["RADIUS_AAA"],"eventName":"RADIUS_AAA_AUTH_RESPONSE","profiles:":["RADIUS_AAA"],"description":"\nThis event is raised when an authentication response arrives.\n    ","examples":"\nwhen HTTP_REQUEST_DATA {\n    set aaa_result [AAA::auth_result $request_id]\n    if { $aaa_result == \"INPROGRESS\" } {\n        after 200\n        continue\n    }\n}\nwhen RADIUS_AAA_AUTH_RESPONSE {\n     log local0, \"in RADIUS_AAA_AUTH_RESPONSE\"\n}\n    "},
{"categories:":["RADIUS_AAA"],"eventName":"RADIUS_AAA_ACCT_REQUEST","profiles:":["RADIUS_AAA"],"description":"\nThis event is raised when an accounting request is about to be sent out.\n    ","examples":"\nwhen HTTP_REQUEST_DATA {\n    AAA::acct_send $internal_radius_aaa_vip user-name $username\n                                                      framed-ip-address $framed-ip\n}                                                      acct-status-type 1\nwhen RADIUS_AAA_ACCT_REQUEST {\n        log local0, \"in RASIUS_AAA_ACCT_REQUEST\"\n}\n    "},
{"categories:":["RADIUS_AAA"],"eventName":"RADIUS_AAA_ACCT_RESPONSE","profiles:":["RADIUS_AAA"],"description":"\nThis event is raised when an accounting response arrives.\n    ","examples":"\nwhen HTTP_REQUEST_DATA {\n    set aaa_result [AAA::acct_result $request_id]\n    if { $acct_result == \"INPROGRESS\" } {\n        after 200\n        continue\n    }\n}\nwhen RADIUS_AAA_ACCT_RESPONSE {\n      log local0, \"in RADIUS_AAA_ACCT_RESPONSE\"\n}\n\n    "},
{"categories:":["ACCESS"],"eventName":"ACCESS_ACL_ALLOWED","profiles:":["ACCESS"],"description":"\nThis is triggered when a resource request passes the access control criteria and is allowed to go through the ACCESS filter. This event is only triggered for the resource requests and does not trigger for internal access control URIs (my.policy etc.) This event is a notification to the administrator that a resource request is being allowed to go through in the network.\n\nYou can use this event to evaluate custom logic which is not supported natively in an ACL. For example you could further limit the access based on some specific session variables or some rate control or some HTTP/SSL properties of the user.\n\nAdministrators can use commands to get and set session variables in this event or use commands to enforce more ACLs in addition to TCP/SSL/HTTP iRule commands.\n    ","examples":"\nEvaluate an additional ACL rule\nwhen ACCESS_ACL_ALLOWED {\n    ACCESS::acl eval \"additional_acl\"\n}\n\nInsert a session variable into an HTTP header (the username in this example):\nwhen ACCESS_ACL_ALLOWED {\n    set user [ACCESS::session data get \"session.logon.last.username\"]\n    HTTP::header insert \"X-USERNAME\" $user\n}\n    "},
{"categories:":["ACCESS"],"eventName":"ACCESS_ACL_DENIED","profiles:":["ACCESS"],"description":"\nThis is triggered when a resource request fails to meet the access control criteria and is denied access. This event is a notification to the administrator that a resource request has been denied to go through in the network. You can use this event to evaluate custom logic which is not supported natively in ACLs. For example you could send a specific response based on specific session variables or HTTP/SSL properties of the user. This event may also be useful for logging purposes. You can use commands to get and set session variables in this event and commands to enforce more ACLs in addition to TCP/SSL/HTTP iRule commands.\n    ","examples":"\nwhen ACCESS_ACL_DENIED {\n    ACCESS::acl eval \"additional_acl\"\n}\n    "},
{"categories:":["ACCESS"],"eventName":"ACCESS_POLICY_AGENT_EVENT","profiles:":["ACCESS"],"description":"\nThis event provides glue between iRule execution and access policy execution. Admin can insert an iRule event agent in its access policy at some point in the access policy. During the access policy execution, iRule event agent is executed and ACCESS_POLICY_AGENT_EVENT is raised in iRules inside TMM. Admin can get the current agent ID (using an iRule command ACCESS::policy agent_id ) to know which of the iRule agent (in case there are multiple of them) raised the event and do some custom logic execution. This event allows admin to execute an iRule logic (inside TMM) at a desired point in the access policy execution. For example, if admin wants to do concurrent session checks for a particular AD group, admin can insert this agent after AD query, and once user's group has been retrieved from AD query, admin can check to see how many concurrent sessions exist for that user group in an iRule inside TMM.\n    ","examples":"\nwhen ACCESS_POLICY_AGENT_EVENT {\n    if { [ACCESS::policy agent_id] eq \"lastLogon\" } {\n        # our limit in seconds\n        set 2weeks 1209600\n        # diff in 100 nanosecond increments between MS time attribute (year 1601) and start of epoch\n        set offset 11644473600000\n        set adtime \"[ACCESS::session data get session.ad.last.attr.lastLogon]\"\n        # convert adtime to milliseconds\n        set millisecs [expr {$adtime / 10000}]\n        # subtract offset\n        set lastlogintime [expr {$millisecs - $offset}]\n        # convert to seconds because milliseconds for 'now' were negative (maybe vmware issue)\n        set secs [expr {$lastlogintime / 1000}]\n        set now [clock seconds]\n        # finally calculate the difference\n        set diff [expr {$now - $secs}]\n        log local0. \"lastLogon: $diff seconds from current time\"\n        if { $diff > $2weeks } {\n                    ACCESS::session data set session.custom.lastLogonWithin2Weeks 0\n        } else {\n                    ACCESS::session data set session.custom.lastLogonWithin2Weeks 1\n        }\n    }\n}\n    "},
{"categories:":["ACCESS"],"eventName":"ACCESS_POLICY_COMPLETED","profiles:":["ACCESS"],"description":"\nThis event is triggered when the access policy execution completes for a user session. This event is a notification to admin that the access policy has completed for the user. Admin can use this event to do post access policy related work. For e.g. reading and setting some session variables. Admin can use ACCESS::policy and ACCESS::session commands to check the result of the policy and to get and set session variables in this event , in addition to TCP/SSL/HTTP iRule commands in this event.\n    ","examples":"\nwhen ACCESS_POLICY_COMPLETED {\n    set policy_result [ACCESS::policy result]\n    switch $policy_result {\n        \"allow\" {\n            # Do nothing\n        }\n        \"deny\" {\n        ACCESS::respond 401 content \"<html><body>Error: Failure in Authentication</body></html>\" Connection Close\n        }\n    }\n}\n    "},
{"categories:":["ACCESS_GLOBAL"],"eventName":"ACCESS_SESSION_CLOSED","profiles:":[],"description":"\nThis event is triggered when a user session is removed due to a user logging out explicitly, session timeout, session terminated by administrator, or session deleted by an iRule.\n\nIn TMOS versions 11.5.1+ you may use \"ACCESS::session data get\" commands in this event. When the event has concluded session data will be expunged.\n\nThis event is a complementary event to the ACCESS_SESSION_STARTED event.\n    ","examples":"\nwhen ACCESS_SESSION_CLOSED {\n    log local0.notice \"APM: ACCESS_SESSION_CLOSED-User using the session: [ACCESS::session data get \"session.logon.last.username\"]\"\n}\n    "},
{"categories:":["ACCESS"],"eventName":"ACCESS_SESSION_STARTED","profiles:":["ACCESS"],"description":"\nThis event is triggered when a new user session is created. This is triggered after creating the session context and initial session variables related to user's source IP, browser capabilities and accepted languages etc. This event is a notification to admin that a new session is being created. Admin can use this event to do some more session restriction checks, and prevent the session from being created in this event. For e.g. if user is exceeding some kind of limit (concurrent sessions etc.) or if the user does not qualify for a new session due to some thing which is a custom logic. Admin can use ACCESS::session commands to get and set various session variables. Admin can also use TCP/SSL/HTTP iRule commands to know various TCP/SSL/HTTP properties of the user.\n    ","examples":"\nExample 1: In this example, admin logs user's agent\nwhen ACCESS_SESSION_STARTED {\n    log local0.notice \"APM: Received a new session from browser: [ACCESS::session data get \"session.user.agent\"]\"\n}\nExample 2: In this example, admin limits the application access to one subnet 192.168.255.0 only.\nwhen ACCESS_SESSION_STARTED {\n    set user_subnet [ACCESS::session data get \"session.user.clientip\"]\n    if { ($user_subnet & 0xffffff00) != \"192.168.255.0\" } {\n        log local0.notice \"Unauthorized subnet\"\n        ACCESS::session remove\n    }\n}\n\n    "},
{},
{},
{"categories:":["IP","TCP","HTTP","SSL"],"eventName":"ACCESS_PER_REQUEST_AGENT_EVENT","profiles:":[],"description":"\n        This event provides a way to use an iRule at any point during per-request access policy execution. During the per-request access policy execution, iRule event agent is executed and ACCESS_PER_REQUEST_AGENT_EVENT is raised in iRules inside TMM. Admin can get the current agent ID (using \"ACCESS::perflow get perflow.irule_agent_id\") to know which of the iRule agents (in case there are multiple of them) raised the event and do some custom logic execution. This event allows admin to execute an iRule logic (inside TMM) at a desired point in the per-request access policy execution.\n    ","examples":"\nwhen ACCESS_PER_REQUEST_AGENT_EVENT {\n    if { [ACCESS::perflow get perflow.irule_agent_id] eq \"irule_agent_one\" } {\n        log local0. \"Hit first iRule agent in PR policy\"\n    }\n    if { [ACCESS::perflow get perflow.irule_agent_id] eq \"irule_agent_two\" } {\n        log local0. \"Hit second iRule agent in PR policy\"\n    }\n}\n    "},
{"categories:":["ADAPT"],"eventName":"ADAPT_REQUEST_RESULT","profiles:":["REQUESTADAPT"],"description":"\nThis event is raised for a request adaptation as soon as an\nadaptation decision has been made by the selected internal virtual\nserver (IVS). In the case of an ICAP profile on the IVS, that\noccurs after receipt of the ICAP headers from the ICAP server, but\nbefore any encapsulated HTTP headers of body have been received.\n    ","examples":"\nwhen ADAPT_REQUEST_RESULT {\n    if {[ADAPT::result] == \"respond\"} {\n         # Force ADAPT to ignore any direct response from IVS\n         # (contrived example, probably not useful as-is).\n         ADAPT::result bypass\n    }\n}\n    "},
{"categories:":["ADAPT"],"eventName":"ADAPT_RESPONSE_RESULT","profiles:":["RESPONSEADAPT"],"description":"\nThis event is raised for a response adaptation as soon as an\nadaptation decision has been made by the selected internal virtual\nserver (IVS). In the case of an ICAP profile on the IVS, that\noccurs after receipt of the ICAP headers from the ICAP server, but\nbefore any encapsulated HTTP headers or body have been received.\n    ","examples":"\nwhen ADAPT_RESPONSE_RESULT {\n     if {[ADAPT::result] == \"modify\"} {\n         # Force ADAPT to ignore any direct response from IVS\n         # (contrived example, probably not useful as-is).\n         ADAPT::result bypass\n     }\n}\n    "},
{"categories:":["ADAPT"],"eventName":"ADAPT_REQUEST_HEADERS","profiles:":["REQUESTADAPT"],"description":"\nThis event is raised for a request adaptation after any HTTP\nheaders have been received from the selected internal virtual server\n(IVS). In the case of an ICAP profile on the IVS, that occurs after\nthe encapsulated HTTP headers of any modified request or direct\nresponse have been received and are accessible to iRule commands.\nThis can happen only when the IVS result is \"modified\" or \"response\".\nThis event does not trigger if the IVS result is \"noop\" or an error.\n    ","examples":"\n# Remove header that should not be encapsulated in the ICAP response.\nwhen ADAPT_REQUEST_HEADERS {\n    HTTP::header remove Transfer-Encoding\n}\n    "},
{"categories:":["ADAPT"],"eventName":"ADAPT_RESPONSE_HEADERS","profiles:":["RESPONSEADAPT"],"description":"\nThis event is raised for a response adaptation after any HTTP\nheaders have been received from the selected internal virtual server\n(IVS). In the case of an ICAP profile on the IVS, that occurs after\nthe encapsulated HTTP headers of any modified response have been\nreceived and are accessible to iRule commands.\nThis can happen only when the IVS result is \"modified\" or \"response\".\nThis event does not trigger if the IVS result is \"noop\" or an error.\n    ","examples":"\n# Remove header that should not be encapsulated in the ICAP response.\nwhen ADAPT_RESPONSE_HEADERS {\n    HTTP::header remove Transfer-Encoding\n}\n    "},
{},
{},
{},
{},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"ANTIFRAUD_LOGIN","profiles:":["ANTIFRAUD"],"description":"\nThis event is raised as soon as a user has logged in successfully.\n    ","examples":"\nwhen ANTIFRAUD_LOGIN {\n            log local0. \"Username [ANTIFRAUD::username] has logged in successfully.\"\n}\n        "},
{"categories:":["HTTP","CLIENTSIDE"],"eventName":"ANTIFRAUD_ALERT","profiles:":["ANTIFRAUD"],"description":"\nThis event is raised as soon as either WebSafe or MobileSafe alert is sent from the BIG-IP to the dashboard.\n    ","examples":"\nwhen ANTIFRAUD_ALERT {\n            ANTIFRAUD::disable_alert\n}\n    "},
{"categories:":["HTTP"],"eventName":"ASM_REQUEST_DONE","profiles:":["FASTHTTP","HTTP"],"description":"\nThis event is triggered after ASM finished processing the request and found all violations of the ASM policy, if there were any, and before enforcing the action on the request, either forwarding to the server or responding with a blocking page. In case the of 100-Continue response, the event will be triggered after the body of the request was received by the ASM. This event replaces the ASM_REQUEST_VIOLATION event which is kept for backward compatibility. The iRules developer can check whether there have been violations using the command.\n    ","examples":"\nwhen ASM_REQUEST_VIOLATION\n{\n  set x [ASM::violation_data]\n\n  for {set i 0} { $i < 7 } {incr i} {\n      switch $i {\n      0         { log local0. \"violation=[lindex $x $i]\" }\n      1         { log local0. \"support_id=[lindex $x $i]\" }\n      2         { log local0. \"web_application=[lindex $x $i]\" }\n      3         { log local0. \"severity=[lindex $x $i]\" }\n      4         { log local0. \"source_ip=[lindex $x $i]\" }\n      5         { log local0. \"attack_type=[lindex $x $i]\" }\n      6         { log local0. \"request_status=[lindex $x $i]\" }\n\n   }}\n\n   if {([lindex $x 0] contains \"VIOLATION_EVASION_DETECTED\")}\n   {\n      log local0. \"VIOLATION_EVASION_DETECTED detected, uri=[HTTP::uri]\"\n      HTTP::header insert header_1 value_1\n      ASM::payload replace 0 0 \"1234567890\"\n   } else {\n      log local0. \"violation=[lindex $x 0]\"\n      log local0. \"Decided to route is to different pool\"\n      HTTP::uri /index.php\n      pool phpauction\n   }\n}\n    "},
{"categories:":["HTTP"],"eventName":"ASM_REQUEST_VIOLATION","profiles:":["FASTHTTP","HTTP"],"description":"\nTriggered when ASM detects that a request violates an ASM security policy.\n    ","examples":"\nThis example logs the received violation data. It also modifies the headers and payload of the request in case of evasion violation (a clientside violation) else it redirects the request to another destination.\nwhen ASM_REQUEST_VIOLATION\n{\n  set x [ASM::violation_data]\n\n  for {set i 0} { $i < 7 } {incr i} {\n      switch $i {\n      0         { log local0. \"violation=[lindex $x $i]\" }\n      1         { log local0. \"support_id=[lindex $x $i]\" }\n      2         { log local0. \"web_application=[lindex $x $i]\" }\n      3         { log local0. \"severity=[lindex $x $i]\" }\n      4         { log local0. \"source_ip=[lindex $x $i]\" }\n      5         { log local0. \"attack_type=[lindex $x $i]\" }\n      6         { log local0. \"request_status=[lindex $x $i]\" }\n\n   }}\n\n   if {([lindex $x 0] contains \"VIOLATION_EVASION_DETECTED\")}\n   {\n      log local0. \"VIOLATION_EVASION_DETECTED detected, uri=[HTTP::uri]\"\n      HTTP::header insert header_1 value_1\n      ASM::payload replace 0 0 \"1234567890\"\n   } else {\n      log local0. \"violation=[lindex $x 0]\"\n      log local0. \"Decided to route is to different pool\"\n      HTTP::uri /index.php\n      pool phpauction\n   }\n}\n\n    "},
{"categories:":["HTTP"],"eventName":"ASM_REQUEST_BLOCKING","profiles:":["FASTHTTP","HTTP"],"description":"\nThis event is triggered when ASM is generating the reject-response and gives the iRule a chance to modify that reject-response before it is sent.\n    ","examples":"\nThis example modifies the ASM reject page when the evasion detected(a client side violation) is triggered by ASM.\nwhen ASM_REQUEST_BLOCKING\n{\n\n  set x [ASM::violation_data]\n  #marker bit to handle header change\n  set activeViolation 1\n  for {set i 0} { $i < 7 } {incr i} {\n      switch $i {\n      0         { log local0. \"violation=[lindex $x $i]\" }\n      1         { log local0. \"support_id=[lindex $x $i]\" }\n      2         { log local0. \"web_application=[lindex $x $i]\" }\n      3         { log local0. \"severity=[lindex $x $i]\" }\n      4         { log local0. \"source_ip=[lindex $x $i]\" }\n      5         { log local0. \"attack_type=[lindex $x $i]\" }\n      6         { log local0. \"request_status=[lindex $x $i]\" }\n\n   }}\n\n   if {([lindex $x 0] contains \"VIOLATION_EVASION_DETECTED\")}\n   {\n      log local0. \"VIOLATION_EVASION_DETECTED detected, let's customized reject page\"\n\n      #this really does not work like this\n      #HTTP::header remove Content-Length\n      #HTTP::header insert header_1 value_1\n\n      set response \"<html><head><title>Apology Page</title></head><body>We are sorry,\\\n         but the site you are looking for is temporarily out of service\\\n         If you feel you have reached this page in error, please try again.</body></html>\"\n\n      ASM::payload replace 0 [ASM::payload length] \"\"\n      ASM::payload replace 0 0 $response\n   }\n\n}\n\nwhen HTTP_RESPONSE_RELEASE {\n   #catch for error if variable does not exist (no previous event ASM_REQUEST_BLOCKING)\n   catch {\n       #do only if  previous was event ASM_REQUEST_BLOCKING\n       if { $activeViolation } {\n           #modify respose header\n           HTTP::header remove Content-Length\n           HTTP::header insert header_1 value_1\n       }\n   }\n}\n    "},
{"categories:":["HTTP"],"eventName":"ASM_RESPONSE_VIOLATION","profiles:":["FASTHTTP","HTTP"],"description":"\nThis event is triggered when ASM detects that a response violates an ASM security policy.\n    ","examples":"\nThis example modifies the response page when the response scrubbing (a server side violation) is triggered by ASM.\nwhen ASM_RESPONSE_VIOLATION\n{\n\n  set x [ASM::violation_data]\n\n  for {set i 0} { $i < 7 } {incr i} {\n      switch $i {\n      0         { log local0. \"violation=[lindex $x $i]\" }\n      1         { log local0. \"support_id=[lindex $x $i]\" }\n      2         { log local0. \"web_application=[lindex $x $i]\" }\n      3         { log local0. \"severity=[lindex $x $i]\" }\n      4         { log local0. \"source_ip=[lindex $x $i]\" }\n      5         { log local0. \"attack_type=[lindex $x $i]\" }\n      6         { log local0. \"request_status=[lindex $x $i]\" }\n\n   }}\n\n   if {([lindex $x 0] contains \"VIOLATION_RESPONSE_SCRUBBING\")}\n   {\n      log local0. \"VIOLATION_RESPONSE_SCRUBBING detected, let's modify\"\n      ASM::payload replace 0 5 \"method\"\n   }\n}\n    "},
{"categories:":["AUTH"],"eventName":"AUTH_RESULT","profiles:":["AUTH"],"description":"\nThis event replaces AUTH_SUCCESS, AUTH_FAILURE, AUTH_ERROR, and AUTH_WANTCREDENTIAL events. These four deprecated events will be removed from a future release. The specific result can be obtained using AUTH::status.\n    ","examples":"\nwhen AUTH_RESULT {\n    if {[AUTH::status] != 0} {\n        HTTP::respond 401\n    } else {\n        HTTP::release\n    }\n}\n    "},
{"categories:":["AUTH"],"eventName":"AUTH_ERROR","profiles:":["AUTH"],"description":"\nNote: Deprecated in 9.4. It will still work, but is being phased out. Use AUTH_RESULT instead in 9.4 and up.\n\nTriggered when an error occurs during authorization. A default handler for this event is associated with each of the authentication profiles and causes the system to close the connection. The associated authentication session ID is invalidated and, upon receipt of this event, the user should immediately discard the session ID.\n    ","examples":"\nwhen AUTH_ERROR {\n    if {$tmm_auth_ssl_ocsp_sid eq [AUTH::last_event_session_id]} {\n        SSL::handshake resume\n    }\n}\n    "},
{"categories:":["AUTH"],"eventName":"AUTH_FAILURE","profiles:":["AUTH"],"description":"\nNote: Deprecated in 9.4. It will still work, but is being phased out. Use AUTH_RESULT instead in 9.4 and up.\n\nTriggered when an unsuccessful authorization operation is completed. A default handler for this event is associated with each of the authentication profiles and causes the system to close the connection.\n    ","examples":"\nwhen AUTH_FAILURE {\n    HTTP::respond 401\n}\n    "},
{"categories:":["AUTH"],"eventName":"AUTH_SUCCESS","profiles:":["AUTH"],"description":"\nNote: Deprecated in 9.4. It will still work, but is being phased out. Use AUTH_RESULT instead in 9.4 and up.\n\nTriggered when a successful authorization has completed all of the required authentication services.\n    ","examples":"\nwhen AUTH_SUCCESS {\n    set authorized 1\n}\n    "},
{"categories:":["AUTH"],"eventName":"AUTH_WANTCREDENTIAL","profiles:":["AUTH"],"description":"\nNote: Deprecated in 9.4. It will still work, but is being phased out. Use AUTH_RESULT instead in 9.4 and up.\n\nTriggered when an authorization operation needs an additional credential. See also the description of the AUTH::wantcredential_prompt command.\n\nA default handler for this event is associated with each of the authentication profiles, and causes the system to close the connection unless it can obtain the desired credential. Typically, this implies that the protocol layer that provides the credential has also not yet obtained the credential, because the system did not enable the necessary authentication protocol. Each of the authentication profiles contains appropriate default handlers for its respective protocol.\n    ","examples":"\nwhen AUTH_WANTCREDENTIAL {\n    HTTP::respond 401 \"WWW-Authenticate\" \"Basic realm=\\\"\\\"\"\n}\nwhen AUTH_FAILURE {\n    log local0. \"Auth failed: Auth prompt was \\\"[AUTH::wantcredential_prompt $authid]\\\" Auth prompt style was \\\"[AUTH::wantcredential_prompt_style $authid]\\\"\"\n}\n    "},
{"categories:":["BOTDEFENSE","HTTP"],"eventName":"BOTDEFENSE_REQUEST","profiles:":["DOSL7"],"description":"\nTriggered on an HTTP request (before the payload), after Bot Defense finished processing the request, but before a decision is made on a possible action. The event may be used to retrieve the data processed by Bot Defense, query and override URL qualification for client-side responses.\n\nThis event is triggered only when Proactive Bot Defense is enabled on the DOS profile, and Bot Defense needs to make a decision on a possible action. The event will not be triggered in the following cases: white-listed IP address, black-listed geo-location, blocked by bot signature, or mitigated by dosl7 attack.\n\nMost of the command that are available on the HTTP_REQUEST event are also available on the BOTDEFENSE_REQUEST event.\n\nNote that commands which may suspend iRule processing are currently not supported in this event and should not be used. Partial list of these commands: after, persist, session, table, and RESOLV::lookup.\n    ","examples":"\n# EXAMPLE: Allow client-side challenges on a specific URL\nwhen BOTDEFENSE_REQUEST {\n    if {[HTTP::uri] eq \"/t/a.php\"} {\n        BOTDEFENSE::cs_allowed true\n    }\n}\n    "},
{"categories:":["BOTDEFENSE","HTTP"],"eventName":"BOTDEFENSE_ACTION","profiles:":["DOSL7"],"description":"\nTriggered immediately prior to taking an action on a transaction. The event may be used to override the default behavior, and/or to log the action taken.\n\nThis event is always triggered when Proactive Bot Defense is enabled on the DOS profile, unless the request is mitigated by dosl7 attack. The event will also be triggered if Proactive Bot Defense is disabled, but a Bot Signature was detected on the request, whether for blocking or for reporting.\n\nMost of the command that are available on the HTTP_REQUEST event are also available on the BOTDEFENSE_ACTION event.\n\nNote that commands which may suspend iRule processing are currently not supported in this event and should not be used. Partial list of these commands: after, persist, session, table, and RESOLV::lookup.\n    ","examples":"\n# EXAMPLE 1: Send parsed Bot Defense data and action to High Speed Logging\nwhen BOTDEFENSE_ACTION {\n    set log \"BOTDEFENSE:\"\n    append log \" uri [HTTP::uri]\"\n    append log \" cs_possible [BOTDEFENSE::cs_possible]\"\n    append log \" cs_allowed [BOTDEFENSE::cs_allowed]\"\n    append log \" cs_attribute(device_id) [BOTDEFENSE::cs_attribute device_id]\"\n    append log \" cookie_status [BOTDEFENSE::cookie_status]\"\n    append log \" cookie_age [BOTDEFENSE::cookie_age]\"\n    append log \" device_id [BOTDEFENSE::device_id]\"\n    append log \" support_id [BOTDEFENSE::support_id]\"\n    append log \" previous_action [BOTDEFENSE::previous_action]\"\n    append log \" previous_support_id [BOTDEFENSE::previous_support_id]\"\n    append log \" previous_request_age [BOTDEFENSE::previous_request_age]\"\n    append log \" bot_signature [BOTDEFENSE::bot_signature]\"\n    append log \" bot_signature_category [BOTDEFENSE::bot_signature_category]\"\n    append log \" captcha_status [BOTDEFENSE::captcha_status]\"\n    append log \" captcha_age [BOTDEFENSE::captcha_age]\"\n    append log \" default action [BOTDEFENSE::action]\"\n    append log \" reason \\\"[BOTDEFENSE::reason]\\\"\"\n    log local0. $log\n    HSL::send $hsl $log\n}\n\n# EXAMPLE 2: Bypassing enforcement on URL pattern\nwhen BOTDEFENSE_ACTION {\n    if {[HTTP::uri] starts_with \"/t/\"} {\n        log local0. \"bypassing enforcement for URI [HTTP::uri]\"\n        set res [BOTDEFENSE::action allow]\n        log local0. \"set action to allow, result \\\"$res\\\"\"\n        log local0. \"resulting action [BOTDEFENSE::action] reason \\\"[BOTDEFENSE::reason]\\\"\"\n    }\n}\n    "},
{"categories:":["CACHE"],"eventName":"CACHE_REQUEST","profiles:":["WEBACCELERATION"],"description":"\nTriggered when the system receives a request for an object eligible to be cached. Used to override default behavior.\n    ","examples":"\nwhen CACHE_REQUEST {\n  if { [CACHE::age] > 60 } {\n    CACHE::expire\n    log local0. \"Expiring content: Age > 60 seconds\"\n   }\n}\n    "},
{"categories:":["CACHE"],"eventName":"CACHE_RESPONSE","profiles:":["WEBACCELERATION"],"description":"\nTriggered immediately prior to sending a cache response. Used to override default behavior.\n    ","examples":"\nwhen CACHE_RESPONSE {\n  if { $expired == 1 } {\n    CACHE::expire\n    log local0. \"cache expire\"\n    set expired 0\n  }\n}\n    "},
{"categories:":["CACHE"],"eventName":"CACHE_UPDATE","profiles:":["WEBACCELERATION"],"description":"\nThis event fires when a new entry is inserted into the cache and when an object is refreshed in the cache by the server after expiring.\n    ","examples":"\nwhen CACHE_UPDATE {\n    # cached object's headers manipulation\n    # modifications will be seen whenever the object is served from cache\n    CACHE::header replace Server Big-IP-Server\n}\n    "},
{"categories:":["CATEGORY"],"eventName":"CATEGORY_MATCHED","profiles:":["HTTP","ACCESS"],"description":"\nThis is triggered when a category match is found during URL filtering. This allows an admin some control over what to do when a category match happens. For example, if a match is in a custom category, it can be logged as such.\n    ","examples":"\nwhen CATEGORY_MATCHED {\n    CATEGORY::matchtype type_var\n    if { $type_var eq \"custom\" } {\n         log local0. \"Custom category match was found.\"\n    }\n}\n    "},
{"categories:":["CLASSIFICATION"],"eventName":"CLASSIFICATION_DETECTED","profiles:":["CLASSIFICATION"],"description":"\nThis is triggered when a flow is classified.\n    ","examples":"\nIn the example, the CLASSIFICATION::result command returns an array of classification tokens.\n\nwhen CLASSIFICATION_DETECTED {\n    set res [CLASSIFICATION::result]\n    log local0.debug \"dpi results: $res\"\n}\n    "},
{"categories:":["DIAMETER"],"eventName":"DIAMETER_INGRESS","profiles:":["DIAMETER","DIAMETER_ENDPOINT","DIAMETERSESSION"],"description":"\nAn iRule event triggered when the system receives a DIAMETER\nmessage. The context of this event shifts based on where the message\noriginated.\n\nIf the client sent the message, DIAMETER_INGRESS is a clientside event.\nIf the server sent the message, DIAMETER_INGRESS is a serverside event.\n    ","examples":"\nwhen DIAMETER_INGRESS {\n    if { ([DIAMETER::command] == \"272\") } {\n        log local0. \"Credit Control Request received from [IP::remote_addr] with origin host [DIAMETER::host origin]\"\n    }\n}\n    "},
{"categories:":["DIAMETER"],"eventName":"DIAMETER_EGRESS","profiles:":["DIAMETER","DIAMETER_ENDPOINT","DIAMETERSESSION"],"description":"\nAn iRule event triggered when the system is ready to send a DIAMETER\nmessage. The context of this event shifts based on where the message\noriginated.\n\nIf the client sent the message, DIAMETER_EGRESS is a serverside event.\nIf the server sent the message, DIAMETER_EGRESS is a clientside event.\n    ","examples":"\nwhen DIAMETER_EGRESS {\n   if {[serverside]} {\n      if { [DIAMETER::command] == \"257\" } {\n         log local0. \"CER sent from [IP::local_addr] to [IP::remote_addr] with origin-host [DIAMETER::host origin]\"\n      }\n   }\n}\n    "},
{"categories:":["DNS"],"eventName":"DNS_REQUEST","profiles:":["DNS"],"description":"\nTriggered when the system receives a DNS request.\n\nWhen using this event in a GTM iRule, a GTM license must be enabled for it to work.\n\nThis event is only available for LTM in versions 11.0+ and requires either a GTM license or DNS Services addon license. When using this event in an LTM iRule a DNS profile must be enabled on the listener.\n    ","examples":"\nwhen DNS_REQUEST {\n  if { [IP::addr [IP::remote_addr] equals 10.10.1.0/24] } {\n    cname cname.siterequest.com\n  } else {\n    host 10.20.20.20\n  }\n}\n\nwhen DNS_REQUEST {\n  # Changed = = 0 to < 1 for CR100063 / SOL10137\n  if { [active_members pool_test] < 1 } {\n    cname \"something.domain.com\"\n  }\n}\n\n# Send one or more IP addresses for a response to an A query\n# Use on an LTM virtual server with a DNS profile enabled\nwhen DNS_REQUEST {\n    # Log query details\n    log local0. \"\\[DNS::question name\\]: [DNS::question name],\\\n        \\[DNS::question class\\]: [DNS::question class],\n        \\[DNS::question type\\]: [DNS::question type]\"\n\n    # Generate an answer with two A records\n    DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.1\"\n    DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.2\"\n\n    # Stop further processing of the query after this iRule and send the answer to the client\n    DNS::return\n    return\n}\n    "},
{"categories:":["DNS"],"eventName":"DNS_RESPONSE","profiles:":["DNS"],"description":"\nTriggered when the system responds to a DNS request.\n\nWhen using this event in an LTM iRule on a DNS listener, either a GTM license or DNS Services addon license must be enabled. When using this event in an LTM iRule a DNS profile must be enabled on the listener.\n\n    ","examples":"\nwhen DNS_RESPONSE {\n  if { [LB::server addr] equals \"10.10.10.10\" } {\n    log local0. \"Alert: [DNS::rrname] resolved to backup server\"\n  }\n}\n\nChange the ttl of all answer records and add a glue record\n\nwhen DNS_RESPONSE {\n    set rrs [DNS::answer]\n    foreach rr $rrs {\n        DNS::ttl $rr 1234\n    }\n    set new_rr [DNS::rr \"bigip3900-30.f5net.com. 88 IN A 1.2.3.4\"]\n    DNS::additional insert $new_rr\n}\n    "},
{"categories:":["HTTP"],"eventName":"IN_DOSL7_ATTACK","profiles:":["FASTHTTP","HTTP"],"description":"\nTriggered when detects that a request violates an ASM security policy for Denial of Service attacks\n\nAs of 11.3, this event replaces the VIOLATION_DOS_ATTACK_STARTED and the ATTACK_TYPE_DOS_ATTACK_STARTED attack type.\n\nThe event is invoked on each HTTP request that is involved in a DoS attack--that is, a request that comes from a suspicious client IP address or destined to a suspicious URL with the exception of the following:\n\nWhen the attack prevention mode is CS challenge (client IP address or requested URL) the event is not triggered for any request.\nWhen in rate limit mode (client IP address or requested URL) the event is invoked only for attack requests that are not dropped.\n\n\nWhen in transparent mode, the event is invoked for every request. This is the most common intended use case for this event: enabling the administrator to implement a proprietary prevention policy.\n\nVariable name       Variable description\n$DOSL7_ATTACKER_IP  The attacker IP address\n$DOSL7_MITIGATION   Mitigation method which is applied on the current HTTP request\n    ","examples":"\nwhen IN_DOSL7_ATTACK {\n    log local0. \"Attacker IP: $DOSL7_ATTACKER_IP\"\n    log local0. \"Mitigation: $DOSL7_MITIGATION\"\n}\n\nlog example from /var/log/ltm\nAug 23 05:44:40 tmm info tmm[17073]: Rule /Common/dosl7_irule : Attacker IP: 192.168.172.210\nAug 23 05:44:40 tmm info tmm[17073]: Rule /Common/dosl7_irule : Mitigation: Source IP-Based Rate Limiting\n    "},
{},
{},
{"categories:":["FIX"],"eventName":"FIX_HEADER","profiles:":["FIX"],"description":"\nTriggered when the system finishes parsing a new FIX header.\n    ","examples":"\nwhen CLIENT_ACCEPTED {\n    log local0. \"Enable client side flow migration after server side is connected.\"\n    BIGTCP::release_flow\n}\nwhen FIX_HEADER {\n    set sender [FIX::tag get 49]\n    set msg_type [FIX::tag get 35]\n    set target [FIX::tag get 56]\n    log local0. \"FIX_HEADER: $sender-$msg_type-$target\"\n    if {$sender eq \"client3\"}{\n        if {$msg_type eq \"A\"}{\n            log local0. \"Logon successfully: $sender-$msg_type-$target\"\n            set tags [list 49 35 56 8 9 98 108 141]\n            foreach i $tags {\n               set tagv [FIX::tag get $i]\n               append tagA $tagv \"-\"\n            }\n            log local0. \"Query A: $tagA\"\n            pool fix_pool2_13976\n        }\n        if {$msg_type eq \"D\"}{\n            set tags [list 35 11 21 55 54 38 40 44]\n            foreach i $tags {\n               set tagv [FIX::tag get $i]\n               append tagD $tagv \"-\"\n            }\n            log local0. \"Query D: $tagD\"\n        }\n    }\n}\n# If explicit flow migration is enabled then notify BIGTCP when to migrate the flow.\nwhen SERVER_CONNECTED {\n    log local0. \"Migrate flow to ePVA once server side is connected.\"\n    BIGTCP::release_flow\n}\n    "},
{"categories:":["FIX"],"eventName":"FIX_MESSAGE","profiles:":["FIX"],"description":"\nTriggered when the system finishes parsing a new FIX message.\n    ","examples":"\nwhen CLIENT_ACCEPTED {\n    log local0. \"Enable client side flow migration after server side is connected.\"\n    BIGTCP::release_flow\n}\nwhen FIX_MESSAGE {\n    set sender [FIX::tag get 49]\n    set msg_type [FIX::tag get 35]\n    set target [FIX::tag get 56]\n    if {$sender eq \"client2\"}{\n        if {$msg_type eq \"A\"}{\n            log local0. \"Logon successfully: $sender-$msg_type-$target\"\n            pool fix_pool2_13976\n        }\n        if {$msg_type eq \"F\"}{\n            set tags [list 35 11 21 55 54 38 40 44]\n            foreach i $tags {\n               set tagv [FIX::tag get $i]\n               append tagF $tagv \"-\"\n            }\n            log local0. \"Query F: $tagF\"\n        }\n    }\n}\n# If explicit flow migration is enabled then notify BIGTCP when to migrate the flow.\nwhen SERVER_CONNECTED {\n    log local0. \"Migrate flow to ePVA once server side is connected.\"\n    BIGTCP::release_flow\n}\n    "},
{"categories:":["IP","TCP","SCTP","UDP"],"eventName":"FLOW_INIT","profiles:":[],"description":"\nThis is triggered (once for TCP and unique UDP/IP flows) after packet filters, but before any AFM and TMM work occurs. The use cases for this event are:\n\n    Override ACL action\n    Bandwidth control on both client/server flows\n    Routing to another Vip\n    Marking qos tos/dscp on both client/server flows\n\n\nCommands supported within this new event:\n    log\n    drop\n    reject\n    node (host ip address)\n    virtual (virtual server name)\n    pool (pool name)\n    TCP::close\n    TCP::respond\n    IP::client_addr\n    IP::local_addr\n    IP::tos\n    IP::ttl\n    IP::version\n    ACL::action\n    ","examples":"\nAllow US/Canada users, drop Great Brittain, Reject all others.\n\nwhen FLOW_INIT {\n    set ipaddr [IP::client_addr]\n    set locale [whereis $ipaddr country]\n    log local0. \"IP Address/Counry $ipaddr/$locale\"\n    switch $locale {\n        \"US\" -\n        \"CA\" { return }\n        \"GB\" { ACL::action drop }\n        default { ACL::action reset }\n    }\n}\n\nAllow traffic from 172.29.97.151 and forward to vip /Common/my_http_vs\nwhen FLOW_INIT {\n  if { [IP::addr [IP::client_addr] equals 172.29.97.151] } {\n    ACL::action allow\n    virtual /Common/my_http_vs\n    log \"FLOW_INIT: ACL allow to /Common/my_http_vs\"\n  }\n}\n    "},
{"categories:":["GENERICMESSAGE"],"eventName":"GENERICMESSAGE_EGRESS","profiles:":["GENERICMSG"],"description":"\nThe event is raised when a message is received from the proxy.\n    ","examples":"\nwhen GENERICMESSAGE_EGRESS {\n    GENERICMESSAGE::message data \"[GENERICMESSAGE::message data] status: [GENERICMESSAGE::message status]\"\n}\n    "},
{"categories:":["GENERICMESSAGE"],"eventName":"GENERICMESSAGE_INGRESS","profiles:":["GENERICMSG"],"description":"\nThis event is raised when a message is received by the generic message filter.\n    ","examples":"\nwhen GENERICMESSAGE_INGRESS {\n    GENERICMESSAGE::message src us\n    GENERICMESSAGE::message dst them\n}\n    "},
{"categories:":["IP","TCP","SCTP","UDP"],"eventName":"CLIENT_ACCEPTED","profiles:":[],"description":"\nAn iRule event triggered when a client has established a connection.\n\nIn effect, when an entry is inserted in the BIG-IP connection table, this event fires. For TCP connections, this happens when the three-way handshake successfully completes. For non-TCP connections, this will fire at a point that may not be wholly intuitive. For example, UDP is connectionless, so one might reasonably expect this event to fire with each segment in a UDP stream. However, BIG-IP does create a connection table entry for UDP, and assigns a timeout. If no segment arrives matching the table entry within the timeout period, the entry is removed (and CLIENT_CLOSED fires). However, segments matching the table entry that arrive within the timeout period will not trigger a new CLIENT_ACCEPTED event (and will reset the timeout timer for the entry). The timeout is generally configured, in the case of UDP, via the UDP profile (or a child profile) applied to the virtual server.\n\nSome profile settings may also have an effect on when events are raised. For example, the \"Datagram LB\" setting on the UDP profile will force each segment in a UDP stream (that is, packets carrying UDP segments that all have a common source ip/port and destination ip/port) to load-balance. Between the BIG-IP system and the pool members, the forwarded segments will use different source port numbers for each segment (sort of like SNAT, but just for the port). In this case, CLIENT_ACCEPTED will fire for each segment. This is actually a specific case of the more general rule above, as each segment essentially creates an independent connection table entry. Notice, for example, that CLIENT_CLOSED will still fire for each segment after the timeout period.\n    ","examples":"\nwhen CLIENT_ACCEPTED {\n  set curtime [clock seconds]\n  set formattedtime [clock format $curtime -format {%H:%S} ]\n  log \"the time is: $formattedtime\"\n}\n    "},
{"categories:":["IP","TCP","SCTP","UDP"],"eventName":"CLIENT_CLOSED","profiles:":[],"description":"\nAn iRule event triggered at the end of any client connection,\nregardless of protocol.\n\n    ","examples":"\nwhen CLIENT_CLOSED {\n  if { [info exists ::active_clients($client_ip)] } {\n    incr ::active_clients($client_ip) -1\n    if { $::active_clients($client_ip) <= 0 } {\n      unset ::active_clients($client_ip)\n    }\n  }\n}\n    "},
{"categories:":["IP","TCP","SCTP","UDP"],"eventName":"CLIENT_DATA","profiles:":[],"description":"\nFor TCP, this event is triggered when new data is received from the\ntarget node after TCP::collect command has been issued. For UDP, this\nevent fires on receipt of each segment from the client.\n\nNOTE: Per F5 Solution SOL14563 it is better to process UDP data in\nCLIENT_ACCEPTED than in this event.\n    ","examples":"\nwhen CLIENT_DATA {\n  if { [UDP::payload 50] contains \"XYZ\" } {\n    pool xyz_servers\n    persist uie \"[IP::client_addr]:[UDP::client_port]\" 300\n  }\n}\n    "},
{"categories:":["GLOBAL"],"eventName":"PERSIST_DOWN","profiles:":[],"description":"\nPERSIST_DOWN is triggered when LTM is ready to send the request to a\nparticular node or pool member via persistence and it has been marked\ndown. This is usually because the server has been detected as\nunreachable (when no route to the target exists) or non-responsive\n(failed to respond to a connection request).\n\n    ","examples":"\nwhen PERSIST_DOWN {\n  pool errorPool\n}\n\n\nwhen PERSIST_DOWN {\n  HTTP::respond 501\n  reject\n}\n    "},
{"categories:":["RULE_INIT_CATEGORY"],"eventName":"RULE_INIT","profiles:":[],"description":"\nUse this event to initialize global or static variables used\nwithin iRules.\n\nExecution\n\n   This event is triggered under the following conditions;\n     * when an iRule using the event is saved.\n     * when the device starts up.\n     * when the software is restarted.\n\n\nScope\n\n   The RULE_INIT event is global in scope and is triggered without the\n   context of a virtual server or client to virtual server connection.\n\nNamespace\n\n   Variables defined in this event are global across the F5 and share the\n   same namespace with any iRule that uses this event.\n\nLimitations\n\n   Global variables modified by an iRule will demote the execution of the\n   virtual to a single processor core. On a BIG-IP with a quad core\n   processor, the virtual will only be able to use one of them. See\n   CMP Compatibility for more details.\n\n    ","examples":"\nwhen RULE_INIT {\n  set ::count 0\n}\n\n# static namespace is available in 10.0.0+\nwhen RULE_INIT {\n  set static::debug 1\n}\n    "},
{"categories:":["IP","SERVERSIDE","TCP","SCTP","UDP"],"eventName":"SERVER_CLOSED","profiles:":[],"description":"\nAn iRule event triggered when the server side connection closes.\nThe SERVER_CLOSED event also fires for UDP traffic when the Idle\nTimeout for the UDP profile is reached. On a Virtual Server whose UDP\nprofile selects \"Datagram LB\", this event fires after every response\nfrom the server.\n    ","examples":"\nwhen SERVER_CLOSED {\n  log local0. \"Server [IP::server_addr] has closed the connection\"\n}\n    "},
{"categories:":["IP","SERVERSIDE","TCP","SCTP","UDP"],"eventName":"SERVER_CONNECTED","profiles:":[],"description":"\nAn iRule event triggered when a connection has been established\nwith the target node.\n\n    ","examples":"\nwhen SERVER_CONNECTED {\n  log local0. \"FTP connection from[IP::client_addr]:[TCP::client_port]. \\\n    Mapped to [serverside {IP::local_addr}]:[serverside {TCP::local_port}] \\\n    -> [IP::server_addr]:[serverside {TCP::remote_port}]\"\n}\n    "},
{"categories:":["IP","SERVERSIDE","TCP","SCTP","UDP"],"eventName":"SERVER_DATA","profiles:":[],"description":"\nFor TCP, this event is triggered when new data is received from\nthe target node after TCP::collect command has been issued. For\nUDP, this event fires on receipt of each segment from the server.\nUnlike TCP, no collect is required, and there is no release\ncommand.\n\n    ","examples":"\nwhen SERVER_CONNECTED {\n  TCP::collect\n}\nwhen SERVER_DATA {\n  set payload [TCP::payload]\n}\n    "},
{"categories:":["GTP"],"eventName":"GTP_GPDU_EGRESS","profiles:":["GTP"],"description":"\nFired for a message that has GTP message-type = 255 on the connection that forwards/egresses the message.\n    ","examples":"\n        when GTP_GPDU_EGRESS {\n            log local0. \"Sent a GTP_GPDU command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["GTP"],"eventName":"GTP_GPDU_INGRESS","profiles:":["GTP"],"description":"\nFired for a message that has GTP message-type = 255 on the the connection that accepted the message.\n    ","examples":"\n        when GTP_GPDU_INGRESS {\n            log local0. \"Received a GTP_GPDU command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["GTP"],"eventName":"GTP_PRIME_EGRESS","profiles:":["GTP"],"description":"\nFired only for GTP prime messages for revision 1 on the connection that forwards/egresses the message.\n    ","examples":"\n        when GTP_PRIME_EGRESS {\n            log local0. \"Sent a GTP_PRIME command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["GTP"],"eventName":"GTP_PRIME_INGRESS","profiles:":["GTP"],"description":"\nFired only for GTP prime messages for revision 1 on the connection that accepted the message.\n    ","examples":"\n        when GTP_PRIME_INGRESS {\n            log local0. \"Received a GTP_PRIME command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["GTP"],"eventName":"GTP_SIGNALLING_EGRESS","profiles:":["GTP"],"description":"\nFired for any GTP-message except G-PDU on the connection that forwards/egresses the message.\n    ","examples":"\n        when GTP_SIGNALLING_EGRESS {\n            log local0. \"Sent a GTP_SIGNALLING command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["GTP"],"eventName":"GTP_SIGNALLING_INGRESS","profiles:":["GTP"],"description":"\nFired for any GTP-message except G-PDU on the connection that accepted the message.\n    ","examples":"\n        when GTP_SIGNALLING_INGRESS {\n            log local0. \"Received a GTP_SIGNALLING command, with payload [GTP::payload]\"\n        }\n    "},
{"categories:":["HTTP","CLIENTSIDE"],"eventName":"HTML_COMMENT_MATCHED","profiles:":["HTTP"],"description":"\nThe HTML_COMMENT_MATCHED event is raised when an HTML comment is encountered in a document and there is a rule attached to the HTML profile that says to raise an event on matching comments.\n    ","examples":"\nwhen HTML_COMMENT_MATCHED {\n  if { ! ( [HTML::comment] contains \"\\[\" ) } {\n    HTML::comment remove\n  }\n}\n\nwhen HTML_COMMENT_MATCHED {\n  HTML::comment append \"some_string\"\n}\n\nwhen HTML_COMMENT_MATCHED {\n  HTML::comment prepend \"some_string\"\n}\n    "},
{"categories:":["HTTP","CLIENTSIDE"],"eventName":"HTML_TAG_MATCHED","profiles:":["HTTP"],"description":"\nThe HTML_TAG_MATCHED event is raised when an HTML tag is encountered in a document and there is a rule attached to the HTML profile that says to raise an event on matching tag with the specific tag name and optionally the specific attribute name and value.\n    ","examples":"\nwhen HTTP_REQUEST {\n    set uri [HTTP::uri]\n    HTTP::header replace \"Host\" \"finance.yahoo.com\"\n}\nwhen HTTP_RESPONSE {\n    if { $uri equals \"/\" } {\n        HTML::enable\n    } else {\n        HTML::disable\n    }\n}\nwhen HTML_TAG_MATCHED {\n    log local0. \"element = [HTML::tag name]\"\n    log local0. \"attribute id = [HTML::tag attribute id]\"\n\n    switch [HTML::tag name] {\n        \"form\" {\n            if { [HTML::tag attribute \"id\"] equals \"quote\" } {\n                set inject_js 1\n            }\n        }\n        \"/form\" {\n            if { [info exists inject_js] && $inject_js == 1 } {\n                unset inject_js\n                HTML::tag append \"<scr\"\n                HTML::tag append \"ipt>\"\n                HTML::tag append \"function submitForm() {\"\n                HTML::tag append \"  document.quote.s.value='FFIV';\"\n                HTML::tag append \"  document.quote.submit();\"\n                HTML::tag append \"}\"\n                HTML::tag append \"setTimeout('submitForm()', 5000);\"\n                HTML::tag append \"</script>\"\n            }\n        }\n    }\n}\n    "},
{"categories:":["IP","TCP"],"eventName":"HTTP_DISABLED","profiles:":["HTTP"],"description":"\nTriggers when HTTP is disabled.\n\n    ","examples":"\nwhen HTTP_DISABLED {\n  log local0. \"Passthru reason: [HTTP::passthrough_reason]\"\n}\n    "},
{"categories:":["HTTP"],"eventName":"HTTP_PROXY_REQUEST","profiles:":["HTTP"],"description":"\nTriggered when a virtual server has proxy-mode explicit set and one of the following two scenarios are true:\n\n    * the request has a full uri of the form http://hostname:port/path (much like HTTP_REQUEST, but with access to the original uri)\n    * the request is a CONNECT request (e.g. CONNECT hostname:port HTTP/1.1)\n\nThis event allows manipulation of either the request URI, or control of whether the BIG-IP performs the proxy action.\n    ","examples":"\n# Example 1: Simple Proxy Chaining\n\nwhen HTTP_PROXY_REQUEST {\n    if { (not [HTTP::method] == \"CONNECT\") && [URI::host [HTTP::uri]] ends_with \".internal.domain.com\" } {\n          HTTP::proxy disable\n          pool internal_proxy_3128\n    } else {\n          HTTP::proxy enable\n    }\n}\n\n\n# Example 2: Advanced Proxy Chaining & URI Rewriting\n\nwhen HTTP_PROXY_REQUEST {\n    log local0. \"[HTTP::method] [HTTP::uri]\"\n    switch [string tolower [URI::host [HTTP::uri]]] {\n        \"www.google.com\" {\n             # send request to default pool (aka proxy-chaining)\n             HTTP::proxy disable\n         }\n         \"www.abc.com\" {\n             # change request to a different host - remains a proxy request\n             HTTP::uri http://www.google.com/\n         }\n         \"www.def.com\" {\n             # change request to a normal (not proxy) request - goes to the default pool\n             HTTP::uri /def.html\n          }\n     }\n}\n\nwhen HTTP_REQUEST {\n    log local0. \"[HTTP::method] [HTTP::uri]\"\n}\n\n\n# Example 3: Proxy Chaining via Categorization (Requires either an SWG or URL Filtering Subscription)\n\nwhen RULE_INIT {\n    log local0. \"Proxy Chain iRule\"\n    set static::Proxy_Chain_categories {\n       /Common/Restaurants_and_Dining\n    }\n    set static::Proxy_Chain_debug 1\n}\n\nwhen HTTP_PROXY_REQUEST {\n    set proxy_chain 0\n    if { $static::Proxy_Chain_debug } { log local0. \"URI: [HTTP::uri]\" }\n\n    # Check for a category match\n    set reply [getfield [CATEGORY::lookup [HTTP::uri]] \" \" 1]\n    if {[lsearch -exact $static::Proxy_Chain_categories $reply] >= 0}{\n        if { $static::Proxy_Chain_debug } { log local0. \"HIT: The category $reply should be bypassed for [HTTP::uri]\" }\n        set proxy_chain 1\n    }\n\n    # Check for a URI::host for HTTP connections\n    if {[URI::host [HTTP::uri]] == \"www.cariboucoffee.com\"} {\n        set proxy_chain 1\n    }\n\n    # Perform the prescibed action\n    if { $proxy_chain } {\n        if { $static::Proxy_Chain_debug } { log local0. \"Proxy Chain: [HTTP::method] URI:[HTTP::uri]\" }\n        HTTP::proxy disable\n        snat 10.10.1.10\n        pool squid\n    }\n}\n    "},
{"categories:":["HTTPPROXYCONNECT"],"eventName":"HTTP_PROXY_CONNECT","profiles:":["HTTP_PROXY_CONNECT"],"description":"\nTriggered when the CONNECT request is generated in the HTTP_PROXY_CONNECT filter.\n\nThis event allows modification of the CONNECT request headers in HTTP Proxy chaining.\nHTTP iRule commands in this event refer to the proxy chaining request, not the original request from the client.\n    ","examples":"\nwhen HTTP_PROXY_CONNECT {\n    HTTP::header insert Proxy_Header \"Header Value\"\n}\n    "},
{"categories:":["HTTPPROXYCONNECT"],"eventName":"HTTP_PROXY_RESPONSE","profiles:":["HTTP_PROXY_CONNECT"],"description":"\nTriggered when the response to HTTP Proxy chaining CONNECT request is received in the HTTP_PROXY_CONNECT filter.\n\nThis event allows inspection of the CONNECT response headers.\n\nThe \"HTTP::proxy chain retry\" command may be used to retry a failed request.\n    ","examples":"\nwhen HTTP_PROXY_RESPONSE {\n    log local0. \"HTTP Proxy response:\" [HTTP::response]\n}\n    "},
{"categories:":["IP","TCP"],"eventName":"HTTP_REJECT","profiles:":[],"description":"\nTriggers when HTTP encounters an error condition, and aborts the connection.  This event is designed for debugging issues with the HTTP filter.\nNote that when this event is triggered most HTTP commands will not work as all HTTP connection state will have been aborted.  You may want to store useful information in earlier iRule events in TCL variables to be printed in log messages here.\n    ","examples":"\nwhen HTTP_REJECT {\n    log local0. \"HTTP Aborted:\" [HTTP::reject_reason]\n}\n    "},
{"categories:":["HTTP"],"eventName":"HTTP_REQUEST","profiles:":["FASTHTTP","HTTP"],"description":"\nAn iRule event triggered when the system fully parses the complete\nclient HTTP request headers (that is, the method, URI, version, and all\nheaders, not including the HTTP request body).\n\n    ","examples":"\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] contains \"secure\"} {\n    HTTP::redirect \"https://[HTTP::host][HTTP::uri]\"\n  }\n}\n    "},
{"categories:":["HTTP"],"eventName":"HTTP_REQUEST_DATA","profiles:":["HTTP"],"description":"\nAn iRule event triggered when an HTTP::collect command has\ncollected the specified amount of request data. Also triggered if the\nclient closes the connection before the HTTP::collect command\nfinishes processing.\n\n    ","examples":"\nwhen HTTP_REQUEST {\n  HTTP::collect 20\n}\nwhen HTTP_REQUEST_DATA {\n  # do stuff with the payload\n  log local0. \"The first 20 bytes of the payload are: [HTTP::payload]\"\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"HTTP_REQUEST_RELEASE","profiles:":["HTTP"],"description":"\nAn iRule event triggered when the system is about to release HTTP\ndata on the serverside of the connection. This event is triggered\nafter modules process the HTTP response.\n\n    ","examples":"\nwhen HTTP_REQUEST_RELEASE {\n  log local0. \"[IP::client_addr]:[TCP::client_port]: [HTTP::method] to [HTTP::host][HTTP::uri] using pool [LB::server]\"\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"HTTP_REQUEST_SEND","profiles:":["HTTP"],"description":"\nAn iRule event triggered immediately before an HTTP request is\nsent to the server-side TCP stack. This is a server-side event. Because\nof that, if you wish to execute commands in a client-side context in\nthis event, you will need to use the clientside command to do so.\n\n    ","examples":"\n##\nwhen HTTP_REQUEST_SEND {\n  TCP::collect 12\n}\n\n\n## Replace HTTP host header value with the connected server IP and port\nwhen HTTP_REQUEST_SEND {\n\n   # Need to force the host header replacement and HTTP:: commands into the clientside context\n   # as the HTTP_REQUEST_SEND event is in the serverside context\n   clientside {\n      # Replace the HTTP host header with the connected server IP and port\n      HTTP::header replace Host \"[IP::server_addr]:[TCP::server_port]\"\n   }\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"HTTP_RESPONSE","profiles:":["HTTP"],"description":"\nAn iRule event triggered when the system parses all of the\nresponse status and header lines from the server response.\n\nNote: HTTP_RESPONSE is specific to a server response passing through\nthe load balancer, and is not triggered for locally-generated responses\n(e.g. sent using the HTTP::respond command)\n\n    ","examples":"\nwhen HTTP_RESPONSE {\n  if { [HTTP::status] contains \"404\"} {\n    HTTP::redirect \"http://www.siterequest.com/\"\n  }\n}\n\n\nwhen HTTP_RESPONSE {\n  HTTP::header insert SERVER_ADDRESS [IP::server_addr]\n  log \"SERVER_ADDRESS [IP::server_addr]\"\n}\n\nIf the reject command is used in this event without HTTP::collect, the\nBIG-IP will forward the server generated headers to the client, then\nsend a TCP RST segment. To send a RST without headers in response to a\nspecific server response condition, execute HTTP::collect before\nreject, as in:\n\nwhen HTTP_RESPONSE {\n    if { [HTTP::status] == 404 } {\n        HTTP::collect\n        reject\n    }\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"HTTP_RESPONSE_CONTINUE","profiles:":["HTTP"],"description":"\nAn iRule event triggered whenever the system receives a 100 Continue\nresponse from the server.\n\n    ","examples":"\nwhen HTTP_RESPONSE_CONTINUE {\n  if { [HTTP::version] != 1.1 } {\n    log \"Buggy server: sent 100-Continue to non-1.1 client!\"\n  }\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"HTTP_RESPONSE_DATA","profiles:":["HTTP"],"description":"\nAn iRule event triggered when an HTTP::collect command has\ncollected the specified amount of response data. Also triggered if the\nserver closes the connection before the HTTP::collect command\nfinishes processing.\n\n    ","examples":"\nwhen HTTP_RESPONSE_DATA {\n    regsub \"oursite\" [HTTP::payload] \"oursitedev\" fixeddata\n    log \"Replacing payload with fixed data.\"\n    HTTP::payload replace 0 $clen $fixeddata\n    HTTP::release\n}\n    "},
{"categories:":["HTTP"],"eventName":"HTTP_RESPONSE_RELEASE","profiles:":["HTTP"],"description":"\nAn iRule event triggered when the system is about to release HTTP\ndata on the clientside of the connection. This event is triggered\nafter modules process the HTTP response.\n\n    ","examples":"\nwhen HTTP_RESPONSE_RELEASE {\nlog local0. \"[IP::client_addr]:[TCP::client_port]: [HTTP::status] response to from [IP::server_addr]:[TCP::server_port]\"\n}\n    "},
{"categories:":["ICAP"],"eventName":"ICAP_REQUEST","profiles:":["ICAP"],"description":"\nAn ICAP request has been created but has not yet been sent to the\nICAP server. The ICAP headers have been created and may be inspected\nand modified at this point.\n    ","examples":"\n        when ICAP_REQUEST {\n            ICAP::header add X-ICAP-my-custom-header foobar\n        }\n    "},
{"categories:":["ICAP"],"eventName":"ICAP_RESPONSE","profiles:":["ICAP"],"description":"\nICAP response headers have been received but the result has not yet\nbeen communicated back to the HTTP adaptation virtual server.\nThe ICAP::status command may be used to obtain the status code.\nThe encapsulated HTTP request or response has not yet been received.\n    ","examples":"\n        when ICAP_RESPONSE {\n            ICAP::header remove X-ICAP-my-custom-header\n        }\n    "},
{"categories:":["PROTOCOL_INSPECTION"],"eventName":"PROTOCOL_INSPECTION_MATCH","profiles:":["IPS"],"description":"\nTriggered when protocol inspection is matched for this flow.\n    ","examples":"\nIn the example, the PROTOCOL_INSPECTION::id array is logged.\n\nwhen PROTOCOL_INSPECTION_MATCH {\n    set id [PROTOCOL_INSPECTION::id]\n    log local0.debug \"inspection id: $id\"\n}\n    "},
{"categories:":["IVS_ENTRY"],"eventName":"IVS_ENTRY_REQUEST","profiles:":[],"description":"\nThe internal virtual server has received a request to process,\nfrom the parent virtual server (client side).\n    ","examples":"\n        when IVS_ENTRY_REQUEST {\n            # Tell primary virtual the IVS will not handle this request\n            IVS_ENTRY::result noop\n        }\n    "},
{"categories:":["IVS_ENTRY"],"eventName":"IVS_ENTRY_RESPONSE","profiles:":[],"description":"\nThe internal virtual server has received a response to process,\nfrom the parent virtual server (server side).\n    ","examples":"\n        when IVS_ENTRY_RESPONSE {\n            # Tell primary virtual the IVS will not handle this response\n            IVS_ENTRY::result noop\n        }\n    "},
{"categories:":["GLOBAL"],"eventName":"LB_FAILED","profiles:":[],"description":"\nLB_FAILED is triggered when LTM is ready to send the request to a pool member and one hasn’t been chosen (the system failed to select a pool or a pool member), is unreachable (when no route to the target exists), has reached a queue limit, or is non-responsive (fails to respond to a connection request).\n\nIf the target fails to respond to a connection request, the \"Maximum Syn Retransmissions\" option in the TCP profile will affect the amount of time before LB_FAILED is triggered.\n\nWhen a client doesn't receive a response to the SYN, there is a defined algorithm for the specified number of re-tries. First retransmission if no response is typically 3 seconds, and typical back-off timer algorithm is to double the wait time after each failed attempt. Most TCP stacks set Max Syn Retransmits to 5, producing the following progression and timing out after 93 seconds:\n\nTrying 172.24.2.200...\n11:26:24.455153 172.24.2.41.55507 > 172.24.2.200.http: S ...\n11:26:27.452465 172.24.2.41.55507 > 172.24.2.200.http: S ...\n11:26:33.452465 172.24.2.41.55507 > 172.24.2.200.http: S ...\n11:26:45.452465 172.24.2.41.55507 > 172.24.2.200.http: S ...\n11:27:09.452481 172.24.2.41.55507 > 172.24.2.200.http: S ...\n11:27:57.452466 172.24.2.41.55507 > 172.24.2.200.http: S ...\ntelnet: connect to address 172.24.2.200: Connection timed out\n\nIn past versions, LTM's default TCP profile sets \"Maximum Syn Retransmissions\" to 4, so with the default setting, LB_FAILED would be triggered if server didn't respond in 45 seconds:\n\n1st SYN:  0\n2nd SYN: +3 seconds\n3rd SYN: +6 seconds\n4th SYN: +12 seconds\n5th SYN: +24 seconds\n======================\nLB_FAILED: 45 seconds\n\nReducing \"Maximum Syn Retransmissions\" to 2 will result in the trigger of the LB_FAILED event in 9 seconds, which makes recovery logic in the LB_FAILED event much more useful as a backup to monitoring.\n    ","examples":"\nwhen DNS_REQUEST {\n    if {[active_members poolName] < 2} {\n        pool fallbackPool\n    }\n}\nwhen LB_FAILED {\n    pool errorPool\n}\n    "},
{"categories:":["GLOBAL","SERVERSIDE"],"eventName":"LB_SELECTED","profiles:":[],"description":"\nTriggered when the system selects a pool member.\n    ","examples":"\nwhen LB_SELECTED {\n    if { [IP::addr [IP::client_addr] equals 10.0.0.1] } {\n        # Apply a snat\n        snat VIPsnat\n    }\n}\n    "},
{"categories:":["GLOBAL","SERVERSIDE"],"eventName":"LB_QUEUED","profiles:":[],"description":"\nLB_QUEUED is a serverside event triggered when a connection limit is hit at the pool or pool member level. HTTP redirection is permissible in this event, but HTTP::retry is not. If the queue limit is exceeded, LB_FAILED will be triggered.\n    ","examples":"\nwhen LB_QUEUED {\n    log local0. \"[IP::local_addr] was queued - [LB::queue depth one\n        pool1] / [LB::queue limit depth pool1]\"\n}\n\nwhich with a queue depth of 5 returns:\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 1/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 2/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 3/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 4/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 5/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 5/5\n    "},
{},
{},
{"categories:":["IP","TCP","MQTT"],"eventName":"MQTT_CLIENT_INGRESS","profiles:":[],"description":"\nThis iRule event triggers when an MQTT message is received from client-side.\nIn case an MQTT message has large payload such as for PUBLISH message types,\nthis event may trigger before entire payload is received. In that case,\nMQTT::collect may be used to obtain the payload.\n    ","examples":"\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n      \"CONNECT\" {\n          log local0.info \"New connection from [MQTT::username], [MQTT::client_id]\"\n      }\n    }\n}\n    "},
{"categories:":["IP","TCP","MQTT"],"eventName":"MQTT_CLIENT_DATA","profiles:":[],"description":"\nThis iRule event triggers when payload data collection invoked\nusing MQTT::collect iRule command finishes. This iRule event\nis for client-side.\n    ","examples":"\n#Example: Redirect PUBLISH that has payloads with blocked keywords defined in\n#blacklisted_keywords_datagroup in first 200 bytes. Prepend a admin message in\n#the payload.\n#\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"PUBLISH\" {\n          if { [class exists  blacklisted_keywords_datagroup] } {\n             MQTT::collect 200\n          }\n       }\n    }\n}\n\nwhen MQTT_CLIENT_DATA {\n   set type [MQTT::type]\n   switch $type {\n       \"PUBLISH\" {\n          set payload [MQTT::payload]\n          set found [class match $payload contains blacklisted_keywords_datagroup]\n          if { $found != \"\" } {\n             set topic [MQTT::topic]\n             MQTT::topic \"/bigip/quarantined/$topic\"\n             MQTT::payload prepend \"!!!!!! QUARANTINED Message !!!!!!\"\n          }\n          MQTT::release\n       }\n   }\n}\n    "},
{"categories:":["IP","TCP","MQTT"],"eventName":"MQTT_SERVER_INGRESS","profiles:":[],"description":"\nThis iRule event triggers when an MQTT message is received from server-side.\nIn case an MQTT message has large payload such as for server\nPUBLISH message types, this event may trigger before entire payload\nis received. In that case, MQTT::collect may be used to obtain the payload.\n    ","examples":"\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"CONNACK\" {\n          log local0.info \"New connection ack [MQTT::return_code]\"\n      }\n   }\n}\n    "},
{"categories:":["IP","TCP","MQTT"],"eventName":"MQTT_SERVER_DATA","profiles:":[],"description":"\nThis iRule event triggers when payload data collection invoked\nusing MQTT::collect iRule command finishes. This iRule event\nis for server-side.\n    ","examples":"\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"PUBLISH\" {\n         MQTT::collect 200\n      }\n   }\n}\n\nwhen MQTT_SERVER_DATA {\n   set type [MQTT::type]\n   switch $type {\n      \"PUBLISH\" {\n         set collected [MQTT::payload]\n         MQTT::release\n         log local0.info \"collected : $collected\"\n      }\n   }\n}\n    "},
{"categories:":["MR"],"eventName":"MR_EGRESS","profiles:":[],"description":"\nThis event is raised after the route has been selected and processed and the message is delivered to the mr_proxy for forwarding on the new connflow.\n    ","examples":"\nwhen MR_INGRESS {\n    set client_addr \"[IP::remote_addr]:[TCP::remote_port]\"\n    MR::store client_addr\n}\nwhen MR_EGRESS {\n    MR::restore client_addr\n}\n    "},
{"categories:":["MR"],"eventName":"MR_FAILED","profiles:":[],"description":"\nThis event is raised when a message has been returned to the originating flow due to a routing failure.\n    ","examples":"\nwhen MR_FAILED {\n    log local0. \"Routing failed with status [MR::message status]\"\n}\n    "},
{"categories:":["MR"],"eventName":"MR_INGRESS","profiles:":[],"description":"\nThis event is raised when a message is received by the message proxy and before a route lookup occurs. Setting the route for a message will bypass route lookup.\n    ","examples":"\nwhen MR_INGRESS {\n    set client_addr \"[IP::remote_addr]:[TCP::remote_port]\"\n    MR::store client_addr\n}\nwhen MR_EGRESS {\n    MR::restore client_addr\n}\n    "},
{"categories:":["GLOBAL"],"eventName":"NAME_RESOLVED","profiles:":[],"description":"\nThis event is triggered after a NAME__lookup command has been issued and a response has been received. This response could be either a success or a failure.\n    ","examples":"\nwhen HTTP_REQUEST {\n    NAME::lookup [HTTP::host]\n}\n\nwhen NAME_RESOLVED {\n    node [NAME::response] 80\n\n}\n    "},
{"categories:":["PCP"],"eventName":"PCP_REQUEST","profiles:":[],"description":"\nTriggered on receipt of a valid PCP (Port Control Protocol) request from a client.\n    ","examples":"\nwhen PCP_REQUEST {\n    if {[PCP::request opcode] == \"map\" &&\n        [PCP::request internal-port] == 22 } {\n            log \"Rejecting PCP request to map SSH\"\n            PCP::reject 1\n        }\n}\n    "},
{"categories:":["PCP"],"eventName":"PCP_RESPONSE","profiles:":[],"description":"\nTriggered when a PCP (Port Control Protocol) response, successful or not, is returned to the client.\n    ","examples":"\nwhen PCP_RESPONSE {\n    if {[PCP::response opcode] == \"map\" && [PCP::response result] != 0] } {\n        log \"PCP map request from\\\n            [PCP::response client-addr]:[PCP::response internal-port]\\\n            failed with a result of [PCP::response result]\"\n    }\n}\n    "},
{"categories:":["PEM"],"eventName":"PEM_POLICY","profiles:":[],"description":"\nThis event is triggered when a PEM policy is evaluated.\n\nNote: the Policy Enforcement Manager license is required for functionality to work.\n    ","examples":"\nwhen PEM_POLICY {\n  PEM::session create 117.13.4.135 subscriber-id test-id subscriber-type e164\n}\n    "},
{"categories:":["PING"],"eventName":"PING_REQUEST_READY","profiles:":["HTTP"],"description":"\nThis event is triggered to execute HTTP commands before the request to ping access server is released.\n    ","examples":"\n        when PING_REQUEST_READY {\n            HTTP::header insert header_1 value_1\n        }\n    "},
{"categories:":["PING"],"eventName":"PING_RESPONSE_READY","profiles:":["HTTP"],"description":"\nThis event is triggered to execute HTTP commands after the response from ping access server is received.\n    ","examples":"\n        when PING_RESPONSE_READY {\n            HTTP::header insert header_1 value_1\n        }\n    "},
{"categories:":["QOE"],"eventName":"QOE_PARSE_DONE","profiles:":["QOE"],"description":"\nThis event is triggered when the system finishes parsing the static\nvideo parameters from video header part. This event applies to MP4, FLV\nand their derivatives, but not to the Apple HLS video (i.e., TS segment\nand m3u8 file) or other video formats.\n\nThis event allows proactive action taken to improve the user video\nexperience. For example, by applying the \"nominal_bitrate\" attribute to\nBandwidth Controller (BWC), the service provider can ensure a\njust-in-time video delivery (i.e., video pacing).\n\nIn addition, the service provider can use \"width\", \"height\" and\n\"nominal_bitrate\" to estimate if the ongoing video is of high\ndefinition (HD) video, medium definition video or low definition video.\n\n    ","examples":"\n\n    "},
{"categories:":["HTTP","CLIENTSIDE"],"eventName":"REWRITE_REQUEST","profiles:":["HTTP"],"description":"\nRaised at the end of rewriting request headers.\n    ","examples":"\n\n    "},
{"categories:":["HTTP","CLIENTSIDE"],"eventName":"REWRITE_REQUEST_DONE","profiles:":["HTTP"],"description":"\nAn iRule event that is always triggered after the ACCESS_ACL_ALLOWED\nevent when a Portal Access resource is accessed.\n\n    ","examples":"\nwhen REWRITE_REQUEST_DONE {\n  log local0. \"[HTTP::uri]\"\n  foreach header_name [HTTP::header names] {\n    log local0. \"  $header_name -> [HTTP::header value $header_name]\"\n  }\n  REWRITE::post_process 1\n}\n\n\nwhen REWRITE_REQUEST_DONE {\n    switch \"[HTTP::host][HTTP::path]\" {\n        \"intra.fp.f5net.com/contents.php\" {\n            set match 1\n            REWRITE::post_process 1\n        }\n        default {\n            # Reset the value of match\n            # log local0. \"No match for [HTTP::host][HTTP::path]\"\n            set match 0\n        }\n    }\n}\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"REWRITE_RESPONSE","profiles:":["HTTP"],"description":"\nRaised at the end of rewriting response headers.\n    ","examples":"\n\n    "},
{"categories:":["HTTP","SERVERSIDE"],"eventName":"REWRITE_RESPONSE_DONE","profiles:":["HTTP"],"description":"\nAn iRule event that is only trigged when the REWRITE_REQUEST_DONE event\ncalls REWRITE::post_process on.\n\n    ","examples":"\nwhen REWRITE_RESPONSE_DONE {\n  log local0. \"length :: [REWRITE::payload length] ::\"\n  log local0. \"payload:: [REWRITE::payload] ::\"\n}\n\n\nwhen REWRITE_RESPONSE_DONE {\n  set data [REWRITE::payload]\n\n  set start [string first <b> $data]\n  set end [string first </b> $data]\n  set end [expr {$end + [string length \"</b>\"]}]\n  set length [expr {$end - $start}]\n\n  REWRITE::payload replace $start $length {<b>Hello World</b>}\n}\n    "},
{"categories:":["RTSP"],"eventName":"RTSP_REQUEST","profiles:":[],"description":"\nTriggered after a complete request has been received from either the\nclient or the server. You can use the RTSP::msg_source command to\ndetermine if the message originated from the client or server.\n    ","examples":"\nwhen RTSP_REQUEST {\n    RTSP::collect 10\n}\nwhen RTSP_REQUEST_DATA {\n    RTSP::release\n}\n    "},
{"categories:":["RTSP"],"eventName":"RTSP_REQUEST_DATA","profiles:":[],"description":"\nTriggered whenever an RTSP::collect command finishes processing.\n\n    ","examples":"\nwhen RTSP_REQUEST_DATA {\n  #\n}\n    "},
{"categories:":["RTSP","CLIENTSIDE","SERVERSIDE"],"eventName":"RTSP_RESPONSE","profiles:":[],"description":"\nTriggered after a complete response has been received from either the\nclient or the server. You can use the RTSP::msg_source command to\ndetermine if the message originated from the client or server.\n    ","examples":"\nwhen RTSP_RESPONSE {\n  log local0. \"Received RTSP response from [RTSP::msg_source]\"\n}\n    "},
{"categories:":["RTSP"],"eventName":"RTSP_RESPONSE_DATA","profiles:":[],"description":"\nTriggered when collection of response data is finished.\n\n    ","examples":"\nwhen RTSP_REQUEST {\n    RTSP::collect 10\n}\nwhen RTSP_REQUEST_DATA {\n    RTSP::release\n}\n    "},
{"categories:":["SIP","SIPSESSION"],"eventName":"SIP_REQUEST","profiles:":["SIP","SIPSESSION","SIPROUTER"],"description":"\nTriggered when the system fully parses a complete client SIP request header.\n    ","examples":"\nwhen SIP_REQUEST {\n    log local0. \"Call ID [SIP::call_id]\"\n}\n    "},
{"categories:":["SIP","SIPSESSION","SERVERSIDE"],"eventName":"SIP_REQUEST_SEND","profiles:":["SIP","SIPSESSION","SIPROUTER"],"description":"\nTriggered immediately before a SIP request is sent.\n    ","examples":"\nwhen SIP_REQUEST_SEND {\n    if {[SIP::method] == \"BYE\"} {\n        persist delete sip [SIP::call_id]\n    }\n    else {\n        persist add sip [SIP::call_id]\n    }\n}\n    "},
{"categories:":["SIP","SIPSESSION","SERVERSIDE"],"eventName":"SIP_RESPONSE","profiles:":["SIP","SIPSESSION","SIPROUTER"],"description":"\nTriggered when the system parses all of the response status and header lines from the server response.\n    ","examples":"\nwhen SIP_RESPONSE {\n    log local0. \"Call ID [SIP::call_id]\"\n}\n    "},
{"categories:":["SIP","SIPSESSION","SERVERSIDE"],"eventName":"SIP_RESPONSE_SEND","profiles:":["SIP","SIPSESSION","SIPROUTER"],"description":"\n        Triggered immediately before a SIP response is sent.\n    ","examples":"\nwhen SIP_RESPONSE_SEND {\n  log local0. [SIP::route_status]\n}\n    "},
{"categories:":["SOCKS"],"eventName":"SOCKS_REQUEST","profiles:":["SOCKS"],"description":"\nThis event is triggered upon receipt of a SOCKS command on a SOCKS connection, before authentication is done.\n    ","examples":"\nwhen SOCKS_REQUEST {\n    log local0. \"SOCKS is using version [SOCKS::version]\"\n}\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_CLIENTCERT","profiles:":["CLIENTSSL","PERSIST"],"description":"\nTriggered when the system receives a certificate message from the client. The message may contain zero or more certificates. The BIG-IP system can retrieve the X509 certificate and its X509 issuer with the SSL::cert and SSL::cert issuer commands.\n    ","examples":"\nwhen CLIENTSSL_CLIENTCERT {\n  # Save the first client cert to a variable.  Not sure why, but...\n  set ssl_cert [SSL::cert 0]\n\n  # Using the SSL session ID as the key,\n  # add the cert to the session table with a timeout of 180 seconds\n  session add ssl [SSL::sessionid] $ssl_cert 180\n}\n\nwhen CLIENTSSL_CLIENTCERT {\n\n   # Debug flag\n   set debug 1\n\n   # Check if client presented a cert after it was requested/required\n   if {[SSL::cert count] > 0}{\n\n      # Client presented at least one cert.  The actual client cert should always be first.\n      if {$debug > 1}{\n\n     # Loop through each cert and log the cert subject, issuer and serial number\n         for {set i 0} {$i < [SSL::cert count]} {incr i}{\n\n            log local0. \"[IP::client_addr]:[TCP::client_port]: cert #$i; subject=[X509::subject [SSL::cert $i]];\\\n               [X509::issuer [SSL::cert $i]]; cert_serial=[X509::serial_number [SSL::cert $i]];\"\n         }\n      }\n   } else {\n      if {$debug > 1}{log local0. \"[IP::client_addr]:[TCP::client_port]: No client cert found!\"}\n   }\n}\n\nSample log output:\n\n<CLIENTSSL_CLIENTCERT>: client IP:port=1.1.1.1:3953: cert 0; subject: emailAddress=some_user@example.com,CN=Some User,OU=Example OU,OU=Example2 OU; issuer: CN=Example CA Customer CA,O=Secure Internet Services Ltd.; cert_serial=22:22:22:22:22:22:22:22:22:22;\n<CLIENTSSL_CLIENTCERT>: client IP:port=1.1.1.1:3953: cert 1; subject: CN=Example CA Customer CA,O=Secure Internet Services Ltd.; issuer: CN=Example CA Primary CA,O=Secure Internet Services Ltd; cert_serial=11:11:11:11:11:11:11:11:11:11;\n<CLIENTSSL_CLIENTCERT>: client IP:port=1.1.1.1:3953: cert 2; subject: CN=Example CA Primary CA,O=Secure Internet Services Ltd; issuer: CN=Example CA Root CA,O=Secure Internet Services Ltd; cert_serial=00:00:00:00:00:00:00:00:00:00;\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_CLIENTHELLO","profiles:":["CLIENTSSL","PERSIST"],"description":"\nTriggered when the system has received the client's SSL ClientHello message, and before the system sends its SSL ServerHello message. Zero or more SSL extensions may be received from or sent to the peer at this stage in the SSL handshake.\n    ","examples":"\nwhen CLIENTSSL_CLIENTHELLO {\n    set my_ext \"Hello world!\"\n    set my_ext_type 62965\n    SSL::extensions insert [binary format S1S1a* $my_ext_type [string length $my_ext] $my_ext]\n}\n\nwhen CLIENTSSL_CLIENTHELLO {\n    set ext_count [SSL::extensions count]\n    log local0.info \"SSL::extensions count = $ext_count\"\n\n    for {set i 0} {$i<$ext_count} {incr i} {\n        binary scan [SSL::extensions -index $i] S1S1H* ext_type ext_len ext\n        set ext_type [expr {$ext_type & 0xffff}]\n        set ext_len [expr {$ext_len & 0xffff}]\n        log local0.info \"SSL extension #[expr {$i + 1}]: (type $ext_type len $ext_len) $ext\"\n    }\n}\n\nSample log output:\n<CLIENTSSL_CLIENTHELLO>: SSL::extensions count = 1\n<CLIENTSSL_CLIENTHELLO>: SSL extension #1: (type 65281 len 1) 00\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_DATA","profiles:":["CLIENTSSL"],"description":"\nAn \"iRule event triggered after ingress SSL plaintext data has been collected from the clientssl connection.\n    ","examples":"\nwhen CLIENTSSL_HANDSHAKE {\n    # Trigger collection of the decrypted payload once the SSL handshake has been completed successfully\n    SSL::collect\n}\nwhen CLIENTSSL_DATA {\n    # Do something with the decrypted data\n    set payload [SSL::payload]\n\n    # Release the payload\n    SSL::release\n}\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_HANDSHAKE","profiles:":["CLIENTSSL"],"description":"\nTriggered when a client-side SSL handshake is completed. If LTM requests a certificate from the client this event would be triggered after the CLIENTSSL_CLIENTCERT event.\n    ","examples":"\nwhen CLIENTSSL_HANDSHAKE {\n    persist ssl\n}\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_SERVERHELLO_SEND","profiles:":["CLIENTSSL"],"description":"\nTriggered when the system is about to send its SSL ServerHello message on the clientside connection. This event is triggered only when in Forward Proxy Bypass mode and the bypass decision is still unknown\n    ","examples":"\nwhen CLIENTSSL_SERVERHELLO_SEND {\n  log local0. 'bypassing'\n  SSL::forward_proxy policy bypass\n}\n\nwhen CLIENTSSL_SERVERHELLO_SEND {\n  log local0. 'intercepting'\n  SSL::forward_proxy policy intercept\n}\n    "},
{"categories:":["SSL"],"eventName":"SERVERSSL_CLIENTHELLO_SEND","profiles:":["SERVERSSL"],"description":"\nTriggered when the system is about to send its SSL ClientHello message on the serverside connection. Zero or more SSL extensions may be sent to the peer at this stage in the SSL handshake.\n    ","examples":"\nwhen SERVERSSL_CLIENTHELLO_SEND {\n    set my_ext \"Hello world!\"\n    set my_ext_type 62965\n    SSL::extensions insert [binary format S1S1a* $my_ext_type [string length $my_ext] $my_ext]\n}\n    "},
{"categories:":["SERVERSIDE","SSL"],"eventName":"SERVERSSL_DATA","profiles:":["SERVERSSL"],"description":"\nAn iRule event triggered after ingress SSL plaintext data has been collected from the serverssl connection.\n\n    ","examples":"\nwhen SERVERSSL_HANDSHAKE {\n   # Trigger collection of the decrypted payload once the SSL handshake has been completed successfully\n   SSL::collect\n}\n\nwhen SERVERSSL_DATA {\n   # Do something with the decrypted data\n   set payload [SSL::payload]\n\n   # Release the payload\n   SSL::release\n}\n    "},
{"categories:":["SERVERSIDE","SSL"],"eventName":"SERVERSSL_HANDSHAKE","profiles:":["SERVERSSL","PERSIST"],"description":"\nTriggered when a server-side SSL handshake is completed.\n    ","examples":"\nwhen SERVERSSL_HANDSHAKE {\n   # Trigger collection of the decrypted payload once the SSL handshake has been completed successfully\n   SSL::collect\n}\n\nwhen SERVERSSL_DATA {\n   # Do something with the decrypted data\n   set payload [SSL::payload]\n\n   # Release the payload\n   SSL::release\n}\n    "},
{"categories:":["SSL"],"eventName":"SERVERSSL_SERVERHELLO","profiles:":["SERVERSSL","PERSIST"],"description":"\nTriggered when the system has received the server's SSL ServerHello message. Zero or more SSL extensions may be received from the peer at this stage in the SSL handshake.\n    ","examples":"\nwhen SERVERSSL_SERVERHELLO {\n    set ext_count [SSL::extensions count]\n    log local0.info \"SSL::extensions count = $ext_count\"\n\n    for {set i 0} {$i<$ext_count} {incr i} {\n        binary scan [SSL::extensions -index $i] S1S1H* ext_type ext_len ext\n        set ext_type [expr {$ext_type & 0xffff}]\n        set ext_len [expr {$ext_len & 0xffff}]\n        log local0.info \"SSL extension #[expr {$i + 1}]: (type $ext_type len $ext_len) $ext\"\n    }\n}\n    "},
{"categories:":["SSL"],"eventName":"SERVERSSL_SERVERCERT","profiles:":["SERVERSSL"],"description":"\nTriggered when the system has finished the server certificate verfication, and the result can be retrieved.\n    ","examples":"\nwhen SERVERSSL_SERVERCERT {\n    set result [X509::verify_cert_error_string [SSL::verify_result]]\n}\n    "},
{"categories:":["SSL"],"eventName":"CLIENTSSL_PASSTHROUGH","profiles:":["CLIENTSSL"],"description":"\nTriggered when the SSL receive the plaintext data and enter the passthrough mode.\n    ","examples":"\n    when CLIENTSSL_PASSTHROUGH {\n       SSL::collect\n    }\n\n    when CLIENTSSL_DATA {\n        log local0. \"[IP::client_addr]:[TCP::client_port]: Collected bytes [SSL::payload length]\"\n        log local0. \"[IP::client_addr]:[TCP::client_port]: Decrypted payload (\\[SSL::payload\\]): [SSL::payload]\"\n        log local0. \"[IP::client_addr]:[TCP::client_port]: Parsed first line: [SSL::payload 0 [string first \\r\\n [SSL::payload]]]\"\n        SSL::release\n    }\n    "},
{"categories:":["STREAM"],"eventName":"STREAM_MATCHED","profiles:":["STREAM"],"description":"\nTriggered when a stream expression matches. This event can be used to\nskip or change the replacement target.\n\n    ","examples":"\n## This example modifies the replacement string based so that only some\nmatches are rewritten. Replace any http:// instance with https:// only\nif the original string is http://*example.com.\n\nwhen HTTP_RESPONSE {\n\n   # Disable the stream filter by default\n   STREAM::disable\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Match any http:// instance and replace it with nothing\n      STREAM::expression {&http://.*?example\\.com&}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\nwhen STREAM_MATCHED {\n   log local0. \"[IP::client_addr]:[TCP::local_port]: matched: [STREAM::match], replaced with: [string map {http:// https://} [STREAM::match]]\"\n   STREAM::replace \"[string map {http:// https://} [STREAM::match]]\"\n}\n\n\nLog output:\nRule stream_expression_rule : 10.0.0.1:3413: matched: http://test.example.com, replaced with: https://test.example.com\nRule stream_expression_rule : 10.0.0.1:3413: matched: http://example.com, replaced with: https://example.com\n\n\n## This example just reads the stream match in the STREAM_MATCHED event and adds a persistence record.\n\n# Look for the jsessionid string in response content and add a persistence record when it is found.\n# Using STREAM:: commands requires a STREAM profile be added to the virtual server.  Use a blank profile.\n# To force LTM to recalculate the Content-Length value, add a custom HTTP profile to the virtual server_addr\n#  with Chunking set to Rechunk.\nwhen HTTP_RESPONSE {\n\n   # Clear the jsessionid if it exists already on this TCP connection\n   if {[info exists jsessionid]}{\n      unset jsessionid\n   }\n\n   # Only look for the jsessionid in text responses\n   if {[HTTP::header value \"Content-Type\"] starts_with \"text\"}{\n\n      log local0. \"[IP::client_addr]:[TCP::client_port]: Matched text, enabling stream filter\"\n\n      # Because TCL doesn't support lookaheads, match the jsessionid string and value\n      # We'll parse out the value in STREAM_MATCHED\n      # Assume the jsessionid is 1 to 100 characters (terminated by a non-alphanumeric character).\n      STREAM::expression ;jsessionid=[A-Za-z0-9]{1,100}\n      STREAM::enable\n\n      # Enable the STREAM_MATCHED event as it could have been disabled if there was a prior\n      # response on this TCP connection\n      event STREAM_MATCHED enable\n\n   } else {\n\n      # Disable the stream filter as this wasn't a text response\n      log local0. \"[IP::client_addr]:[TCP::client_port]: No Content-Type match, disabling stream filter\"\n      STREAM::disable\n   }\n}\nwhen STREAM_MATCHED {\n\n   # Save the matched value (example: ;jsessionid=ABCDEF)\n   set jsessionid [STREAM::match]\n   log local0. \"[IP::client_addr]:[TCP::client_port]: Matched: $jsessionid\"\n\n   # STREAM::match shouldn't match a null string with the defined regex, but check anyhow\n   if {[string length $jsessionid]}{\n\n      # Get the jsessionid value (split ;jsessionid=ABCDEF on the equals sign)\n      set jsessionid [getfield $jsessionid \"=\" 2]\n\n      # Not sure why, but the parser doesn't allow the persist command.\n      # It works though, so hide the command from the parser\n      set persist_cmd \"persist add uie $jsessionid\"\n      log local0. \"[IP::client_addr]:[TCP::client_port]: Parsed: $jsessionid \\$persist_cmd: $persist_cmd\"\n\n      eval $persist_cmd\n\n      # Assume the first match is the same as any other jsessionids, so stop checking for them\n      log local0. \"[IP::client_addr]:[TCP::client_port]: Added persistence record. Exiting event for this response.\"\n      event STREAM_MATCHED disable\n   }\n}\n\nLog output:\n\nRule persist_on_response_content_stream_rule : 1.2.3.4:2418: Matched text, enabling stream filter\nRule persist_on_response_content_stream_rule : 1.2.3.4:2418: Matched: ;jsessionid=a111111111111111111z\nRule persist_on_response_content_stream_rule : 1.2.3.4:2418: Parsed: a111111111111111111z $persist_cmd: persist add uie a111111111111111111z\nRule persist_on_response_content_stream_rule : 1.2.3.4:2418: Added persistence record. Exiting event for this response.\n    "},
{"categories:":["SERVERSIDE","TCP"],"eventName":"USER_REQUEST","profiles:":[],"description":"\nThis event is triggered by command TCP::notify request. It\nexecutes in a server-side context.\n\n    ","examples":"\nwhen CLIENT_DATA {\n TCP::release\n TCP::collect\n log local0. \"in CLIENT_DATA, calling TCP::notify request to trigger USER_REQUEST event\"\n TCP::notify request\n}\nwhen USER_REQUEST {\n  log local0. \"in USER_REQUEST\"\n}\n    "},
{"categories:":["TCP"],"eventName":"USER_RESPONSE","profiles:":[],"description":"\nThis event is triggered by command TCP::notify response. It\nexecutes in a client-side context.\n\n    ","examples":"\nwhen SERVER_DATA {\n TCP::release\n TCP::collect\n log local0. \"in SERVER_DATA, calling TCP::notify response to trigger USER_RESPONSE event\"\n TCP::notify response\n}\n\nwhen USER_RESPONSE {\n log local0. \"in USER_RESPONSE\"\n}\n    "},
{"categories:":["TDS"],"eventName":"TDS_REQUEST","profiles:":["MSSQL"],"description":"\nThis event is triggered when a TDS request message is received.\n\n    ","examples":"\n\n    "},
{"categories:":["TDS"],"eventName":"TDS_RESPONSE","profiles:":["MSSQL"],"description":"\nThis event is triggered when a TDS response message is received.\n\n    ","examples":"\n\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_REQUEST","profiles:":[],"description":"\nThis event is raised when the following headers are present in the client request - Upgrade: websocket, Connection: Upgrade, Sec-Websocket-Key.\n    ","examples":"\nwhen WS_REQUEST {\n    WS::enabled false\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_RESPONSE","profiles:":[],"description":"\nThis event is raised when the following headers are present in the server response - Upgrade: websocket, Connection: Upgrade, Sec-Websocket-Accept.\n    ","examples":"\nwhen WS_RESPONSE {\n    WS::enabled false\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_CLIENT_FRAME","profiles:":[],"description":"\nThis event is raised to indicate the start of a Websocket frame received from the client.\n    ","examples":"\nwhen WS_CLIENT_FRAME {\n    set mask [expr { int(20 * rand()) }]\n    WS::frame insert 1 \"abcdefghi\" $mask\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_SERVER_FRAME","profiles:":[],"description":"\nThis event is raised to indicate the start of a Websocket frame received from the server.\n    ","examples":"\nwhen WS_SERVER_FRAME {\n    WS::frame drop\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_CLIENT_FRAME_DONE","profiles:":[],"description":"\nThis event is raised to indicate the end of a Websocket frame received from the client.\n    ","examples":"\nwhen WS_CLIENT_FRAME_DONE {\n    WS::disconnect 1000 \"some random reason\"\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_SERVER_FRAME_DONE","profiles:":[],"description":"\nThis event is raised to indicate the end of a Websocket frame received from the server.\n    ","examples":"\nwhen WS_SERVER_FRAME_DONE {\n    WS::disconnect 1000 \"some random reason\"\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_CLIENT_DATA","profiles:":[],"description":"\nWhen the system collects the specified amount of data via the WS::collect command, WS_CLIENT_DATA event is raised. Within the context of this event, the collected payload can then be accessed using the WS::payload command.\n    ","examples":"\nwhen WS_CLIENT_DATA {\n    regsub -all \"oursite\" [WS::payload] \"oursitedev\" newdata\n    log local0. \"Replacing payload with new data.\"\n    WS::payload replace 0 $clen $newdata\n    WS::release\n}\n    "},
{"categories:":["IP","TCP","HTTP","WEBSOCKET"],"eventName":"WS_SERVER_DATA","profiles:":[],"description":"\nWhen the system collects the specified amount of data via the WS::collect command, WS_SERVER_DATA event is raised. Within the context of this event, the collected payload can then be accessed using the WS::payload command.\n    ","examples":"\nwhen WS_SERVER_DATA {\n    regsub -all \"oursite\" [WS::payload] \"oursitedev\" newdata\n    log local0. \"Replacing payload with new data.\"\n    WS::payload replace 0 $clen $newdata\n    WS::release\n}\n    "},
{"categories:":["HTTP"],"eventName":"XML_CONTENT_BASED_ROUTING","profiles:":["FASTHTTP","HTTP"],"description":"\nTriggered when a match is found in the XML profile. There are three\nvariables populated by the XML profile for this event:\n\nv10.2 - v11.1\n    Variable        Purpose\n    $XML::count     Shows how many queries matched.\n    $XML::queries   Contains an array of the query names that matched.\n    $XML::values    Holds the values of the elements that matched.\n\nv11.2+\n    Variable        Purpose\n    $XML_count      Shows how many queries matched.\n    $XML_queries    Contains an array of the query names that matched.\n    $XML_values     Holds the values of the elements that matched.\n\n    ","examples":"\n# v10.2 - v11.1\nwhen XML_CONTENT_BASED_ROUTING {\n  for {set i 0} { $i < $XML::count } {incr i} {\n    log local0. $XML::queries($i)\n    log local0. $XML::values($i)\n    if {($XML::queries($i) contains \"FinanceObject\")} {\n      pool finance_pool\n    }\n  }\n}\n\n# v11.2+\nwhen XML_CONTENT_BASED_ROUTING {\n  for {set i 0} { $i < $XML_count } {incr i} {\n    log local0. $XML_queries($i)\n    log local0. $XML_values($i)\n    if {($XML_queries($i) contains \"FinanceObject\")} {\n      pool finance_pool\n    }\n  }\n}\n    "},
{"commandName":"after","description":"The after command allows you to insert a delay into the processing of your iRule, executing the specified script after a certain amount of time has passed. It also allows for things like periodic (repeat) execution of a script, as well as looking up or canceling currently delayed scripts.\n\nNote: The after command is not available in GTM.\n    \nDelays rule execution for the given milliseconds. If SCRIPT parameter is given, schedules it for execution after the given milliseconds.  If -periodic switch is supplied, the script will be evaluated every given milliseconds.\n    \nCancels the scheduled evaluation of the scripts identified by <id>. When -current is supplied from within after script, cancel the periodic timer of the active script.\n    \nReturns information about currently scheduled scripts, or about the script of the given id.","examples":"when RULE_INIT {\n   set users_last_sec 0\n   set new_user_count 0\n   after 1000 ¨Cperiodic {\n      set users_last_sec $new_user_count\n      set new_user_count 0\n   }\n}\n\nwhen HTTP_REQUEST {\n   if {not [HTTP::cookie exists UserID]} {\n      incr new_user_count\n   }\n   if {[expr {$users_last_sec + $new_user_count}] > 500} {\n      HTTP::respond 503 Retry-After 3\n   }\n}\n\n\n# send response from BigIP if server does not respond within a specified amount of time.\nwhen RULE_INIT {\n    # Timeout is in Milliseconds\n    set static::response_timeout  10000\n    }\n\n    when HTTP_REQUEST {\n        log local0. \"Received request, beginning response monitor interval. [clock seconds]\"\n        set monitor_id [\\\n            after $static::response_timeout {\n                log local0. \"Timeout $static::response_timeout  milliseconds elapsed without server response. [clock seconds]\"\n                TCP::respond \"HTTP/1.0 200 OK\\r\\nContent-Type: text/html\\r\\nContent-Length: 69\\r\\n\\r\\n<html><body> We are responding because server was late.</body></html>\"\n            }\\\n         ]\n    }\n\n    when HTTP_RESPONSE {\n        log local0. \"Received server response. \"\n        if {[info exists monitor_id]} {\n            log local0. \"Canceling after script with id $monitor_id\"\n            after cancel $monitor_id\n        }\n    }\n\n\n # Close the client connection after X seconds no matter how long it's idle for\n when RULE_INIT {\n     # Timeout is in milliseconds\n     set static::response_timeout 10000\n }\n\n when CLIENT_ACCEPTED {\n     log local0. \"Received connection, beginning timer for $static::response_timeout from [clock seconds]\"\n     after $static::response_timeout {\n         log local0. \"Timeout $static::response_timeout milliseconds elapsed closing connection. [clock seconds]\"\n         reject\n     }\n }","returnValue":"When script is named, an id is returned for the script."},
{"commandName":"call","description":"iRule procedures:\n    - Are similar to procedures, functions, subroutines from other languages\n    - Allow for reuse of common code\n        - Reference the same code from multiple locations, but only define it in one place\n        - Simplifies code maintenance\n    - Allow you to augment the predefined iRule commands\n\nProcedures are defined with the proc statement. This must be done outside of any event. Procedures can be defined within an iRule assigned to a virtual server or in a separate iRule not assigned to any virtual server.\n\nYou can call a local proc (one defined in the same iRule) without a namespace prefix:\n    call my_proc $args\nTo reference a proc defined in another iRule in the same partition, prefix the proc name with the iRule name where the proc is defined\n    call other_rule::my_proc $args\nTo reference a proc defined in another iRule in a different partition, prefix the proc name with the partition and iRule name where the proc is defined\n    call /other_partition/other_rule::procname args\n\nNote: Calling a proc in another iRule and/or partition does not affect CMP","examples":"# Define one or more procs in an iRule outside of any event. This iRule does not need to be assigned to any virtual server.\nrule proc_rule {\n\n  proc printArguments args {\n    foreach arg $args {\n      log local0. \"$arg\"\n    }\n  }\n\n  proc returnArguments args {\n    log local0. \"returning $args\"\n    return $args\n  }\n}\n\n# Call the proc(s) from the same or another iRule. If you reference the proc from another iRule prefix it with the iRule name where the proc is defined. The prefix can contain an absolute folder path.\nwhen RULE_INIT {\n    # Call a proc which returns no values\n    call proc_rule::printArguments one two three\n\n    # Save the return value of a proc\n    set return_values [call proc_rule::returnArguments one two three]\n}\n\n# Proc which accepts no parameters:\nproc noargs {} {\n log local0. \"Expected and received no arguments\"\n}\n\n# Proc which accepts a variable number of arguments:\nproc any_number_args args  {\n log local0. \"Received [llength $args] args: $args\"\n}\n\n# Proc which accepts an explicit number of arguments\nproc explicit_args {arg1 arg2} {\n log local0. \"Received two args: $arg1 and $arg2\"\n}\n\n# Proc which sets default values for arguments if they aren't specified in the call statement:\nproc default_value_for_args {{arg1 default1} {arg2 default2}} {\n    log local0. \"Current values \\$arg1: $arg1, \\$arg2: $arg2\"\n}\ncall default_value_for_args         ; # arg1 is set to \"default1\", arg2 is set to \"default\"\ncall default_value_for_args \"a\"     ; # arg1 is set to \"a\",        arg2 is set to \"default\"\ncall default_value_for_args \"a\" \"b\" ; # arg1 is set to \"a\",        arg2 is set to \"b\"","returnValue":"Returns the value that returns (if any)."},
{},
{"commandName":"class","description":"The class command, implemented in v10.0.0, allows you to query data groups and data group properties.\n\nThese commands work for both internal (defined in the bigip.conf) and external (custom file) data groups. Internal data groups were not able to make use of the name/value pairing with the := separator until version 10.1. As of 10.1 all classes support the name/value pairing.\n\nThe class command deprecates the findclass and matchclass commands as it offers better functionality and performance than the older commands.\n\nNote -\n    You should not use a $:: or :: prefix on the datagroup name when using the class command (or in any datagroup reference on 9.4.4 or later).\n\n    In v9.4.4 - 10, using $::datagroup_name will work but demote the virtual server from running on all TMMs. For details, see the CMP compatibility page.\n\n    In v11, using $::datagroup_name will result in a TCL runtime error and a reset being sent to the client!\n\nNote -\n    Starting in v11, any data-groups that are configured in a partition other than Common must be referenced by /Partition_Name/Data-Group_Name, even by iRules configured in that partition. Data-groups referenced only by name are implicitly presumed to be /Common/Data-Group_Name.\n\nNote -\n    When using the equals operator on IP classes, or when using the starts_with or ends_with operators, if multiple possible matches are found in the class, then the longest match is always chosen. This is not true when using the contains operator. See the example below for more details.\n    \nclass match attempts to match the provided <item> to an element in <class> by applying the <operator> to the <item>.\n\nThe return value depends on the option specified. If no option was specified, the return value is 1 for a match and 0 for a no-match.\n\nThis command form is equivalent to the current iRule command:\n    matchclass <item> <operator> <class>\n\nExample:\n    class match [HTTP::uri] ends_with image_class\nread as, does the URI end with an element from image_class.\n\nExample:\n    class match [IP::client_addr] equals client_ip_class\nread as, does the client IP address exist in the client_ip_class.\n        \nclass search attempts to match the provided <item> to an element in <class> by applying the <operator>to the <class> element.\n\nThe return value depends on the option specified. If no option was specified, the return value is 1 for a match and 0 for a no-match.\n\nThis command form is equivalent to the current iRule command:\n    matchclass <class> <operator> <item>\n\nExample:\n    class search blocked_paths starts_with [HTTP::uri]\nread as, does blocked_paths contain an element that starts with the URI.\n\nclass match & class search difference:\nNotice that there are differences between the two forms:\n- The order in which you specify <item> and <class>.\n- The item on which the operator is applied for operations other than equals.\n\nThe table below describes the semantics of the different operators when used in each of the commands. See also the example below for a code snippet depicting the differences:\n\noperator      class match                                                                              class search\nequals\t  return a value indicating <class> has an element that is equal to <item>\t           return a value indicating <class> has an element that is equal to <item>\nstarts_with\t  return a value indicating there is a <class> element that matches the start of <item>\t   return a value indicating <item> value matches the start of a <class> element\nends_with\t  return a value indicating there is a <class> element that matches the end of <item>\t   return a value indicating <item> value matches the end of a <class> element\ncontains\t  return a value indicating <item> value contains a <class> element                        return a value indicating there is a <class> element that contains <item>\n\nclass match & class search optional arguments:\nThe <options> for both of the above forms of the class command can be:\n-index    Changes the return value to be the index of the matching class element.\n-name     Changes the return value to be the name of the matching class element.\n-value    Changes the return value to be the value of the matching class element.\n-element  Changes the return value to be a list of the name and value of the matching class element.\n-all      If used with -index, -name, -value, -element, changes the return value to all of the matching class elements.  (added in v11.0)\n--        Terminates option processing (useful if the <item> or <class> begins with a hyphen).\n\nThe <operator> for both of the above forms can be: equals, starts_with, ends_with, contains\n        \nEquivalent to: class match -value <item> equals <class>\n        \nReturns a list containing the name and value of the element found at <index> in <class>.\n\nNote: class indexes are not guaranteed to be consistent and may change when a datagroup is modified. This could happen if the event execution becomes suspended or across executions of different events.\n\nThe <options> for this command can be:\n    -name   Changes the return value to be the name of the class element at the index.\n    -value  Changes the return value to be the value of the class element at the index.\n    --      Terminates option processing.\n        \nReturns the type of the <class>, currently only string, IP, or value.\n        \nReturns 1 or 0 depending on whether a class named <class> actually exists.\n        \nReturns the number of elements currently found in <class>.\n        \nReturns the names of the class elements.\n        \nReturns a list containing the names or a list of the name and value currently found in <class>.\nAn optional <pattern> may be specified to restrict the list to names that match the Tcl glob pattern. Additionally, the switch -nocase may be specified to enable case-insensitive pattern matching.\nThis command provides a way to access the class as a Tcl list similar to previously access the global variable named the same as the list.\n\nNote: Use class get only if you want to manage a class as a list. If you are looking for an element within the class, class search and class match are far more efficient. This is particularly important when using large classes.\n        \nReturns a <search_id> to be used with each of the following commands.\n        \nSubcommand nextelement returns a list containing the name and value of the next element in the current search.\n\n-index       Changes the return value to be the index of the next class element.\n-name        Changes the return value to be the name of the next class element.\n-value       Changes the return value to be the value of the next class element.\n--           Terminates option processing.\n\nSubcommand anymore returns 1 or 0 depending on whether there are more elements to iterate on in the <class>.\n\nSubcommand donesearch terminates the search. After using this command, executing 'class anymore' or 'class nextelement' will cause a runtime error. To exit a loop early, use break . Once done with the search and outside any loop referencing the search id, use 'class donesearch' to clean up the memory associated with the search.","examples":"# External Class Format (v10):\n# class namevalue {\n#   \"name1\" := \"value\",\n#   \"name2\" := \"value\",\n# }\n\n# Internal Class Format (v10.1):\n# class namevalue {\n#    {\n#       \"name1\" { \"value1\" }\n#       \"name2\" { \"value2\" }\n#    }\n# }\n\n# Internal Class Format (v11.0):\n# ltm data-group internal name_value_dg {\n#     records {\n#         name1 {\n#             data value1\n#         }\n#         name2 {\n#             data \"value2 with spaces\"\n#         }\n#     }\n#    type string\n# }\n\n#\n# The example below demonstrates the differences between class match and class search when applied to a data group using different keys and operations (note that no option was specified, so the return value shown in the tables below is the operation result code). The iRule first gets the contents of the data group being queried and then performs the various operations using both forms. When a match occurs, the matching data group key is shown as well.\nwhen RULE_INIT {\n\n    log local0.info \"dg_test_class: [class get dg_test_class]\"\n    foreach val {p://a.b p://a.b/x p://a.b/x/y p://a.b/x/y/z } {\n        log local0.info \"+[string repeat - 15]|[string repeat - 15]|[string repeat - 15]|[string repeat - 15]+\"\n        log local0.info \"[format |%-15s|%15s|%15s|%15s| value operation {class match} {class search}]\"\n        foreach oper {equals starts_with ends_with contains} {\n            set rc_match \"[class match -name $val $oper dg_test_class]:[class match $val $oper dg_test_class]\"\n            set rc_search \"[class search -name dg_test_class $oper $val]:[class search dg_test_class $oper $val]\"\n            log local0.info \"[format |%-15s|%15s|%15s|%15s| $val $oper $rc_match $rc_search ]\"\n        }\n        log local0.info \"+[string repeat - 15]|[string repeat - 15]|[string repeat - 15]|[string repeat - 15]+\"\n    }\n}\n\n# Below is the resulting log output (note the line prefix was stripped for brevity):\n# \"/Common/rl_test_dg <RULE_INIT>: dg_test_class: {p://a.b/x/y a_b_x_y} {p://y.y/x y_y_x} {p://u.v/w u_v_w}\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: |value          |      operation|    class match|   class search|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b        |         equals|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b        |    starts_with|             :0|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b        |      ends_with|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b        |       contains|             :0|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: |value          |      operation|    class match|   class search|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x      |         equals|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x      |    starts_with|             :0|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x      |      ends_with|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x      |       contains|             :0|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: |value          |      operation|    class match|   class search|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y    |         equals|  p://a.b/x/y:1|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y    |    starts_with|  p://a.b/x/y:1|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y    |      ends_with|  p://a.b/x/y:1|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y    |       contains|  p://a.b/x/y:1|  p://a.b/x/y:1|\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n# \"/Common/rl_test_dg <RULE_INIT>: |value          |      operation|    class match|   class search|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y/z  |         equals|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y/z  |    starts_with|  p://a.b/x/y:1|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y/z  |      ends_with|             :0|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: |p://a.b/x/y/z  |       contains|  p://a.b/x/y:1|             :0|\"\n# \"/Common/rl_test_dg <RULE_INIT>: +---------------|---------------|---------------|---------------+\"\n\n# This example disables compression based on source IP's in an address type datagroup named localusers_dg\nwhen HTTP_REQUEST {\n    if { [class match [IP::client_addr] equals \"localusers_dg\" ] } {\n        COMPRESS::disable\n    }\n}\n\n# This v10 example chooses a pool based on the URI requested:\n# /config/app_class.dat:\n# \"/trxdef/\" := \"trx_pool\",\n# \"/aaa/\" := \"aaa_pool\",\n# \"/abscon/\" := \"abs_pool\",\n\n# class app_class {\n#    type string\n#    filename app_class.dat\n# }\nrule appl_director {\n   when HTTP_REQUEST {\n      set app_pool [class match -value -- [HTTP::uri] starts_with app_class]\n      if {$app_pool ne \"\"} {\n         pool $app_pool\n      } else {\n         pool default_pool\n      }\n   }\n}\n\n# This example chooses a pool based on the time of day:\n# /config/daily_schedule.dat:\n# 0 := early_morning_pool,\n# 7 := morning_rush,\n# 10 := midday_pool,\n# 15 := afternoon_rush,\n# 18 := evening_pool,\n\n# class daily_schedule {\n#    type value\n#    filename daily_schedule.dat\n# }\n\nrule daily_director {\n\n   # Initialize a variable to track the closest hour match\n   # as we loop through the datagroup elements.\n   # We want to find the lowest hour in the datagroup that is\n   # greater or equal to the current hour.\n   #\n   # Note: The order of datagroup elements is not guaranteed\n   # so we must loop through all elements to find the best match.\n\n   when HTTP_REQUEST {\n\n      # Get the hour of day\n      set hour_now [clock format [clock seconds] -format {%H}]\n\n      # Save a search ID for the daily_schedule datagroup\n      set id [class startsearch daily_schedule]\n\n      # Initialize a variable to track the closest hour match\n      # By setting this to higher than the highest hour of the day,\n      # any match in the datagroup will override this default value.\n      set best_match 24\n\n      # Loop through the datagroup\n      while { [class anymore daily_schedule $id] } {\n\n         # Save the current element's key and value to a TCL list\n         set x [class nextelement daily_schedule $id]\n\n         # Save the current datagroup element's hour field (the first list element)\n         # to a variable so we don't rerun the lindex several times\n         set hour_class [lindex $x 0]\n\n         # Check if the current hour is greater than the the current element key\n         if {$hour_now >= $hour_class && $hour_class < $best_match} {\n\n            # Save the currently matched hour to see if it's the best match\n            set best_match $hour_class\n\n            # Save the value as the pool name\n            set pool [lindex $x 1]\n         }\n      }\n      # Assign the best match's corresponding pool\n      pool $pool\n   }\n}\n\n# This example demostrates how to loop through each element in a datagroup using 'class startsearch' and exit the loop once a match is found. Cleanup of internal structures is done using 'class donesearch':\nwhen RULE_INIT {\n\n   # Save a class name to search through\n   set class_name numbers_class\n\n   # Save a search ID for the datagroup\n   set id [class startsearch $class_name]\n\n   # Loop through the class row by row\n   while {[class anymore $class_name $id]}{\n      set element [class nextelement $class_name $id]\n      log local0. \"\\[class nextelement $class_name $id\\]: $element\"\n\n      # Perform some operation against the current datagroup key and/or value\n\n      # Check if the element's key is greater than 2\n      if {[lindex $element 1] > 2}{\n\n         # Exit the loop if the logic check is true\n         log local0. \"Found key greater than 2, breaking out of loop\"\n         break\n      }\n   }\n   # Clean up the search\n   class donesearch $class_name $id\n}\n\n# This example extracts an base64 encoded image from a class to send in an HTTP response when load balancing failed:\n# /config/img.txt:\n# \"img\" := \"R0lGODlhEgAeANUAABAREz9CSEBBQz0+QB8hJCIkJ5eZnGJlaXN2egQJDwUKEDo+Q0VJTgE\n#           DBQULEQUKDwMGCTo+Qk1RVUtPU0pOUk9TV1RYXFZaXlxgZFtfYy0vMRcYGTEzNR8gIW5xdG1\n#           wc2lsb2hrbklLTXh7fnV4e3R3enN2eXF0d4SHiqCipJeZmwQKDwULEDU6PktQVFtfYjI4PHN\n#           2eAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwAAAAAEgAeAEA\n#           G20CRcEgsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+mIfH7\n#           E7/P1eSGsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+CggMd\n#           IIWHHYOCsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+FY2NG\n#           hsSkJIbjsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+o0RmJ\n#           gEAC2bnQsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+CZmFU\n#           uEA6kpqUsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+OVyxc\n#           ExAKrrCvsDjFIZGa5fDmTSId0Sq2yroqsdsvVnr5fk9gUK8fAX4Z6zW6vu3Duak6v2+W3auK\n#           7a2dSm7vL2+vCXBwSTExcTCwR/KygYCHs0eKgLLygfW19jZ1xfc3CgcFt/hHN3cFOfo6eroA\n#           e3tJwU7vL2+L8PIF7u0w+Pn6+/lV/lSruEBooGBgQYJxEio0yBChlgcQI0qcGPGORTsJMmrc\n#           yFFjEA7vL2+A7\",\n\n# class img {\n#    type string\n#    filename \"/config/img.txt\"\n# }\n\nrule LBFailedResponse {\n   when LB_FAILED {\n      HTTP::respond 200 content [b64decode [class element -value 0 img]] \"Content-Type\" \"image/png\"\n   }\n}\n\n\n# Using the -all flag added in v11.0 to return details on multiple matches (for class match or class search):\n#\n# Show the full contents of the string_dg datagroup retrieved as a TCL list:\n  log local0. \"[class get string_dg] \"\n# Log output: {abc value1} {abcd value2} {abcde value3} {123 value4}\n\n# Use -all with no other options to return a count of the number of matching names in the datagroup:\n  log local0. \"[class search -all string_dg starts_with \"abc\"]\"\n# Log output: 3\n\n# Use -all with the -index option to return the index of matching names in the datagroup:\n  log local0. \"[class search -all -index string_dg starts_with \"abc\"]\"\n# Log output: 0 1 2\n\n# Use -all with the -index option to return the index of matching names in the datagroup:\n  log local0. \"[class search -all -index string_dg starts_with \"abc\"]\"\n# Log output: 0 1 2\n\n# Use -all with the -element option to return the name and value of matching names in the datagroup:\n  log local0. \"[class search -all -element string_dg starts_with \"abc\"]\"\n# Log output: {abc value1} {abcd value2} {abcde value3}\n\n# Use -all with the -name option to return the name of matching names in the datagroup:\nlog local0. \"[class search -all -name string_dg starts_with \"abc\"]\"\n# Log output: abc abcd abcde\n\n# Use -all with the -value option to return the value of matching names in the datagroup:\nlog local0. \"[class search -all -value string_dg starts_with \"abc\"]\"\n# Log output: value1 value2 value3\n\n# Examples showing longest-match selection (v11.x syntax):\nltm data-group internal /Common/addr_list {\n    records {\n        10.0.0.0/8 {\n            data bignet\n        }\n        10.0.0.0/24 {\n            data littlenet\n        }\n    }\n    type ip\n}\nltm data-group internal /Common/string_list {\n    records {\n        left {\n            data first\n        }\n        lefter {\n            data second\n        }\n    }\n    type string\n}\n\nlog local0. \"match of 10.0.0.128 is [class match -value 10.0.0.128 equals addr_list]\"\nlog local0. \"match of lefterest is [class match -value lefterest starts_with string_list]\"\n# will log:\n# Rule /Common/classes <RULE_INIT>: match of 10.0.0.128 is littlenet\n# Rule /Common/classes <RULE_INIT>: match of lefterest is second\n# In each case, the longest match was used (10.0.0.0/24 had a longer match than 10.0.0.0/8, and \"lefter\" had a longer match than \"left\").","returnValue":""},
{"commandName":"pool","description":"Causes the system to load balance traffic to the specified pool or pool member . In case only pool member is specified ,the system will load balance traffic to the specified pool member regardless of pool member monitor status. Pool member status may be determined by the use of the LB::status command. Server failure to respond may be caught in the LB_FAILED event. Failure to select a server because none are available may be caught in the LB_FAILED event or prevented by using the active_members command to test the number of active servers in the pool before sending traffic.)\n\nPool member may be selected conditionally. If multiple conditions match, the last match will determine the pool/member to which this traffic is load balanced.\n\n    Syntax\n\n    pool <pool_name>\n\n         * Specifies the pool to which you want to send the traffic.\n\n    pool <pool_name> [member <addr> [<port>]]\n\n         * Specifies a pool member to which you want to directly send the\n           traffic.","examples":"To select a pool conditionally:\nwhen CLIENT_ACCEPTED {\n  if { [IP::addr [IP::client_addr] equals 10.10.10.10] } {\n     pool my_pool\n  }\n}\n\nTo check pool member status before sending traffic:\n\nwhen HTTP_REQUEST {\n   if { [HTTP::uri] ends_with \".gif\" } {\n      if { [LB::status pool my_Pool member 10.1.2.200 80] eq \"down\" } {\n         log \"Server $ip $port down!\"\n         pool fallback_Pool\n      } else {\n         pool my_Pool member 10.1.2.200 80\n      }\n   }\n}\n\nTo catch failure of selected pool member to respond:\n\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] ends_with \".gif\" } {\n    pool my_Pool member 10.1.2.200 80\n  }\n}\nwhen LB_FAILED {\n  pool my_Pool\n  LB::reselect\n  log \"Selected server [LB::server] did not respond. Re-selecting node from myPool\"\n}","returnValue":""},
{"commandName":"log","description":"Generates and logs the specified message to the Syslog-ng utility. This\ncommand works by performing variable expansion on the message as\ndefined for the HTTP profile Header Insert setting.\nThe log command can produce large amounts of output. Use with care in\nproduction environments, especially where disk space is limited.\nThe syslog facility is limited to logging 1024 bytes per request.\nLonger strings will be truncated.\nThe High Speed Logging feature offers the ability to send TCP or\nUDP syslog messages from an iRule with very low CPU or memory overhead.\nConsider using HSL instead of the default log command for remote\nlogging.\n\nSyntax\n\nlog <message>\n\n     * Logs the specified message to the syslog-ng utility. Log entries\n       are written to the local system log (/var/log/ltm). (See Note below\n       about supression.)\n\nlog [-noname] <facility>.[<level>] <message>\n\n     * Logs the specified message to the syslog-ng utility at the\n       specified facility & log level. The iRule name prefixing the\n       message text may optionally suppressed by including the -noname\n       option.\n\nlog [-noname] <remote_ip>[:<remote_port>] <facility>.[<level>] <message>\n\n     * (LTM only) Logs the specified message directly to the specified IP\n       address (and optional alternate port when specified) via UDP.\n       Facility and/or level are required. The iRule name prefixing the\n       message text may optionally suppressed by including the -noname\n       option. <remote_ip> must be a TMM-routed address. If you must route\n       specific messages to a remote address via the management interface,\n       you must log locally. syslog-ng is able to route messages via both\n       TMM and management interfaces using the standard syntax. You can\n       define an appropriate filter and remote log destination in LTM's\n       syslog-ng service.\n\n   Note: There is a significant behavioral difference when the optional\n   <facility>.<level> is specified. When iRule logs messages without the\n   facility and/or level, they are rate-limited as a class and\n   subsequently logged messages within the rate-limit period may be\n   suppressed even though they are textually different. However, when the\n   <facility> and/or <level> are specified, the log messages are not\n   rate-limited (though syslog-ng will still perform suppression of\n   repeated duplicates).","examples":"Log to the local facility with no duplicate message suppression:\n\nlog local0. \"Found $isCard $type CC# $card_number\"\n\nLog in the default message format to a remote syslog server on the\ndefault port:\n\nwhen CLIENT_ACCEPTED {\nlog 172.27.31.10 local0.info \"Client Connected, IP: [IP::client_addr]\"\n}","returnValue":""},
{"commandName":"table","description":"The table command is a superset of the session command, with improved syntax for general purpose use. Please see the table command article series for detailed information on its use.\n\nThis command is not available to GTM.\n\nIf the table command is used on the standby system in a HA pair, the command will perform a no-op because the content of the standby unit's session db should be updated only through mirroring.\n\n    Syntax\n\n    table set\n\n         * Sets a key/value pair in the session table or named subtable, with\n           the specified timeout and lifetime.\n         * Returns the entry's value after the set operation is complete.\n\n         * If no timeout is specified, a default of 180 seconds will be used.\n         * The timeout may be specified as \"indefinite\" or \"indef\", in which\n           case the key/value will not be expired based on access times.\n         * The timeout may be specified as 0, in which case an existing\n           timeout will not be changed. A timeout specified as 0 for a new\n           record will be set to the default of 180 seconds.\n\n         * If no lifetime is specified, the default of indefinite will be\n           used.\n         * The lifetime may be specified as \"indefinite\" or \"indef\", in which\n           case the key/value will not be expired based on life time.\n         * The lifetime may be specified as 0, in which case an existing\n           lifetime will not be changed. A lifetime specified as 0 for a new\n           record will be set to the default of indefinite.\n\n         * If -notouch is specified any existing entry for the key will not\n           have its timestamp updated.\n         * If -mustexist is specified, and the key does not already exist, no\n           action will be taken, and an empty string will be returned. Cannot\n           be specified with -excl.\n         * If -excl is specified, and the key already exists, the key will not\n           be inserted, and the existing value will be returned. Cannot be\n           specified with -mustexist.\n\n       To use a subtable or not to use a subtable for storing your session\n       entries? The short answer is only use a subtable if you need to be able\n       to count the number of keys or retrieve the keys in one command.\n       Manipulating entries in subtables has higher overhead than manipulating\n       an entry not in a subtable. Each subtable itself also takes up memory.\n       All of the entries in a given subtable are on the same processor. So if\n       you put all of your entries (or the vast majority of them) into the\n       same subtable, then one CPU will take a disproportionate amount of\n       memory and load. Which you probably don't want.\n\n    table add\n\n         * Exactly the same as table set -excl\n\n    table replace\n\n         * Exactly the same as table set -mustexist\n\n    table lookup\n\n         * Looks up a value associated with the specified key, in the\n           specified table (if any).\n         * If -notouch is specified then any existing entry for the key will\n           not have its timestamp updated.\n\n    table incr\n\n         * Increments the value associated with the specified key, in the\n           specified subtable (if any). If no delta is specified, a default\n           value of 1 is used. If the key does not already exist, a default\n           value of 0 will be used, and the entry will have a timeout of 180\n           seconds.\n         * Returns the entry's value after the incr operation is complete.\n         * If -notouch is specified then any existing entry for the key will\n           not have its timestamp updated.\n         * If -mustexist is specified, and the key does not already exist,\n           then no action will be taken.\n\n    table append\n\n         * Appends to the value associated with the specified key, in the\n           specified subtable (if any). If the key does not already exist, a\n           starting value of an empty string will be used, and the entry will\n           have a timeout of 180 seconds.\n         * Returns the entry's value after the append operation is complete.\n         * If -notouch is specified then any existing entry for the key will\n           not have its timestamp updated.\n         * If -mustexist is specified, and the key does not already exist,\n           then no action will be taken.\n\n    table delete\n\n         * Deletes the key/value pair with specified key, in the specified\n           subtable (if any).\n         * If -all is specified in addition to a subtable name, all key/value\n           pairs in the subtable are deleted.\n\n    table timeout\n\n         * Returns, and optionally sets, the timeout of the specified key, in\n           the specified subtable (if any).\n         * If -remaining is specified, then the time remaining before timeout\n           will be returned instead. If the key does not already exist, an\n           empty string is returned.\n         * Returns -1 if no timeout or an indefinite timeout was set for the\n           specified key\n         * Any existing entry for the key will not have its timestamp updated.\n\n    table lifetime\n\n         * Returns, and optionally sets, the lifetime of the specified key, in\n           the specified subtable (if any).\n         * If -remaining is specified, then the time remaining before\n           expiration will be returned instead. If the key does not already\n           exist, an empty string is returned.\n         * Returns -1 if no lifetime or an indefinite lifetime was set for the\n           specified key\n         * Any existing entry for the key will not have its timestamp updated.\n\n       Note: By setting a lifetime on an entry, you can have it expire after a\n       certain period of time no matter how many changes or lookups are\n       performed on it. An entry can have a lifetime and a timeout at the same\n       time. It will expire (be removed from the table) whenever the timeout\n       OR the lifetime expires, whichever comes first. For more info see the\n       table article series: https://devcentral.f5.com/Default.aspx?tabid=63&articleType=ArticleView&articleId=2378\n\n    table keys\n\n         * Returns a list of the keys in the specified subtable.\n         * If -notouch is specified, then any existing entries will not have\n           their timestamps updated.\n         * If -count is specified, then a count of the keys in the specified\n           subtable is returned and entries will not have their timestamps\n           updated.","examples":"# Limit each client IP address to 20 concurrent connections\nwhen CLIENT_ACCEPTED {\n   # Check if the subtable has over 20 entries\n   if { [table keys -subtable connlimit:[IP::client_addr] -count] >= 20 } {\n      reject\n   } else {\n      # Add the client IP:port to the client IP-specific subtable\n      #   with a max lifetime of 180 seconds\n      table set -subtable connlimit:[IP::client_addr] [TCP::client_port] \"\" 180\n   }\n}\n\nwhen CLIENT_CLOSED {\n   # When the client connection is closed, remove the table entry\n   table delete -subtable connlimit:[IP::client_addr] [TCP::client_port]\n}\n\n\nBlacklist IPs for 10 minutes if they make more than 100 DNS queries per second:\nwhen RULE_INIT {\n    set static::maxquery 100\n    set static::holdtime 600\n}\nwhen CLIENT_DATA {\n    set srcip [IP::remote_addr]\n    if { [table lookup -subtable \"blacklist\" $srcip] != \"\" } {\n        drop\n        return\n    }\n    set curtime [clock second]\n    set key \"count:$srcip:$curtime\"\n    set count [table incr $key]\n    table lifetime $key 2\n    if { $count > $static::maxquery } {\n        table add -subtable \"blacklist\" $srcip \"blocked\" indef $static::holdtime\n        table delete $key\n        drop\n        return\n    }\n}","returnValue":""},
{"commandName":"persist","description":"Causes the system to use the named persistence type to persist the\nconnection. Also allows direct inspection and manipulation of the\npersistence table.\n\nSyntax\n\n   Note: Items marked with <item> are meant to be replaced with a value.\n   Arguments bracketed by [ ] are used to note they are optional. They\n   should not be confused with Tcl command evaluation.\n\n   <timeout> = The timeout in seconds.\n\npersist simple [<mask>] [<timeout>]\npersist source_addr [<mask>] [<timeout>]\npersist sticky [<mask>] [<timeout>]\npersist dest_addr [<mask>] [<timeout>]\npersist ssl [<timeout>]\npersist msrdp [<timeout>]\npersist cookie [insert [<cookie_name>] [<expiration>] |\n                rewrite [<cookie_name>] [<expiration>] |\n                passive [<cookie_name>] |\n                hash <cookie_name> [ {<offset> [<length>]} [<timeout>]] ]\npersist uie <string> [<timeout>]\npersist hash <string> [<timeout>]\npersist carp <string>\npersist none\n\n\n\n   These permutations are used to manipulate the persistence table\n   directly:\n\npersist add <mode> <key> [<timeout>]\n   <key> = <mode specific value> | { <value> [any virtual|service|pool] [pool <name>] }\n     the latter key specification is used to add persistence entries that can be used across virtuals, services, or pools.\n\npersist lookup <mode> <key> [all|node|port|pool]\n  \"all\" or no specification returns a list containing the node, port and pool name.\n  Specifying any of the other return types will return the specified item only.\n   <key> = <mode specific value> | { <value> [any virtual|service|pool] [pool <name>] }\n     the latter key specification is used to access persistence entries across virtuals, services, or pools.\n\npersist delete <mode> <key>\n   <mode> = simple | source_addr | sticky | dest_addr | ssl | uie | hash\n   <key> = <mode specific value> | { <value> [any virtual|service|pool] [pool <name>] }\n     the latter key specification is used to delete persistence entries regardless of virtual, service, or pool association.\n\n   Note: When using the latter key specification above (e.g. = { any\n   virtual }), the persist command expects the key (the data and\n   associated \"any virtual\" commands) to be a single argument; in other\n   words, a list. Often, users will want to specify some variable data in\n   such a command. However, the usual way of creating a list (via braces,\n   as shown above) will inhibit variable and command expansion. See iRules\n   Optimization 101 - #4 - Delimiters: Braces, Brackets, Quotes and more for more information on this.\n   To use variables and commands with these key specifications, users should\n   either use the list command to construct a list, or use double quotes,\n   which Tcl will interpret as a list. See the last two examples below.\n\n   Note: 'persist none' disables persistence (whether enabled via profile\n   or iRule) until the current connection is closed or another persist\n   iRule command is used.\n\n   Note: The following persistence methods require a corresponding\n   persistence profile be added to the virtual server: ssl, msrdp, cookie","examples":"when CLIENTSSL_HANDSHAKE {\n   # Persist the client connection based on the SSL session ID\n    persist ssl\n}\n\n\nwhen HTTP_REQUEST {\n   # Look up the UIE persistence record for 11111111\n   persist lookup uie {11111111 pool pool_1}\n}\n\n\nwhen HTTP_REQUEST {\n\n   # Look up the client IP in UIE persistence records for any virtual server\n   set lookup_key [list [IP::client_addr] any virtual]\n   set value [persist lookup uie $lookup_key]\n}\n\n\nwhen HTTP_REQUEST {\n   # Save the value of the UIE persistence record for this client for any pool\n   set value [persist lookup uie \"[IP::client_addr] any pool\"]\n}\n\n\nwhen HTTP_REQUEST {\n   # Save the value of the UIE persistence record for a generic token for any virtual server\n   set value [persist lookup uie [list $myVar any virtual]]\n}\n\n\n# Select different persistence methods by HTTP URI\n\nwhen HTTP_REQUEST {\n\n   # Check the requested URI\n   switch -glob [HTTP::uri] {\n      \"/path1/*\" -\n      \"/path2/*\" {\n         # Request was for an IIS URI so select the pool and set a pool-specific cookie\n         pool iis_pool\n         persist cookie insert iis_persist 0\n      }\n      default {\n         # Request was for an iPlanet URI so select the pool and source addresspersistence with a /24 source mask\n         pool iplanet_pool\n         persist source_addr 255.255.255.0 0\n      }\n   }\n}\n\nUse CARP persistence to ensure connections between two hosts are hashed\nto the same firewall pool member in an LTM firewall sandwich regardless\nof which host initiates a connection.\n\nwhen CLIENT_ACCEPTED {\n        # Persist on the client and destination IP addresses\n        # Use lsort to order them the same regardless of which host is originating the connection\n        # Replace the space with an underscore so the persist command is given a single string\n        persist carp [string map {\" \" \"_\"} [lsort \"[IP::client_addr] [IP::local_addr]\"]]\n}","returnValue":""},
{"commandName":"node","description":"Causes the specified server node (IP address and port number) to be\nused directly, thus bypassing any load-balancing.\nIf the node command is called prior to the LB::server command a\nnull string is returned by LB::server as the node command overrides any\nprior pool selection logic.\n\nSyntax\n\nnode <addr> [<port>]\n\n     * Causes the specified server node (IP address and port number) to be\n       used directly, thus bypassing any load-balancing. Since statistics\n       and health monitoring are tied to pool membership, node status and\n       statistics for this connection will not be available. Use the\n       LB_FAILED event to catch server response failure.\n\n   Note: If <port> is omitted, the client's destination port is used for\n   the serverside connection.\n\nnode <addr>:<port>\n\n     * Causes the specified server node (IP address and port number) to be\n       used directly, thus bypassing any load-balancing. Since statistics\n       and health monitoring are tied to pool membership, node status and\n       statistics for this connection will not be available. Use the\n       LB_FAILED event to catch server response failure.\n\n   Note: <port> is required when using this syntax.\n   Note: When using the <port> option on a virtual server with a\n   destination port of \"any\", port translation must be enabled. Port\n   translation is disabled by default when a virtual server has a\n   destination port of \"any\".","examples":"when HTTP_REQUEST {\n  if { [HTTP::uri] ends_with \".gif\" } {\n     node 10.1.2.200 80\n  }\n}\nwhen LB_FAILED {\n  log local0. \"Selected server [LB::server] did not respond. Re-selecting node from myPool\"\n  pool myPool\n  LB::reselect\n}","returnValue":""},
{"commandName":"virtual","description":"Returns the name of the associated virtual server that the connection\nis flowing through. In 9.4.0 and higher, it can be also used to route\nthe connection to another virtual server and an optional IP address\nand port, without leaving the BIG-IP.\n\nSyntax\n\nvirtual name\n\n     * Return the name of the associated virtual server.\n\nvirtual <virtual server name> [<IP address>[:|.| ]<port>]\n\n     * Route the traffic to a virtual server and an optional IP address\n       and port instead of normal server selection by load balancing.\n\n   Note: In version 9.4.0 and higher, virtual or virtual name\n   returns the current virtual server's name. In previous versions, only\n   virtual name returns the current virtual server's name.\n   Note: In version 9.4.0 and higher, 'virtual ' can be used to route the\n   connection to another virtual server and an optional IP address and port,\n   without leaving the BIG-IP. This functionality did not exist in previous\n   versions. When no IP address is specified one must precede the virtual\n   command with an LB::reselect command if a pool member has already\n   been selected.\n   Note: In version 9.4.0 and higher, you can disable cmp on a virtual\n   server. If you disable cmp on the post processing virtual server,\n   ensure that the front virtual server is also cmp disabled.","examples":"when HTTP_REQUEST {\n  log local0. \"Current virtual server name: [virtual name]\"\n}\nwhen HTTP_REQUEST {\n  # Send request to a new virtual server\n  virtual my_post_processing_server\n}\nwhen HTTP_REQUEST {\n  # Send request to a new virtual server and a designated IP address.\n  # This can be a node, SNAT, pool member, virtual server, etc.\n  virtual my_post_processing_server $ip_tuple\n}","returnValue":""},
{"commandName":"vlan_id","description":"Returns the VLAN tag of the packet. This is a BIG-IP 4.X variable,\nprovided for backward-compatibility. You can use the equivalent 9.X\ncommand LINK::vlan_id instead.\n\nSyntax\n\nvlan_id\n\n     * Returns the VLAN tag of the packet.","examples":"","returnValue":""},
{"commandName":"forward","description":"Sets the connection to forward IP packets. This is strict forwarding\nand will bypass any pool configured on the virtual server.\nThe request will be forwarded out the appropriate interface according\nto the routes in the LTM routing table. No destination address or port\ntranslation is performed.\n\nSyntax\n\nforward\n\n     * Sets the connection to forward IP packets, bypassing load\n       balancing.","examples":"when CLIENT_ACCEPTED {\n  if { [class match [IP::client_addr] equals my_hosts_class]} {\n    snat 192.168.100.12\n  } else {\n    forward\n  }\n}","returnValue":""},
{"commandName":"snat","description":"Causes the system to assign the specified source address to the\nserverside connection(s). The assignment is valid for the duration of\nthe clientside connection or until 'snat none' is called. The iRule\nSNAT command overrides the SNAT configuration of the virtual server or\na SNAT pool. It does not override the 'Allow SNAT' setting of a pool.\n\nSyntax\n\nsnat <addr> [<port>] | none | automap\n\n     * Causes the system to assign the specified translation address to\n       the serverside connection.","examples":"# Apply a specific SNAT address for clients in the 10.10.10.0/24 subnet\nwhen CLIENT_ACCEPTED {\nif { [IP::addr [IP::client_addr] equals 10.10.10.0/24] }{\n      snat 192.168.20.10\n   }\n}\n\n\n# Apply SNAT autmap if the selected pool member IP address is 1.1.1.1\nwhen LB_SELECTED {\nIf { [IP::addr [LB::server addr] equals 1.1.1.1] } {\n     snat automap\n  }\n}\n\n\n# Apply SNAT automap for clients in the 10.10.10.0/24 subnet\nwhen CLIENT_ACCEPTED {\nif { [IP::addr [IP::local_addr] equals 10.10.10.0/24] }{\n      snat automap\n   }\n}\n\n\n# Assign a pool and configure SNAT based on the HTTP URI\nwhen HTTP_REQUEST {\n        switch -glob [string tolower [HTTP::path]] {\n                \"/app1*\" -\n                \"/app2*\" {\n                        # Select the corresponding pool and use SNAT automap\n                        pool app1_pool\n                        snat automap\n                }\n                \"/app3*\" {\n                        # Select the corresponding pool and do not use SNAT\n                        pool app3_pool\n                        snat none\n                }\n                default {\n                        # Select the corresponding pool and a specific SNAT address\n                        #  to source serverside connections from\n                        pool app4_pool\n                        snat 10.0.0.10\n                }\n        }\n}\n\n\n# Apply a specific SNAT address and port client destination address is 10.10.10.1\n#  and the client destination port is 1025\nwhen CLIENT_ACCEPTED {\nif { [IP::addr [IP::local_addr] equals 10.10.10.1] and [TCP::local_port] == 1025] }{\n      snat 1.1.1.1 80\n   }\n}","returnValue":""},
{"commandName":"urlcatblindquery","description":"Query the encrypted URL's hash for URL categorization","examples":"","returnValue":""},
{"commandName":"pem_dtos","description":"Queries DTOS (Device Type and OS) database","examples":"","returnValue":""},
{"commandName":"active_members","description":"Returns the number or list of active members in the specified pool.","examples":"Test the number of active members in a pool when a client connects to the VIP:\nwhen CLIENT_ACCEPTED {\n    if { [active_members http_pool] >= 2 } {\n        pool http_pool\n    }\n}\n\nTest the number of active members in a pool when a client makes an HTTP request:\nwhen HTTP_REQUEST {\n    if { [active_members http_pool] >= 2 } {\n        pool http_pool\n    }\n}\n\nTo retrieve a list containing the active members in a pool\nwhen HTTP_REQUEST {\n    set members [active_members -list http_pool]\n    log local0. \"Active members are: $members\"\n}\n\nLogs the following:\nActive members are: {{192.168.1.1 80} {192.168.1.2 80}}","returnValue":"active_members <pool_name>\n    Returns the number of active members in the specified pool.\n\nactive_members -list <pool_name>\n    Returns a tcl list of lists, each containing the IP and port of an active member in the specified pool. (see output example below)\n    Note: GTM does not support the -list option"},
{"commandName":"active_nodes","description":"Returns the alias for active members of the specified pool (for BIG-IP version 4.X compatibility).","examples":"when HTTP_REQUEST {\n    log local0. \"There are [active_nodes http_pool] active nodes in the pool.\"\n}\n\nwhen CLIENT_ACCEPTED {\n    # Check if the client IP address is a node in the VIP's default pool\n    if {[matchclass [IP::client_addr] equals [active_nodes -list [LB::server pool]]]}{\n        log local0. \"SNAT'ing for [IP::client_addr], member of pool [LB::server pool]\"\n        snat automap\n    }\n}","returnValue":"active_nodes <pool name>\n    Returns the number of active members of the specified pool (for BIG-IP version 4.X compatibility).\n\nactive_nodes -list <pool_name>\n    Returns a tcl list containing the IP address of each active member in the specified pool."},
{"commandName":"b64encode","description":"Returns a string that is base-64 encoded, or if an error occurs, an empty string.","examples":"when RULE_INIT {\n    set ::key [AES::key]\n}\nwhen HTTP_RESPONSE {\n    set decrypted [HTTP::cookie \"MyCookie\"]\n    HTTP::cookie remove \"MyCookie\"\n    set encrypted [b64encode [AES::encrypt $::key $decrypted]]\n    HTTP::cookie insert name \"MyCookie\" value $encrypted\n}\nwhen HTTP_REQUEST {\n    set encrypted [HTTP::cookie \"MyCookie\"]\n    HTTP::cookie remove \"MyCookie\"\n    set decrypted [AES::decrypt $::key [b64decode $encrypted]]\n    HTTP::cookie insert name \"MyCookie\" value $decrypted\n}","returnValue":"b64encode <string>\n    Returns a string that is base-64 encoded, or if an error occurs, an empty string."},
{"commandName":"b64decode","description":"Returns a string that is base-64 decoded.","examples":"when RULE_INIT {\n   set ::key [AES::key]\n}\nwhen HTTP_RESPONSE {\n   set decrypted [HTTP::cookie \"MyCookie\"]\n   HTTP::cookie remove \"MyCookie\"\n   set encrypted [b64encode [AES::encrypt $::key $decrypted]]\n   HTTP::cookie insert name \"MyCookie\" value $encrypted\n}\nwhen HTTP_REQUEST {\n   set encrypted [HTTP::cookie \"MyCookie\"]\n   HTTP::cookie remove \"MyCookie\"\n   set decrypted [AES::decrypt $::key [b64decode $encrypted]]\n   HTTP::cookie insert name \"MyCookie\" value $decrypted\n}\n\nNote: b64decode seems to trigger a runtime TCL error when decoding fails. See below for an example which uses catch to handle this.\n\nTest decoding an invalid string\nlog local0. \"[b64decode \"\\\\a b c d\"]\"\n\nLTM log output\n01220001:3: TCL error: scratch_rule <RULE_INIT> - conversion error invoked from within \"b64decode \"\\\\a b c d\"\"\n\nUse catch to handle runtime errors when decoding a potentially invalid input string\n\n# Try to base64 decode $string_b64encoded. Handle errors using catch.\n#   Successful execution of b64decode by catch will return 0 and the output will be written to $string_b64decoded\nif {[catch {b64decode $string_b64encoded} string_b64decoded] == 0 and $string_b64decoded ne \"\"}{\n   # base64 decoding succeeded\n} else {\n   # base64 decoding failed\n}","returnValue":"b64decode <string>\n    Returns a string that is base-64 decoded"},
{},
{"commandName":"md5","description":"Returns the RSA Data Security, Inc. MD5 Message Digest Algorithm (md5) message digest of the specified string, or if an error occurs, an empty string. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [md5 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"md5 <string>\n    Returns the RSA Data Security, Inc. MD5 Message Digest Algorithm (md5) message digest of the specified string, or if an error occurs, an empty string."},
{},
{"commandName":"client_addr","description":"Returns the client IP address of a connection. This is a BIG-IP version 4.X variable, provided for backward compatibility. You can use the equivalent 9.X command, IP::client_addr instead.","examples":"","returnValue":"client_addr\n    Returns the client IP address of a connection."},
{"commandName":"client_port","description":"Returns the TCP port number/service of the specified client. This is a BIG-IP version 4.X variable, provided for backward compatibility. You can use the equivalent 9.X command, TCP::client_port instead.","examples":"","returnValue":"client_port\n    Returns the TCP port number/service of the specified client."},
{"commandName":"clone","description":"Causes the system to clone traffic to the specified pool, pool member or vlan regardless of monitor status. (Pool member status may be determined by the use of the LB::status command. Failure to select a server because none are available may be prevented by using the active_members command to test the number of active members in the target pool before choosing it.) Any responses to cloned traffic from pool members will be ignored. \"Clone\" is meant to be used to allow traffic to be sent to devices such as IDS, Sniffers, etc and is not meant to try load balancing a single request to multiple systems at the same time.\n\nPool / member may be selected conditionally. If multiple conditions match, the last match will determine the pool/member to which this traffic is cloned.\n\nNexthop <vlan> will be used to send cloned traffic to physical interface(s) mapped to the vlan.","examples":"# Clone traffic based on the requested HTTP URI\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] starts_with \"/clone_me\" } {\n    pool real_pool\n    clone pool clone_pool\n  } else {\n    pool real_pool\n  }\n}\n\n# Clone only traffic destined for one VS pool member\nwhen LB_SELECTED {\n  if { [IP::addr [LB::server addr] equals 10.1.1.1] } {\n    clone pool member1_clone_pool\n  }\n}\n\nwhen CLIENT_ACCEPTED {\n   clone nexthop tap_vlan\n}","returnValue":"clone pool <pool_name>\n    Specifies the pool to which you want to send the cloned traffic.\n\nclone pool <pool_name> [member <addr> [<port>]]\n    Specifies a pool member to which you want to directly send the cloned traffic.\n\nclone nexthop <vlan>\n    Specifies a vlan to which you want to send the cloned traffic."},
{"commandName":"peer","description":"Causes the specified iRule commands to be evaluated under the peer-side context.","examples":"when SERVER_CONNECTED {\n  peer { TCP::collect }\n}\nwhen CLIENT_DATA {\n  if { [TCP::payload] starts_with \"EHLO\" } {\n    TCP::respond \"500 5.3.3 Unrecognized command\\r\\n\"\n    set len [TCP::payload length]\n    TCP::payload replace 0 $len \"\"\n    TCP::release\n  } else {\n    TCP::release\n    TCP::collect\n  }\n}","returnValue":""},
{"commandName":"clientside","description":"Causes the specified iRule commands to be evaluated under the client-side context. This command has no effect if the iRule is already being evaluated under the client-side context. If there is no argument, the command returns 1 if the current event is in the clientside context or 0 if not.","examples":"when SERVER_CONNECTED {\n   # Check if the client IP address is 10.1.1.80\n   # [clientside {IP::remote_addr}] is equivalent to [IP::client_addr]\n   if { [IP::addr [clientside {IP::remote_addr}] equals 10.1.1.80] } {\n      # Do something like drop the packets in this example\n      discard\n   }\n}","returnValue":"clientside\n    Returns 1 if the current event is in the clientside context or 0 if not.\n\nclientside {<iRule commands>}\n    Causes the specified iRule commands to be evaluated under the client-side context."},
{"commandName":"serverside","description":"Causes the specified iRule command or commands to be evaluated under the server-side context. This command has no effect if the iRule is already being evaluated under the server-side context. If there is no argument, the command returns 1 if the current event is in the serverside context or 0 if not.","examples":"when CLIENT_ACCEPTED {\n\n   # Check if the server (pool member) IP address is 10.1.1.80\n   # [serverside {IP::remote_addr}] is equivalent to [IP::server_addr]\n   if { [IP::addr [serverside {IP::remote_addr}] equals 10.1.1.80] } {\n\n      # Do something like drop the packets in this example\n      discard\n   }\n}","returnValue":"serverside\n    Returns 1 if the current event is in the serverside context or 0 if not.\n\nserverside { <iRule command> }\n    Causes the specified iRule command or commands to be evaluated under the server-side context."},
{"commandName":"close","description":"This command closes an existing sideband connection. It is one of several commands that make up the ability to create sideband connections from iRules.","examples":"# Open a sideband connection with a connection timeout of 100 ms and an idle timeout of 30 seconds\n#   to a local virtual server name sideband_virtual_server\nset conn_id [connect -timeout 100 -idle 30 -status conn_status sideband_virtual_server]\n\n# Same as above, but use an external host IP:port instead of a virtual server name\nset conn_id [connect -timeout 100 -idle 30 -status conn_status 10.0.0.10:80]\n\n# close the connection\nclose conn_id","returnValue":"close <connection>\n    closes an existing connection"},
{"commandName":"connect","description":"This command establishes a sideband connection. It is one of several commands that make up the ability to use sideband connections from iRules.","examples":"# Open a sideband connection with a connection timeout of 100 ms and an idle timeout of 30 seconds\n#   to a local virtual server name sideband_virtual_server\nset conn_id [connect -timeout 100 -idle 30 -status conn_status sideband_virtual_server]\n\n# Same as above, but use an external host IP:port instead of a virtual server name\nset conn_id [connect -timeout 100 -idle 30 -status conn_status 10.0.0.10:80]\n\n\nExample with more complete error handling:\n# Connect to an external host with a connection timeout of 100 ms and an idle timeout of 30 seconds\n# Use catch to handle any errors in the destination virtual server name or external host:port\n# Check if the return value saved to $conn_id is not null\nif {[catch {connect -timeout 1000 -idle 30 -status conn_status sideband_virtual_server} conn_id] == 0 && $conn_id ne \"\"}{\n    log local0. \"Connect returns: $conn_id and conn status: $conn_status\"\n} else {\n    log local0. \"Connection could not be established to sideband_virtual_server\"\n}","returnValue":"This command opens a sideband connection to the specified destination.\n\nThe connect command returns a connection identifier, assuming the connection attempt succeeds. This connection ID is then used to send and receive data on the connection as well as close it. If the connection attempt fails, a null string is returned. The connect command will suspend iRule execution until the connection attempt succeeds or fails.\n\nIf you wanted the sideband connection to be encrypted with SSL, you should target a virtual server that has a Server SSL profile associated to it. Connections from the sideband connection to the sideband VS will be unencrypted, but all external traffic will be encrypted with SSL.\n\nArguments\n    destination specifies where the traffic should be sent. This can either be the name of a virtual server, or an IP address and port, in the format \"IPv4:port\" or \"IPv6.port\".\n\n\n-protocol specifies the IP protocol to be used. The default is TCP, but can be explicitly specified. Note than in some versions, the protocol may be case-sensitive, and is not validated during rule load time. An unknown protocol will trigger a TCL error, and result in the client connection being torn down.\n\n\n-myaddr specifies the source address for the connection. See the caveats below. The default is to let the BIG-IP pick, in which case the system will use the closest Self-IP to the destination as the source address; if targeting a virtual server that has \"address translation\" disabled, the source address will be the local TMM's internal address (in 127.1.0.0/16).\n\n\n-myport specifies the source port for the connection. See the caveats below. The default is to let the BIG-IP pick. Even if specified, the BIG-IP may choose a different source port to ensure return traffic disaggregates to the same TMM.\n\n\n-timeout $ms is the time in milliseconds to wait to establish the connection.\n\n\n-idle $sec is the idle timeout to use for the connection; how long to leave the connection open if it is unused. The default is 300 seconds.\n\n\n-tos $tos specifies the IP TOS to use (see IP::tos)\n\n\n-status varname will save the status of the connection attempt into varname. The possible status values are:\n    connected - the connection is established (success)\n    timeout - the connection attempt timed out (if a timeout was specified)\n    failed - the connection attempt failed\n\n\nNote that the connect command may raise a TCL error in some failure conditions, e.g. if the BIG-IP is unable to route to the destination. If a TCL error is raised, the status variable may be unset.\n\nmyaddr and myport\n    If specifying an IP and port as the destination, the IP address specified as -myaddr must be one to which TMM will respond to ARP requests (e.g. a self IP address), to ensure that return traffic is properly routed back to the BIG-IP.\n\nIf using a VS or VIP as the destination, -myaddr must not be specified, as it breaks the functionality (as of version 11.5.0). Instead, omit the -myaddr and TMM will use the local TMM's IP address (127.1.x.x) as the source address instead."},
{"commandName":"recv","description":"This command receives data from an existing sideband connection (established with connect). It is one of several commands that make up the ability to create sideband connections from iRules.","examples":"when HTTP_REQUEST {\n    set dest \"10.10.145.1:80\"\n    set conn [connect -protocol TCP -timeout 30000 -idle 30 $dest]\n    set data \"GET /mypage/index.html HTTP/1.0\\r\\n\\r\\n\"\n    send $conn $data\n    # recv 2000 chars get recv bytes error\n    set recv_2kbytes [recv -timeout 30000 2000 $conn]\n    log local0. \"Recv data: '$recv_2kbytes'\"\n    set length_recv [string length $recv_2kbytes]\n    log local0. \"length_recv has $length_recv bytes in it.\"\n    close $conn\n}","returnValue":"Receives some data (up to numChars bytes) from a sideband connection. If varname is specified, the response is stored in that variable, and recv returns the amount of data received. Otherwise, recv returns the response data.\n\nArguments\n\n-timeout ms specifies the amount of time to wait for the data to be received. If unspecified, the default is an immediate timeout, and likely not what you want in a typical situation.\n\n<varname> is the name of the variable in which to store the received data. If specified, recv will return the number of bytes received. If unspecified, recv will return the received data.\n\n-eol causes the command to suspend until an end-of-line has been received or the timeout expires. The first line of data will be returned.\n\n-peek will return the data received, but will leave it buffered for a subsequent call to recv\n\nIf -status status_varname is used, the status of the connection attempt is saved to status_varname. These are the possible return values for the recv status:\n    received - Got the requested amount of data\n    closed - the connection was closed. Some data may have been received.\n    timeout - A timeout occurred. Some data may have been received.\n    failed - An unexpected error occurred"},
{"commandName":"send","description":"This command sends data on an existing sideband connection (established with connect). It is one of several commands that make up the ability to create sideband connections from iRules.\n\nArguments\n\n    <connection> is the connection identifier returned from connect\n\n    <data> is the data to send\n\n    -timeout ms specifies the amount of time to wait for the data to be sent. The default is an immediate timeout.\n\n    -status varname will save the result of the send command into varname. The possible status values are:\n        1. sent - the data was sent successfully\n        2. timeout - the specified timeout has occurred\n        3. closed - the sideband connection has closed\n        4. busy - the local TCP refused to accept the data\n\nNote: The send command may also raise a TCL error if the sideband connection was already closed. If a TCL error is raised, the status variable may be unset.","examples":"when LB_SELECTED {\n    # Save some data to send\n    set dest \"10.0.16.1:8888\"\n    set data \"GET /mypage/myindex2.html HTTP/1.0\\r\\n\\r\\n\"\n\n    # Open a new TCP connection to $dest\n    set conn_id [connect -protocol TCP -timeout 30000 -idle 30 $dest]\n\n    # Send the data with a 1000ms timeout on the connection identifier received from the connect command\n    set send_bytes [send -timeout 1000 -status send_status $conn_id $data]\n\n    # Log the number of bytes sent and the send status\n    log local0. \"Sent $send_bytes with status $send_status\"\n}","returnValue":"Sends data on a specified sideband connection, and returns an integer representing the amount of data that was sent."},
{"commandName":"crc32","description":"The crc32 command calculates a 32-bit cyclic redundancy check value\n(CRC) for the bytes in a string using the well-known CRC-32 (Ethernet\nCRC) scheme. The polynomial is 0x04c11db7, the CRC register is\ninitialized with 0xffffffff, the input bytes are taken msb-first, and\nthe result is the complement of the final register value reflected.\n(crc32 implements the scheme called \"CRC-32\" in this Catalogue of\nParametrised CRC Algorithms.)\ncrc32 returns a number, or the empty string if an error occurs. CRC\nvalues with their most significant bits set are returned as negative\nnumbers (due to sign-bit extension upon conversion to 64-bit iRules\nintegers). To obtain a correct unsigned 32-bit CRC in every case apply\na 32-bit mask like this: set CRC [expr {0xffffffff & [crc32 $msg]}].\n(To display a CRC value, use something like log local0.info [format\n\"CRC = 0x%08x\" [expr {0xffffffff & [crc32 $msg]}]] .)\n\nSyntax\n\ncrc32 <string>\n\n     * Returns the crc32 check value for the specified string, or if an\n       error occurs, an empty string.","examples":"when HTTP_REQUEST {\n   # Create a hash value for the host based on crc32\n   # This could also be based on md5 or any other implementation\n   # of a hash like djb or something.\nset key [crc32 [HTTP::host]]\n\n   # Modulo the hash value by 1 - odd goes to one member, even another\nset key [expr {$key & 1}]\n\n   # Route the request to the pool member based on the modulus\n   # of the hash value.\nswitch $key {\n0 { pool my_pool member 1.2.3.4:80 }\n1 { pool my_pool member 5.6.7.8:80 }\n   }\n}","returnValue":""},
{"commandName":"cpu","description":"The cpu usage command returns the average TMM cpu load for the given\ninterval. All averages are exponential weighted moving averages over\nthe interval.\n\nSyntax\n\ncpu usage [1sec | 5secs | 15secs | 1min | 5mins | 15mins | all_seconds | all_minutes]\n\n     * Returns the average TMM cpu load for the given interval","examples":"when HTTP_REQUEST {\n  if{ [cpu usage 5sec] <= 1} {\n    pool1\n  } else {\n    HTTP::redirect \"http://anotherpool.com\"\n  }\n}\n\n\nwhen RULE_INIT {\n        foreach slice [split \"1sec|5secs|15secs|1min|5mins|15mins|all_seconds|all_minutes\" \"|\"] {\n                log local0. \"\\[cpu usage $slice\\]: [cpu usage $slice]\"\n        }\n}\n\n# Log output (from an unloaded LTM unit):\n\n[cpu usage 1sec]: 0\n[cpu usage 5secs]: 0\n[cpu usage 15secs]: 0\n[cpu usage 1min]: 0\n[cpu usage 5mins]: 0\n[cpu usage 15mins]: 0\n[cpu usage all_seconds]: 0 0 0\n[cpu usage all_minutes]: 0 0 0","returnValue":""},
{"commandName":"decode_uri","description":"Decodes the specified string using HTTP URI encoding per RFC2616 and\nreturns the result. This is a BIG-IP 4.x variable, provided for\nbackward-compatibiliy. You can use the equivalent 9.X commmand\nURI::decode instead.\n\nSyntax\n\ndecode_uri <string>\n\n     * Decodes the specified string using HTTP URI encoding per RFC2616\n       and returns the result.","examples":"","returnValue":""},
{"commandName":"discard","description":"Causes the current packet or connection (depending on the context of\nthe event) to be dropped/discarded and the rule continues (no implied\nreturn). This command is identical to drop.\n\nSyntax\n\ndiscard\n\n     * Causes the current packet or connection (depending on the context\n       of the event) to be discarded. Nothing is sent to the client.\n     * Removes the corresponding entry from the system connection table.\n       Note that, in the case of TCP, if subsequent segments arrive\n       without SYN bit set (and ACK bit unset), a RST will be sent as a\n       result. This is the standard behavior when segments of that type\n       arrive when there is no system connection entry.","examples":"when SERVER_CONNECTED {\n  if { [IP::addr [IP::client_addr] equals 10.1.1.80] } {\n     discard\n     log local0. \"connection discarded from [IP::client_addr]\"\n  }\n }\n\nAfter \"discard\" is executed, the rule will continue until the end of\nthe current event so \"connection discarded ...\" will be logged.","returnValue":""},
{"commandName":"domain","description":"A custom iRule function which parses the specified string as a\ndotted domain name and returns the last <count> portions of the domain\nname.\n\nSyntax\n\ndomain <string> <count>\n\n     * Parses the specified string as a dotted domain name and returns the\n       last <count>* portions of the domain name.","examples":"when HTTP_REQUEST\nif { [HTTP::uri] ends_with \".html\" } {\n      pool cache_pool\n      set key [crc32 [concat [domain [HTTP::host] 2] [HTTP::uri]]]\n}\n...\n\nThis code:\n\n log local0. [domain www.sub.my.domain.com 1]   ; # result: com\n log local0. [domain www.sub.my.domain.com 2]   ; # result: domain.com\n log local0. [domain www.sub.my.domain.com 3]   ; # result: my.domain.com\n log local0. [domain www.sub.my.domain.com 4]   ; # result: sub.my.domain.com\n log local0. [domain www.sub.my.domain.com 5]   ; # result: www.sub.my.domain.com\n log local0. [domain www.sub.my.domain.com 6]   ; # result: www.sub.my.domain.com\n\nThis code:\n\n log local0. [domain www.sub.my.domain.co.uk 1]   ; # result: uk\n log local0. [domain www.sub.my.domain.co.uk 2]   ; # result: co.uk\n log local0. [domain www.sub.my.domain.co.uk 3]   ; # result: domain.co.uk\n log local0. [domain www.sub.my.domain.co.uk 4]   ; # result: my.domain.co.uk\n log local0. [domain www.sub.my.domain.co.uk 5]   ; # result: sub.my.domain.co.uk\n log local0. [domain www.sub.my.domain.co.uk 6]   ; # result: www.sub.my.domain.co.uk\n\n   (* A bug in v9.1.0 truncates last character if <count> = 1 or 2.)","returnValue":""},
{"commandName":"drop","description":"Causes the current packet or connection (depending on the context of\nthe event) to be dropped/discarded and the rule continues (no implied\nreturn). This command is identical to discard.\n\nSyntax\n\ndrop\n\n     * Causes the current packet or connection (depending on the context\n       of the event) to be discarded. Nothing is sent to the client.\n     * Removes the corresponding entry from the system connection table.\n       Note that, in the case of TCP, if subsequent segments arrive\n       without SYN bit set (and ACK bit unset), a RST will be sent as a\n       result. This is the standard behavior when segments of that type\n       arrive when there is no system connection entry.","examples":"when SERVER_CONNECTED {\n  if { [IP::addr [IP::client_addr] equals 10.1.1.80] } {\n     drop\n     log local0. \"connection dropped from [IP::client_addr]\"\n  }\n}\n\nAfter \"drop\" is executed, the rule will continue until the end of the\ncurrent event so \"connection dropped ...\" will be logged.","returnValue":""},
{"commandName":"event","description":"Enables or disables evaluation of the specified iRule event, or all\niRule events, on this connection. However, the iRule continues to run.\n\nSyntax\n\nevent [<name>] [enable|disable] | [enable all|disable all]\n\n     * Discontinues or continues evaluating the specified iRule event, or\n       all iRule events, on this connection.\n\nAdded in v11:\nevent info\n\n     * Returns a string describing why this event was fired (v11+ only).\n       Added to support LB::queue/LB_QUEUED so limited to\n       LB_FAILED currently, but is anticipated that this will become\n       more generalized in the future.\n\n   For details on the possible error codes below, please contact F5\n   Support.\n   Error code             Description\n   ERR_MEM                Out of memory error\n   ERR_BUF                Buffer error\n   ERR_VAL                Illegal value\n   ERR_ARG                Illegal argument\n   ERR_BOUNDS             Out of bounds\n   ERR_TOOBIG             Packet or data too big\n   ERR_ABRT               Connection aborted\n   ERR_CONN               Not connected\n   ERR_VLAN               Vlan error\n   ERR_RTE                Routing problem\n   ERR_NEIGHBOR           Neighbor problem\n   ERR_USE                Address in use\n   ERR_PORT               Out of ports\n   ERR_IO                 Input/Output error\n   ERR_EXPIRED            Expired data\n   ERR_REJECT             Traffic rejected\n   ERR_MORE_DATA          More data required\n   ERR_NOT_FOUND          Not found\n   ERR_HUD_ABORT          Hudfilter abort\n   ERR_HUD_TEARDOWN       Hudfilter teardown\n   ERR_INPROGRESS         Operation now in progress\n   ERR_MCP                MCP error or unsupported message\n   ERR_DB                 Database error\n   ERR_TCL                TCL error\n   ERR_DL                 Dynamic library error\n   ERR_ISCONNECTED        Already connected\n   ERR_HA_UNIT_NOT_ACTIVE The HA unit is not active for this TMM\n   ERR_NOTINPROGRESS      Prerequisite operation not in progress\n   ERR_TYPE               Type mismatch\n   ERR_VERSION            Improper version\n   ERR_INIT               Initialization error\n   ERR_UNKNOWN            Unknown error\n   ERR_NOT_SUPPORTED      Unsupported action\n   ERR_LICENSE            Feature not licensed\n   ERR_ALIGN              Buffer alignment error\n   ERR_TIMEOUT            Operation timed out\n   ERR_ENCAP_FAILED       Encapsulation failed\n   ERR_VERBOTEN           Operation not allowed\n   ERR_TUNNEL             Tunnel error\n   ERR_WOULDBLOCK         Resource temporarily unavailable\n   ERR_OPENSSLRNG         OpenSSL RNG call failed\n   ERR_RETRY              Retry the operation\n   ERR_DUPLICATE_ENTRY    Duplicate entry, item already exists","examples":"when HTTP_RESPONSE {\n  COMPRESS::method prefer gzip\n  event disable\n}","returnValue":""},
{"commandName":"fasthash","description":"fasthash is guaranteed to return a high quality hash of the input as quickly as practical. The hash value returned is between 0 and 2^63-1 inclusive (a positive integer).\n\nfasthash was added because there are many use cases (ie CARP) which need a hash of some value (ie URI) and which were using crc32 (which is a bad and slow hash function).\n\nNote: fasthash does not guarantee to provide the same hash value across different BIGIP versions and over BIGIP reboots. Do not use fasthash for long term and persistent storage.\n\nSyntax\n\nfasthash <string>\n\n     * Returns the numeric hash for the specified string","examples":"when CLIENT_ACCEPTED {\n    set str \"hello world\"\n    log local0. \"hash of $str is [fasthash $str]\"\n}","returnValue":"Returns the numeric hash for the specified string"},
{"commandName":"findclass","description":"Searches a data group list for a member whose key matches the specified\nstring, and if a match is found, returns the data-group member string.\n\nNote: findclass has been deprecated in v10 in favor of the new\nclass commands. The class command offers better functionality and\nperformance than findclass\nOnly the key value of the data group list member (the portion up to the\nfirst separator character, which defaults to space unless otherwise\nspecified) is compared to the specified string to determine a match.\n\nIf a match is found, and no separator character is specified, the\ncommand returns the entire member value associated with the matched key\n(including the key).\n\nIf a match is found and a separator is specified, the data group member\nis split at the first separator, and the portion of the list member\nfollowing the first separator is returned.\nNote that you should not use a $:: or :: prefix on the datagroup name\nwhen using the class command (or in any datagroup reference on 9.4.4 or\nlater).\n\nIn v9.4.4 - 10, using $::datagroup_name will work but demote the\nvirtual server from running on all TMMs. For details, see the CMP\ncompatibility page.\n\nIn v11, using $::datagroup_name will result in a runtime error and TCP\nreset being sent to the client!\n\nSyntax\n\nfindclass <string> <data group>\n\n     * Searches for a member whose key exactly matches . If a match is\n       found, it returns the entire data group list member intact,\n       including the key and the separator.\n\nfindclass <string> <data group> <separator>\n\n     * Searches for a member whose key exactly matches . If a match is\n       found, it returns the portion of the data group list member\n       following the first instance of .","examples":"class dest_pairs_dg {\n  \"8080 proxy\"\n  \"8020 snatpool2\"\n  \"8081 proxy2\"\n  \"8084 proxy3\"\n  \"8140 snatpool6\"\n}\n\nwhen CLIENT_ACCEPTED {\n  set my_spool [findclass [TCP::local_port] dest_pairs_dg \" \"]\n  if { $my_spool ne \"\" } {\n    snatpool $my_spool\n  }\n}\n\n\nclass URIredirects_dg {\n  \"/dir1/dir2/dir3/ http://somehost.somewhere.com/redirect_target.html\"\n  \"/dir4/dir5/dir6/ http://someotherhost.nowhere.com/redirect_target.html\"\n}\n\nwhen HTTP_REQUEST {\n  set location [findclass [HTTP::uri] URIredirects_dg \" \"]\n  if { $location ne \"\" } {\n    HTTP::redirect $location\n  }\n}\n\n\nclass myRedirects_dg {\n  \"host1.domain.com 302 https://securehost.domain.com\"\n  \"host2.domain.com 301 https://securehost2.domain.com\"\n}\n\nwhen HTTP_REQUEST {\n\n   # Check if there is a class entry which starts with the requested URI\nset row [findclass [string tolower [HTTP::host]] myRedirects_dg]\n\n   # Check if there was a matched row\nif { $row ne \"\" }{\n\n      # Send a response using the status and location from the class\n      HTTP::respond [getfield $row \" \" 2] Location [getfield $row \" \" 3][HTTP::uri] Connection Close\n\n      # Clear the row variable\n      unset row\n   }\n}","returnValue":""},
{"commandName":"findstr","description":"A custom iRule function which finds a string within another string\nand returns the string starting at the offset specified from the match.\n\nSyntax\n\nfindstr <string> <search_string> [<skip_count> [<terminator>]]\n     * Finds the string <search_string> within <string> and returns a\n       sub-string based on the <skip_count> and <terminator> from the\n       matched location. Note the following:\n          + If the <skip_count> argument is not specified, it defaults to\n            zero. If the <skip_count> argument is omitted, the\n            <terminator> element must not be specified.\n          + The <terminator> argument may be either a length or string of\n            one or more characters.\n          + If the <terminator> argument is not specified, it defaults to\n            the end of the string.\n          + <search_string> and <terminator> may be delimited by whitespace only,\n            by double quotes, or by curly braces. Single quotes are taken\n            literally, rather than as delimiters, meaning that the match will fail\n            if the search string is delimited with single quotes, and the match\n            will extend to the end of the string if the termination character is\n            delimited with single quotes (neither being the intended result.)\n          + If either <terminator> <search_string> contain a double quote\n            character, it can be escaped with a backslash immediately preceding the\n            character, or by enclosing the entire string in curly braces {}. Either\n            value may also be represented by a variable to take advantage of the\n            natural delimiting they offer. (Don't use curly braces to delimit\n            variables or they won't expand).\n          + This command, without <skip_count> or <terminator>, is\n            equivalent to the following Tcl command:\n                string range <string> [string first <search_string> <string>] end","examples":"This iRule parses a session ID from the HTTP path and if found persists\noff of it using UIE persistence.\n\nwhen HTTP_REQUEST {\n\n   # Check for /install/ or /scripts/ in the path\nswitch -glob [HTTP::path] {\n      \"*/install/*\" {\n\n         # Parse the URI \"directory\" after install. Look for /install/, skip 9 characters and match up to the next /.\n         set session_id [findstr [HTTP::path] /install/ 9 /]\n      }\n      \"*/scripts/*\" {\n         # Parse the URI \"directory\" after scripts. Look for /scripts/, skip 9 characters and match up to the next /.\n         set session_id [findstr [HTTP::path] /scripts/ 9 /]\n      }\n      default {\n         set session_id \"\"\n      }\n   }\nif {$session_id ne \"\"}{\n\n      # Persist on the parsed session ID for X seconds\n      persist uie $session_id 1800\n   }\n}\n\nThis rule logs the URL value\n   (https://host.domain.com/path/file.ext?...&var=val)\n\nwhen RULE_INIT {\n  set static::payload {<meta HTTP-EQUIV=\"REFRESH\" CONTENT=\"0; URL=https://host.domain.com/path/file.ext?...&var=val\">}\n  set static::term {\">}\n  set urlresponse [findstr $static::payload URL= 4 $static::term]\n  log local0. \"urlresponse $urlresponse\"\n}\n\nParse the domain from a SIP header. Find the first @ instance, skip 1\ncharacter and read up until the first > or the end of the string.\n\nlog local0. \"findstr output: [findstr \"<sip:+12065551234@sip.example.com>\" \"@\" 1 \">\"]\"\n# Logs: findstr output: sip.example.com\n\nExample using a multi-character terminator:\n\nlog local0. \"findstr output: [findstr \"aaa123456xxyz\" \"aaa\" 3 \"xyz\"]\"\n# Logs: findstr output: 123456x","returnValue":""},
{"commandName":"listen","description":"Sets up a related ephemeral listener to allow an incoming related\nconnection to be established. The source address and/or port of the\nrelated connection is unknown but the destination address and port are\nknown.\n\nSyntax\n\nlisten {\n    proto <ip_protocol>\n    timeout <seconds>\n    bind <vlan> <addr> <port>\n    server <addr> <port>\n    allow <addr> [<port>]\n}\n\n    * Sets up a related ephemeral listener to allow an incoming related\n       connection to be established:\n       + proto: The IP protocol number used in the connection. See /etc/protocols. Usually 6 (TCP) or 17 (UDP). See also IP::protocol\n       + timeout: The number of seconds to hold the listener open waiting\n         on a connection.\n       + bind: vlan, addr, port to listen on. See also LINK::vlan_id\n       + server: The address and port to connect the listening connection to. See also LB::server\n       + allow: The address and optional port to restrict the incoming connection to. See also IP::client_addr","examples":"# Note, this example is not quite working yet...\n# connect to virtual and send something like \"L 4444\" to listen on port 4444.\nrule rl_listen {\n\nwhen RULE_INIT {\n      set my_port \"\"\n   }\nwhen CLIENT_ACCEPTED {\n      TCP::collect 6\n   }\nwhen CLIENT_DATA {\n      set my_port [getfield [TCP::payload 6] \" \" 2]\n   }\nwhen LB_SELECTED {\n      listen {\n         proto [IP::protocol]\n         timeout 30\n         bind [LINK::vlan_id] [IP::local_addr] $my_port\n         server [LB::server addr] 7\n         allow [IP::client_addr]\n      }\n   }\n}","returnValue":""},
{"commandName":"getfield","description":"A custom iRule function which splits a string on a character or\nstring, and returns the string corresponding to the specific field.\n\nSyntax\n\n\ngetfield <string> <split> <field_number>\n\n     * Splits a string on a character or string, and returns the string\n       corresponding to the specific field. The field_number parameter is\n       1 indexed.","examples":"Extract specific columns from a data group list match:\n\nclass HostRedirects {\nwww.domain.com https://www.domain.com/\nhost.domain.com http://host2.domain.com/\nanother.domain.com https://www.domain.com/another\n}\nrule HostRedirects {\nwhen HTTP_REQUEST {\n  set row [findclass [HTTP::host] $::HostRedirects]\n  if { not ($row eq \"\")}{\n    HTTP::redirect [getfield $row \" \" 2][HTTP::uri]\n    return\n  }\n}\n}\n\nTo extract only the hostname from the host header (strips any trailing\n   \":###\" port specification)\n\nwhen HTTP_REQUEST {\n  set hostname [getfield [HTTP::host] \":\" 1]\n}\n\nTo redirect any request for a domain.com host to the same\nhostname.subdomain @ domain.org (uses a multi-character split string\nand field_number 1 to extract only those characters in the hostname\nbefore the split string.):\n\nwhen HTTP_REQUEST {\n  if { [HTTP::host] contains \"domain.com\"} {\n    HTTP::redirect https://[getfield [HTTP::host] \".domain.com\" 1].domain.org[HTTP::uri]\n  }\n}\n\n     * When used to compare a valid IP address (by Joe)\n\n\nset addr \"10.10.10.10\"\nset a [getfield $addr \".\" 1]\nset b [getfield $addr \".\" 2]\nset c [getfield $addr \".\" 3]\nset d [getfield $addr \".\" 4]\n\n# Or use scan instead to parse the IP octets to variables $a $b $c $d\nscan $addr {%d.%d.%d.%d} a b d c\n\nif { (0 <= $a) && ($a <= 255) &&\n     (0 <= $b) && ($b <= 255) &&\n     (0 <= $c) && ($c <= 255) &&\n     (0 <= $d) && ($d <= 255) } {\nlog local0. \"$addr is a valid IP Address\"\n} else {\n  log local0. \"$addr is NOT a valid IP Address\"\n}","returnValue":""},
{"commandName":"htonl","description":"Convert the unsigned integer from host byte order to network byte\norder.\n\nSyntax\n\nhtonl <hostlong>\n\n     * Convert the unsigned integer from host byte order to network byte\n       order.","examples":"when HTTP_REQUEST {\n  set hostlong 12345678\n  set netlong [htonl $hostlong]\n}","returnValue":""},
{"commandName":"htons","description":"Convert the unsigned short integer from host byte order to network byte\norder.\n\nSyntax\n\nhtons <hostshort>\n\n     * Convert the unsigned short integer from host byte order to network\n       byte order.","examples":"when HTTP_REQUEST {\n  set hostshort 1234\n  set netshort [htons $hostshort]\n}","returnValue":""},
{"commandName":"ntohl","description":"Convert the unsigned integer from network byte order to host byte\norder.\n\nSyntax\n\nntohl <netlong>\n\n     * Convert the unsigned integer from network byte order to host byte\n       order.","examples":"when HTTP_REQUEST{\n  set netlong 12345678\n  set hostlong [ntohl $netlong]\n}","returnValue":""},
{"commandName":"ntohs","description":"Convert the unsigned short integer from network byte order to host byte\norder.\n\nSyntax\n\nntohs <netshort>\n\n     * Convert the unsigned short integer from network byte order to host\n       byte order.","examples":"when HTTP_REQUEST {\n  set netshort 1234\n  set hostshort [ntohs $netshort]\n}","returnValue":""},
{"commandName":"http_cookie","description":"Returns the value in the Cookie: header for the specified cookie\nname. This is a BIG-IP version 4.X variable, provided for\nbackward-compatibility. You can use the equivalent 9.X command\nHTTP::cookie instead\n\nSyntax\n\nhttp_cookie <cookie_name>\n\n     * Specifies the value in the Cookie: header for the specified cookie\n       name.","examples":"","returnValue":""},
{"commandName":"http_header","description":"Evaluates the string following an HTTP header tag that you specify.\nThis command is a BIG-IP version 4.X variable, provided for\nbackward-compatibility. You can use the equivalent 9.X command\nHTTP::header, instead.\n\nSyntax\n\nhttp_header(header_tag_string)\n\n     * Evaluates the string following an HTTP header tag that you specify.","examples":"","returnValue":""},
{"commandName":"http_host","description":"Returns the value in the Host: header of the HTTP request. This is a\nBIG-IP version 4.X variable, provided for backward-compatibility. You\ncan use the equivalent 9.X command HTTP::host instead.\n\nSyntax\n\nhttp_host\n\n     * Specifies the value in the Host: header of the HTTP request.","examples":"","returnValue":""},
{"commandName":"http_method","description":"Returns the action of the HTTP request. Common values are GET and\nPOST. This command is a BIG-IP version 4.X variable, provided for\nbackward-compatibility. You can use the equivalent 9.Xcommand\nHTTP::method instead.\n\nSyntax\n\nhttp_method\n\n     * Specifies the action of the HTTP request. Common values are GET and\n       POST.","examples":"","returnValue":""},
{"commandName":"http_uri","description":"Returns a URL, but does not include the protocol and the fully\nqualified domain name (FQDN). For example, if the URL is\nhttp://www.mysite.com/buy.asp, then the URI is /buy.asp. This command\nis a BIG-IP 4.X variable, provided for backward-compatibility. You can\nuse the equivalent 9.x command HTTP::uri instead.\n\nSyntax\n\nhttp_uri\n\n     * Returns a URI, which is a URL that does not include the protocol\n       and the fully qualified domain name (FQDN).","examples":"","returnValue":""},
{"commandName":"http_version","description":"Returns the HTTP protocol version. Possible values are \"HTTP/1.0\" or\n\"HTTP/1.1\". This is a BIG-IP version 4.X variable, provided for\nbackward compatibility. You can use the equivalent 9.X command,\nHTTP::version instead.\n\nSyntax\n\nhttp_version\n\n     * Returns the HTTP protocol version.","examples":"","returnValue":""},
{"commandName":"ifile","description":"This iRules command returns content and attributes from external files\non the BIG-IP system\n\nSyntax\n\nifile get <iFile Name>\n\n     * returns the contents of the file\n\nifile listall\n\n     * returns a list of all iFiles available\n\nifile attributes <iFile Name>\n\n     * returns all the attributes of an iFile\n\nifile size <iFile Name>\n\n     * returns the size of an iFile\n\nifile last_updated_by <iFile Name>\n\n     * returns the user who last update the iFile on the system\n\nifile last_update_time <iFile Name>\n\n     * returns the date the iFile was last updated\n\nifile revision <iFile Name>\n\n     * returns the current revision of the iFile\n\nifile checksum <iFile Name>\n\n     * returns the checksum of the iFile\n\narray set <variable> [ifile attributes <iFile Name>]\n\n     * stores all the iFile attributes for an iFile in an array","examples":"when RULE_INIT {\n   # Get a list of iFiles\n   # Waiting 10 seconds first to ensure they are fully defined after iFile loading is complete\n   after 10000 {\n      set ifilelist [ifile listall]\n      log local0. \"List of files: $ifilelist\"\n\n      # Print the attributes for the first iFile in the list\n      log local0. \"Attributes for the first file [lindex $ifilelist 0]:\"\n      array set ifile_attributes [ifile attributes [lindex $ifilelist 0]]\n      foreach {array attr} [array get ifile_attributes] {\n         log local0. \"Array $array Attr: $attr\"\n      }\n      unset ifilelist ifile_attributes array attr\n   }\n}\n\nwhen HTTP_REQUEST {\n   # Retrieve the file contents, send it in an HTTP 200 response and clear the temporary variable\n   set ifileContent [ifile get \"/Common/iFile-index.html\"]\n   HTTP::respond 200 content $ifileContent\n   unset ifileContent\n}","returnValue":""},
{"commandName":"imid","description":"Parses the BIG-IP 4.X http_uri variable and the user-agent header field to return an i-mode identifier string that can be used for i-mode session persistence. This is a BIG-IP 4.X function, provided for backward compatibility.\n\nThe imid function takes no arguments and simply returns the string representing the i-mode identifier or the empty string, if none is found.","examples":"","returnValue":"Parses the BIG-IP 4.X http_uri variable and the '''user-agent* header field to return an i-mode identifier string that can be used for i-mode session persistence."},
{"commandName":"ip_protocol","description":"Returns the IP protocol value. This is a BIG-IP 4.X variable, provided\nfor backward-compatibility. You can use the command IP::protocol\ninstead.\n\nSyntax\n\nip_protocol\n\n     * Returns the IP protocol value.","examples":"","returnValue":""},
{"commandName":"ip_tos","description":"Returns the ToS level of a packet. The Type of Service (ToS) standard\nis a means by which network equipment can identify and treat traffic\ndifferently based on an identifier. As traffic enters the site, the\nBIG-IP system can apply a rule that sends the traffic to different\npools of servers based on the ToS level within a packet.\nThis is a BIG-IP version 4.X variable, provided for\nbackward-compatibility. You can use the equivalent 9.X command\nIP::tos instead.\n\nSyntax\n\nip_tos\n\n     * Sends the traffic to a different pool of servers based on the ToS\n       level within a packet.","examples":"","returnValue":""},
{"commandName":"ip_ttl","description":"Synonym for IP::ttl. Returns the TTL of the latest IP packet\nreceived.\n\nSyntax\n\nip_ttl\n\n     * Returns the TTL of the latest IP packet received.","examples":"when CLIENT_ACCEPTED {\n  log local0. \"Client ttl: [ip_ttl]\"\n}","returnValue":""},
{"commandName":"lasthop","description":"Sets the lasthop of a IP connection. The lasthop is the MAC destination\nfor packets going back to the client. This is usually the router\n(gateway) that forwards the client's packets to the BIG-IP (if \"auto\nlasthop\" is set), or is determined by the IP routing table. This\ncommand lets you specify the lasthop to use for a particular\nconnection.\n\nSyntax\n\nlasthop [<vlan>] <IP address>\n\n     * Sets the lasthop to the ethernet address belonging to the specified\n       IP address, optionally on the specified vlan. The IP address must\n       be directly connected to the BIG-IP (no intermediate router).\n\nlasthop <vlan> <ethernet address>\n\n     * Sets the lasthop to the specified ethernet address on the specified\n       vlan.","examples":"when CLIENT_ACCEPTED {\n  lasthop external 01:23:45:ab:cd:ef\n}","returnValue":""},
{"commandName":"link_qos","description":"Returns the QoS level. The Quality of Service (QoS) standard is a means\nby which network equipment can identify and treat traffic differently\nbased on an identifier. As traffic enters the site, the BIG-IP system\ncan apply an iRule that sends the traffic to different pools of servers\nbased on the QoS level within a packet.\nThis is a BIG-IP version 4.X variable, provided for\nbackward-compatibility. You can use the equivalent 9.X command\nLINK::qos instead.\n\nSyntax\n\nlink_qos\n\n     * Returns the QoS level.","examples":"","returnValue":""},
{"commandName":"llookup","description":"This command returns a list of values corresponding to the given key.\nIn case there is no value for thekey or the [mmap] is not a properly\nstructured multimap, the command will return null. Useful for data from\nASM::violation details. This is a safer shortcut for this tcl\ncode:\nThis sets $ to the list of values corresponding to a given key $key in\na multimap $m:\n\nset r { }\nforeach pair [lsearch -inline -all $m [concat $key *] {\n  lappend r [lindex $pair 1]\n}\n\n\nSyntax\n\nllookup <mmap> <key>","examples":"","returnValue":""},
{"commandName":"local_addr","description":"Deprecated: Use IP::local_addr instead","examples":"when CLIENT_ACCEPTED {\n    log local0. \"client ip addr: [local_addr]\"\n}","returnValue":"Returns the IP address being used in the connection. In the clientside context, this is the destination IP address from the client request (not necessarily the virtual IP address). In the serverside context, this is the source IP address (SNAT address if SNAT is used, else spoofed client IP address)."},
{"commandName":"matchclass","description":"Performs comparisons against the contents of data group. Typically used\nfor conditional logic control.\n\nNote: matchclass has been deprecated in v10 in favor of the new\nclass commands. The class command offers better functionality and\nperformance than matchclass.\n\nNote that you should not use a $:: or :: prefix on the datagroup name\nwhen using the matchclass command (or in any datagroup reference on\n9.4.4 or later).\n\nIn v9.4.4 - 10, using $::datagroup_name will work but demote the\nvirtual server from running on all TMMs. For details, see the CMP\ncompatibility page.\n\nIn v11, using $::datagroup_name will result in a TCL runtime error and\nreset being sent to the client!\n\nSyntax\n\nmatchclass <data-group> <operator name> <value>\n\n     * Compares each member of a data group with the specified value.\n       Returns index of match if found, 0 if no match is found.\n\nmatchclass <value> <operator name> <data-group>\n\n     * Compares the specified value with each member of a data group.\n       Returns index of match if found, 0 if no match is found.\n\n   How the match is performed depends on the operator you use with the\n   matchclass command. Consider the following...\n   For the equals operator, either form of the command will produce\n   the same results. Both of the following examples will perform a full\n   string comparison and return the index of the first data group item\n   that is exactly \"green\":\n\n [matchclass my_data_group equals \"green\"]\n [matchclass \"green\" equals my_data_group]\n\n   However, when using a partial comparison operator, such as\n   contains, starts_with or ends_with, the order of\n   comparison does matter. This example will return the index of the first\n   row that has the string \"green\" anywhere in it:\n\n [matchclass my_data_group contains \"green\"]\n\n   And this example will will return the index of the first row containing\n   any of contiguous characters in the string \"green\" (g, r, e, n, gr, re,\n   ee, en, gre, ree, een, gree, reen, and green will all match):\n\n [matchclass \"green\" contains my_data_group]\n\n   Note: For v10 users: Classes (data groups) used to be accessible as a\n   global TCL list. Starting in v10, accessing a data group as a global\n   variable ($::class_name) simply returns the name of the data group and\n   is no longer a TCL list. You should now use the \"class\" command for all\n   data group access as matchclass/findclass have been deprecated in v10.\n\n   Note: The terms Data Group List and Class are synonymous when referring\n   to matchclass. Data Group Lists are hashed tcl lists containing data\n   for comparison with live traffic conditions. They may be created in the\n   admin web interface under Local Traffic/iRules/Data Group Lists. See\n   Examples below.\n\n   Note: The value of the matched item is NOT returned by matchclass. If\n   you need to return a value for a specific match, the findclass command\n   might be what you need. (Link below)","examples":"To redirect any request whose URI starts with any of the listed strings\ndefined in the redirectURIs data group (class), first define the class\n   (Local Traffic >> iRules >> Data Groups). This is how the object\ndefinition appears in the bigip.conf file:\n\nclass redirectURIs {\n  /my/application/directory\n  /another/appdir\n  /yet/another\n}\n\nNow create a rule which references the class:\n\nwhen HTTP_REQUEST {\n  if { [matchclass [HTTP::uri] starts_with redirectURIs] } {\n     HTTP::redirect \"http://www.domain.com/unavailable.html\"\n }\n}\n\nTo send AOL-sourced connections to a specific pool. (Note: Use the\n   \"equals\" operator for address comparison with matchclass):\n\nwhen CLIENT_ACCEPTED {\n  if { [matchclass [IP::remote_addr] equals aol] } {\n     pool aol_pool\n  } else {\n     pool all_pool\n }\n}\n\nUse matchclass with the TCL \"lindex\" command to extract the value of\nthe matched item. (Matchclass index starts at 1, while lindex uses a 0\nbased index, thus the expr {$var - 1} adjustment):\nAs noted above, use the class get command instead of matchclass\nand lindex for this example!\n\nwhen HTTP_REQUEST {\n  set idx [matchclass [HTTP::uri] contains color]\n  if { -1 != $idx } {\n    set val [lindex $::color [expr {$idx - 1}]]\n    log local0. \"Found match index = $idx; value = $val\"\n  } else {\n    log local0. \"Didn't find a match\"\n  }\n}\n\nAs matchclass doesn't support wildcards, you can use a foreach loop to\ngo through the class, element by element. Use string compare as it\nsupports glob style (wildcard) matching:\n\nwhen RULE_INIT {\n   # Create a test class (actually a list in this case).  This could also be defined as a class/datagroup.\nset ::test_class [list abcd abcde abcdef* abcdefg*]\n\n   # Loop through the datagroup line by line.\nforeach element $::test_class {\n\n      # Log the current line.\n      log local0. \"Current \\$element: $element\"\n\n      # Compare the element against the string.\n      # If the datagroup entry has a wildcard, it should be listed first in thestring compare statement.\n      if {[string match -nocase $element \"ABCDEFG\"]}{\n\n         # Found a match, so log it and break out of the foreach loop.\n         log local0. \"Matched \\$element: $element.  Exiting loop.\"\n         break\n      }\n   }\n}","returnValue":""},
{"commandName":"members","description":"This command behaves much like active_members, but counts or lists all\nmembers (IP+port combinations) in a pool, not just active ones.\n\nNote\n\n   When assigning a snatpool to static variable and using \"members -list\"\n   to reference it in RULE_INIT, failures will be observed at startup but\n   won't show up in a reload afterwards. Expected behavior is to fail it\n   in any case as \"members -list\" is not designed to reference a snatpool\n   name.\n\nSyntax\n\nmembers <pool>\n\n     * Returns the number of pool members.\n\nmembers -list <pool>\n\n     * Returns a list of the pool members.","examples":"when HTTP_REQUEST {\n    set response \"<?xml version=\\\"1.0\\\" encoding=\\\"utf-8\\\"?><rss version=\\\"2.0\\\"><channel>\"\n    append response \"<title>BigIP Server Pool Status</title>\"\n    append response \"<description>Server Pool Status</description>\"\n    append response \"<language>en</language>\"\n    append response \"<pubDate>[clock format [clock seconds]]</pubDate>\"\n    append response \"<ttl>60</ttl>\"\n    if { [HTTP::uri] eq \"/status\" } {\n                foreach { selectedpool } [class get pooltest] {\n                        set thispool [getfield $selectedpool \" \" 1]\n                        if {  [catch {\n                                if { [active_members $thispool] < 1 } {\n                                        append response \"<item>\"\n                                        append response \"<title>$thispool status</title>\"\n                                        append response \"<description>$thispoolis <b><font style=\\\"color:red\\\">DOWN</font></b></description>\"\n                                        append response \"</item>\"\n                                } else {\n                                        append response \"<item>\"\n                                        append response \"<title>$thispool status</title>\"\n                                        append response \"<description>$thispoolis <b>UP</b></description>\"\n                                        append response \"</item>\"\n                                        # Member Status Section for \"UP\" pools\"\n                                        append response \"<item><title>$thispoolmember status</title><description><!\\[CDATA\\[\"\n                                        foreach { pmem } [members -list $thispool] {\n                                                append response \"Pool Member [join $pmem \":\"] is [LB::status pool $thispool member [getfield $pmem \" \" 1] [getfield $pmem \" \" 2] ] <br></br>\"\n                                        }\n                                        append response \"\\]\\]></description></item>\"\n                                        # End Member Status Section\n                                }\n                        } errmsg ] } {\n                                append response \"<item>\"\n                                append response \"<title>$thispool ERROR</title>\"\n                                append response \"<description><b><font style=\\\"color:purple\\\">Invalid pool name: $thispool</font></b></description>\"\n                                append response \"</item>\"\n                        }\n                }\n                append response \"</channel>\"\n                append response \"</rss>\"\n                log local0.info \"$response\"\n                HTTP::respond 200 content $response \"Content-Type\" \"text/xml\"\n        }\n}","returnValue":""},
{"commandName":"nexthop","description":"Sets the nexthop of an IP connection. The nexthop is the destination\nfor packets going from the BIG-IP to the server. This is usually\ndetermined by the IP routing table. This command lets you specify the\nnexthop to use for a particular connection.\n\nNote: In 11.6, you can use the 'nexthop' command to direct traffic over\n    IPIP tunnels.  In 13.0, you can use the 'nexthop' command to make\n    connections L2 transparent (preserve source and destination MAC address).\n\n\nSyntax\n\nnexthop [<vlan>] <IP address>\n\n     * Sets the nexthop to the ethernet address belonging to the specified\n       IP address, optionally on the specified vlan. The IP address must\n       be directly connected to the BIG-IP (no intermediate router).\n\nnexthop <vlan> <ethernet address>\n\n     * Sets the nexthop to the specified ethernet address on the specified\n       vlan.\n\nnexthop <tunnel-name> [<IP address>]\n\n     * Sets the nexthop to the specific tunnel interface 'tunnel-name'. If\n       the tunnel interface is a point-to-point tunnel, the IP address is\n       optional, in which the IP address has not effect. If the tunnel\n       interface is a wild-card IPIP tunnel, the IP address specifies the\n       remote IP address.\n\nnexthop <vlan> transparent\n\n     * Sets the transparent nexthop vlan to the specific vlan interface 'vlan'.\n       The flow will be marked as L2 transparent: auto lasthop will be enabled\n       and address translation will be disabled.","examples":"when CLIENT_ACCEPTED {\n  nexthop external 01:23:45:ab:cd:ef\n}\n\n\nnet tunnels tunnel wildcard-ipip-tun {\n    local-address 10.5.0.21\n    profile ipip\n}\nwhen CLIENT_ACCEPTED {\n    nexthop wildcard-ipip-tun 10.4.0.21\n}","returnValue":""},
{"commandName":"nodes","description":"This command behaves like active_nodes but lists all nodes in a pool,\nnot just nodes that are currently active.\n\nSyntax\n\nnodes <pool>\n\n     * Returns the number of pool nodes.\n\nnodes -list <pool>\n\n     * Returns a list of the pool nodes.","examples":"#!/bin/bash\necho \"Active:Total members for $1: `curl -s http://172.18.201.234/pool/<partition>/$1`\"\n\n\nwhen HTTP_REQUEST {\n        set in_path [HTTP::path]\n        log local0. \"debug request: path $in_path\"\n        switch -glob $in_path {\n                \"/pool*\" {\n                        set pool [string map {\"/pool\" \"\"} $in_path]\n                        HTTP::respond 200 content \"[active_members $pool]:[nodes $pool]\"\n                }\n        }\n}","returnValue":""},
{"commandName":"priority","description":"The priority command is used as an attribute associated with any iRule\nevent. When the iRules are loaded into the internal iRules engine for a\ngiven virtual server, they are stored in a table with the event name\nand a priority (with a default of 500).\nLower numbered priority events are evaluated before higher numbered\npriority events: When an event is triggered an event, the irules engine\npasses control to each of the code blocks for that given event in the\norder of lowest to highest priority. Multiple events with the same\npriority will be executed in the order they are inserted into the\ntable.\nThe valid values for the priority are 0 to 1000 inclusive.\nYou can assign a priority between 1 and 1000 in one of two ways: either\nwith the priority command at the outermost scope of a rule, in which\ncase the designated priority is used for all subsequent events; or as\nan additional argument to the when command, in which the priority is\nonly used for that event.\n\nSyntax\n\npriority nnn\n\n    * priority for all subsequent events\n\nwhen <event_name> priority nnn\n\n     * priority for a particular event declaration.\n\n     The value of nnn can be 0 to 1000 inclusive.","examples":"In this example, the first event is assigned priority 700 and both\nsubsequent events are assigned priority 400. The second events will be\nevaluated before the other rules with a priority > 400.\n\n rule my_test_rule {\n    priority 700\n    when HTTP_REQUEST {\n       HTTP::header insert ORIG_CLIENT_IP [IP::remote_addr]\n    }\n    priority 400\n    when CLIENT_ACCEPTED {\n       log \"Client [IP::remote_addr] connected\"\n    }\n    when HTTP_REQUEST {\n       log \"Requested URI: [HTTP::host][HTTP::uri]\"\n    }\n }\n\nIn this example, one event is assigned priority 700, another is\ndefaulted to 500 and the third is 400:\n\n rule my_test_rule {\n    when HTTP_REQUEST priority 700 {\n       HTTP::header insert ORIG_CLIENT_IP [IP::remote_addr]\n    }\n    when CLIENT_ACCEPTED priority 400 {\n       log \"Client [IP::remote_addr] connected\"\n    }\n    when HTTP_REQUEST {\n       log \"Requested URI: [HTTP::host][HTTP::uri]\"\n    }\n }","returnValue":""},
{"commandName":"proc","description":"Define an iRule proc which is called by iRule command call.\n\nThe syntax is same as basic TCL proc command.","examples":"proc logme msg {\n    log local0. $msg\n}\n\nwhen CLIENT_ACCEPTED {\n    call logme \"Coming to CLIENT_ACCEPTED\"\n}\n\nwhen CLIENT_DATA {\n    call logme \"Coming to CLIENT_DATA\"\n}","returnValue":"Returns the value in the return command, if any, in the proc script."},
{"commandName":"rateclass","description":"Causes the system to select the specified rate class to use when\ntransmitting packets.\n\nSyntax\n\nrateclass <rateclass_name>\n\n     * Causes the system to select the specified rate class to use when\n       transmitting packets.","examples":"when CLIENT_ACCEPTED {\n  if { [IP::addr [IP::client_addr] equals xxx.xxx.xxx.xxx] } {\n    log local0. \"[IP::client_addr] being handled by rateclass class1\"\n    rateclass class1\n  }\n}","returnValue":""},
{"commandName":"redirect","description":"Redirects an HTTP request to a specific location. The location can be\neither a host name or a URI. This is a BIG-IP 4.X statement, provided\nfor backward compatibility. You can use the equivalent 9.X command\nHTTP::redirect instead.\n\nSyntax\n\nredirect to [<host_name> | <URI>]\n\n     * Redirects an HTTP request to a specific location.","examples":"when HTTP_REQUEST {\n    # HTTP::redirect, HTTP::host and HTTP::uri should be used instead\n    redirect to \"https://[http_host][http_uri]\"\n}","returnValue":""},
{"commandName":"reject","description":"Causes the connection to be rejected, returning a reset as appropriate\nfor the protocol. Subsequent code in the current event in the current\niRule or other iRules on the VS are still executed prior to the reset\nbeing sent.\nIf the VS is using FastHTTP, reject commands will not work, at least\nunder 11.3.0.\nSyntax\n\nreject\n\n     * Causes the connection to be rejected, returning a reset as\n       appropriate for the protocol. In the case of TCP, the client will\n       receive a TCP segment with the RST bit set. In the case of UDP, an\n       ICMP unreachable message will be generated.\n     * The system connection table entry associated with the flow is also\n       removed.\n     * Subsequent code in the current event is still executed prior to the\n       reset being sent. If there are other iRules with the same event,\n       those event(s) will also be executed. See the second example below\n       for details.","examples":"when CLIENT_ACCEPTED {\n  if { [TCP::local_port] != 443 }{\n    reject\n  }\n}\n\nExample showing how code in a second iRule in the same event will still execute after reject is called\n\n# Rule 1 on VS1\nwhen HTTP_REQUEST priority 100 {\n   # This event in this iRule runs first\n   reject\n   log local0. \"Rejecting this request\"\n}\n# Rule 2 on VS1\nwhen HTTP_REQUEST priority 200 {\n   # This event in this iRule runs second\n   log local0. \"This will still execute\"\n}\n\nExample showing how code in a second iRule in the same event can be prevented from executing after reject is called\n# Rule 1 on VS1\nwhen HTTP_REQUEST priority 100 {\n   # This event in this iRule runs first\n   reject\n   log local0. \"rejected\"\n\n   # Disable future events in this or any other iRule on the virtual server\n   event disable all\n\n   # Exit this event of this iRule immediately\n   return\n\n   # This never gets executed\n   log local0. \"not hit\"\n}\n\n# Rule 2 on VS1\nwhen HTTP_REQUEST priority 200 {\n   # This event in this iRule runs second but won't be executed\n   log local0. \"This will still execute\"\n}","returnValue":""},
{"commandName":"relate_client","description":"Sets up a related established connection. This can be used with protocols that parse information out of a control connection and then establish a data connection based on information that was exchanged in the control connection.","examples":"when SIP_REQUEST {\n    # Taken from https://devcentral.f5.com/wiki/irules.Load-Balance-Outbound-SIP-Voice-Traffic-Signaling-AND-Media-with-SNAT.ashx\n    # Pre-establish the UDP connection to allow RTP from Server -> Client (and vice versa)\n    relate_client {\n        proto 17\n        clientflow $source_VLAN $destination_RTP $destination_RTP_port $source_inside $source_RTP_port\n        serverflow $destination_VLAN $source_outside $source_RTP_port $destination_RTP $destination_RTP_port\n    }\n}","returnValue":""},
{"commandName":"relate_server","description":"Sets up a related established connection. This can be used with protocols that parse information out of a control connection and then establish a data connection based on information that was exchanged in the control connection.","examples":"when SIP_RESPONSE {\n    # Taken from https://devcentral.f5.com/wiki/irules.Load-Balance-Outbound-SIP-Voice-Traffic-Signaling-AND-Media-with-SNAT.ashx\n    # Pre-establish the UDP connection to allow RTP from Server -> Client (and vice versa)\n    relate_server {\n        proto 17\n        clientflow $source_VLAN $destination_RTP $destination_RTP_port $source_inside $source_RTP_port\n        serverflow $destination_VLAN $source_outside $source_RTP_port $destination_RTP $destination_RTP_port\n    }\n}","returnValue":""},
{"commandName":"remote_addr","description":"Returns the IP address of the host on the far end of the connection. In the clientside context, this is the client IP address. In the serverside context this is the node IP address. You can also specify the IP::client_addr and IP::server_addr commands, respectively.\n\nIn BIG-IP 10.x with route domains enabled this command returns the remote IP address in the x.x.x.x%rd of the server or client (depending on the context) that is in any non-default route domain else it returns just the IP address as expected.\n\nThis command is equivalent to the BIG-IP 4.X variable remote_addr.","examples":"when CLIENT_ACCEPTED {\n    if { [IP::addr [IP::remote_addr] equals 206.0.0.0 mask 255.0.0.0] } {\n        pool clients_from_206\n    } else {\n        pool other_clients_pool\n    }\n}","returnValue":"Returns the IP address of the host on the far end of the connection."},
{"commandName":"rmd160","description":"Returns the RIPEMD-160 (RACE Integrity Primitives Evaluation Message Digest) message digest of the specified string, or an empty string if an error occurs. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [rmd160 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"rmd160 <string>\n    Returns the RIPEMD-160 message digest of the specified string, or an empty string if an error occurs."},
{"commandName":"server_addr","description":"Returns the IP address of the server. This is a BIG-IP version 4.X\nvariable, provided for backward compatibility. You can use the\nequivalent 9.X command IP::server_addr instead.\n\nSyntax\n\nserver_addr\n\n     * Returns the IP address of the server.","examples":"","returnValue":""},
{"commandName":"server_port","description":"Returns the TCP port/service number of the specified server. This is a\nBIG-IP version 4.X variable, provided for backward compatibility. You\ncan use the equivalent 9.X command TCP::server_port instead.\n\nSyntax\n\nserver_port\n\n     * Returns the TCP port/service number of the specified server.","examples":"","returnValue":""},
{"commandName":"session","description":"Utilizes the persistence table to store arbitrary information based on\nthe same keys as persistence. This information does not affect the\npersistence itself.\n\nSyntax\n\n   Note: items marked with <item> are meant to be replaced with a value.\n   Arguments bracketed by [] are used to note they are optional. They\n   should not be confused with Tcl command evaluation.\n\n   <mode> = simple | source_addr | sticky | dest_addr | ssl | uie | hash | sip\n\n   <key> = <mode specific value> | { <value> [any virtual | service | pool] [pool <name>] }\n     the latter key specification is used to delete persistence entries regardless of virtual, service, or pool association.\n\n   <timeout> = The timeout in seconds. Defaults to 180 seconds.  If the session key is touched (updated or looked up), the timeout counter starts over again.\n\nsession add <mode> <key> <data> [<timeout>]\n\n     * Stores user's data under the specified key for the specified\n       persistence mode\n\nsession lookup <mode> <key>\n\n     * Returns user data previously stored using session add. If the\n       lookup key is a null string, a runtime TCL error will be triggered\n       and the connection will be reset. So it is a best practice to\n       explicitly check for a null key before attempting a session lookup.\n\nsession delete <mode> <key>\n\n     * Removes user data previously stored using session add\n\n   When using the latter key specification above (e.g. = { any virtual }),\n   the session command expects the key (the data and associated \"any\n   virtual\" commands) to be a single argument; in other words, a list.\n   Often, users will want to specify some variable data in such a command.\n   However, the usual way of creating a list (via braces, as shown above)\n   will inhibit variable and command expansion. See https://devcentral.f5.com/articles/irules-optimization-101-04-delimiters-braces-brackets-quotes-and-more for more information on this.\n   To use variables and commands with these key specifications, users should\n   either use the list command to construct a list, or use double quotes,\n   which Tcl will interpret as a list. See the last two examples below.\n\n   Note: Starting in BIG-IP version 10, the session table is a simple,\n   global key/value table. Although the syntax is the same (for\n   compatibility with existing iRules), the specifier is ignored in\n   version 10, as are the any virtual and related specifiers.","examples":"Saves client cert in session table after handshake for retrieval during\nsubsequent requests:\n\nwhen CLIENTSSL_CLIENTCERT {\n  # Set results in the session so they are available to other events\n  set ssl_cert [SSL::cert 0]\n  session add ssl [SSL::sessionid] $ssl_cert 180\n}\nwhen HTTP_REQUEST {\n  # Retrieve certificate information from the session\n  set ssl_cert [session lookup ssl [SSL::sessionid]]\n}\n\nwhen HTTP_REQUEST {\nset lookup [list [IP::client_addr] any virtual]\nset value [session lookup uie $lookup]\n}\n\n\nwhen HTTP_REQUEST {\nset value [session lookup uie \"[IP::client_addr] any pool\"]\n}\n\n\nwhen HTTP_REQUEST {\nset value [session lookup uie [list $myVar any virtual]]\n}","returnValue":""},
{"commandName":"sha1","description":"Returns the Secure Hash Algorithm version 1.0 (SHA1) message digest of the specified string, or if an error occurs, an empty string. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [sha1 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"sha1 <string>\n    Returns the Secure Hash Algorithm version 1.0 (SHA1) message digest of the specified string, or if an error occurs, an empty string."},
{"commandName":"sha256","description":"Returns the Secure Hash Algorithm (SHA2) 256-bit message digest of the specified string. If an error occurs, an empty string is returned. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [sha256 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"sha256 <string>\n    Returns the Secure Hash Algorithm version 2.0 (SHA2) message digest of the specified string using 256 bit digest length. If an error occurs, an empty string is returned."},
{"commandName":"sha384","description":"Returns the Secure Hash Algorithm (SHA2) 384-bit message digest of the specified string. If an error occurs, an empty string is returned. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [sha384 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"sha384 <string>\n    Returns the Secure Hash Algorithm version 2.0 (SHA2) message digest of the specified string using 384 bit digest length. If an error occurs, an empty string is returned."},
{"commandName":"sha512","description":"Returns the Secure Hash Algorithm (SHA2) 512-bit message digest of the specified string. If an error occurs, an empty string is returned. Used to ensure data integrity.","examples":"when HTTP_REQUEST {\n    binary scan [sha512 [HTTP::host]] w1 key\n\n    set key [expr {$key & 1}]\n    switch $key {\n        0 { pool my_pool member 1.2.3.4:80 }\n        1 { pool my_pool member 5.6.7.8:80 }\n    }\n}","returnValue":"sha512 <string>\n    Returns the Secure Hash Algorithm version 2.0 (SHA2) message digest of the specified string using 512 bit digest length. If an error occurs, an empty string is returned."},
{"commandName":"sharedvar","description":"Allows a variable to be accessed in both sides of a VIP-targetting-VIP\n\nSyntax\n\nsharedvar <variable name>\n\n     * Shares a variable between both connections when a VIP targets\n       another VIP. Note that both virtuals must declare the variable as\n       shared for the data to be shared.","examples":"Virtual vip1:\n\nwhen HTTP_REQUEST {\nsharedvar public\nset private \"data for vip1 only\"\nset public \"data for vip1 and vip2\"\nvirtual vip2\n}\nwhen HTTP_RESPONSE {\nlog local0. \"vip1 @ response: private: $private\"\nlog local0. \"vip1 @ response: public: $public\"\n}\n\nVirtual vip2:\n\nwhen HTTP_REQUEST {\nsharedvar public\nif { [info exists private] } {\n     log local0. \"vip2 @ request: private: $private\"\n   } else {\n     log local0. \"vip2 @ request: private does not exist\"\n   }\nif { [info exists public] } {\n     log local0. \"vip2 @ request: public: $public\"\n   } else {\n     log local0. \"vip2 @ request: public does not exist\"\n   }\n}\nwhen HTTP_RESPONSE {\nset private \"vip2 private data\"\nset public \"vip2 public data\"\nlog local0. \"vip2 @ response: private: $private\"\nlog local0. \"vip2 @ response: public: $public\"\n}\n\nAn HTTP request to VIP1 will log:\n\n Rule share2 <HTTP_REQUEST>: vip2 @ request: private does not exist\n Rule share2 <HTTP_REQUEST>: vip2 @ request: public: data for vip1 and vip2\n Rule share2 <HTTP_RESPONSE>: vip2 @ response: private: vip2 private data\n Rule share2 <HTTP_RESPONSE>: vip2 @ response: public: vip2 public data\n Rule share1 <HTTP_RESPONSE>: vip1 @ response: private: data for vip1 only\n Rule share1 <HTTP_RESPONSE>: vip1 @ response: public: vip2 public data","returnValue":""},
{"commandName":"snatpool","description":"Causes the pool of addresses identified by <snatpool_name> to be used\nas translation addresses to create a SNAT.\n\nSyntax\n\nsnatpool <snatpool_name>\n\n     * Causes the pool of addresses identified by <snatpool_name> to be\n       used as translation addresses to create a SNAT.\n\nsnatpool <snatpool_name> member <IP address>\n\n     * Causes the a particular member of the pool of addresses identified\n       by <snatpool_name> to be used as translation addresses to create a\n       SNAT.","examples":"when CLIENT_ACCEPTED {\n  if { [TCP::local_port] == 531 } {\n     snatpool chat_snatpool\n}\n  elseif { [TCP::local_port] == 25 } {\n     snatpool smtp_snatpool member 10.20.30.40\n }\n}","returnValue":""},
{"commandName":"substr","description":"A custom iRule function which returns a substring named <string>,\nbased on the values of the <skip_count> and <terminator> arguments.\nNote the following:\n  * The <skip_count> and <terminator> arguments are used in the same\n    way as they are for the findstr command.\n  * The <skip_count> argument is the index into <string> of the first\n    character to be returned, where 0 indicates the first character of\n    <string>.\n  * The <terminator> argument can be either the subtring length or the\n    substring terminating string.\n  * If <terminator> is an integer, the returned string will include\n    that many characters, or up to the end of the string, whichever is\n    shorter.\n  * If <terminator> is a string, the returned string will include\n    characters up to but not including the first occurence of the\n    string.\n  * If <terminator> is a string which does not occur in the search\n    space, from <skip_count> to the end of <string> is returned.\n  * This command is equivalent to the Tcl string range command except\n    that the value of the <terminator> argument may be either a\n    character or a count.\n\n\nSyntax\n\nsubstr <string> <skip_count> [<terminator>]\n\n     * Returns a sub-string from <string>, based on the values of\n       the'<skip_count> and <terminator>* arguments.","examples":"when HTTP_REQUEST {\n  set uri [substr $uri 1 \"?\"]\n  log local0. \"Uri Part = $uri\"\n}\n\n\n  log \"[substr \"abcdefghijklm\" 2 \"x\"]\"\n  log \"[substr \"abcdefghijklm\" 2 \"gh\"]\"\n  log \"[substr \"abcdefghijklm\" 2 4]\"\n  log \"[substr \"abcdefghijklm\" 2 20]\"\n  log \"[substr \"abcdefghijklm\" 2 0]\"\n\nThe above example logs the following:\n\n  cdefghijklm\n  cdef\n  cdef\n  cdefghijklm\n  cdefghijklm","returnValue":""},
{},
{"commandName":"timing","description":"The timing command can be used to enable iRule timing statistics. This\nwill then collect timing information as specified each time the rule is\nevaluated. Statistics may be viewed with \"b rule show all\" or in the\nStatistics tab of the iRules Editor.\n\nNote: In 11.5.0, timing was enabled by default for all iRules in\nBZ375905. The performance impact is negligible. As a result, you no\nlonger need to use this command to view timing statistics.\n\nYou'll likely only want to look at the average and min numbers as max\nis often way, way out there due to the optimizations being performed on\nthe first run of the rule. By \"optimizations\" we mean that TMM is doing\nits normal data inspection/collection routine which is performed for\neach new connection. This process allows you to use the streamlined,\ncached values later in your iRules, such as HTTP::host and\nIP::local_addr. This process is more resource intensive than a normal\npass through the iRule and as such will offset the \"max\" statistics,\nhence the need to throw out this number when scoping your iRule usage.\n\nEnabling timing does have negligible overhead so you shouldn't need to\nworry about leaving it enabled.\n\nSyntax\n\ntiming <on |off>\n\n     * When the timing command is issued before a \"when EVENT_NAME\"\n       declaration in an iRule, timing is enabled or disabled for the\n       remainder of the iRule.\n\nwhen EVENT_NAME timing <on |off> { <iRule code> }\n\n     * Use the timing command after the \"when EVENT_NAME\" and before its\n       braces to enable or disable timing only for that specified event.","examples":"To enable timing for the entire rule:\n\ntiming on\nwhen RULE_INIT {\n  log local0. \"Rule initialized with timing enabled.\"\n}\nwhen HTTP_REQUEST {\n  pool my_pool\n}\n\nTo enable timing for just one event:\n\nwhen RULE_INIT {\n  log local0. \"Rule initialized -- timing not enabled.\"\n}\nwhen HTTP_REQUEST timing on {\n  log local0. \"This event only is being timed\"\n  pool my_pool\n}\n\nTo enable, selectively disable, then disable timing:\n\nrule foo {\n  timing on\n  when HTTP_REQUEST {\n    ...\n  }\n  when CLIENT_ACCEPTED timing off {\n    ...\n  }\n  timing off\n  when SERVER_CONNECTED {\n    ...\n  }\n}","returnValue":""},
{"commandName":"traffic_group","description":"This command returns the current traffic group. Useful for\ntroubleshooting the partitioning of data in the session table.\n\nSyntax\n\ntraffic_group","examples":"when RULE_INIT {\n  log local0. \"traffic_group name: [traffic_group]\"\n}\nwhen CLIENT_ACCEPTED {\n  log local0. \"traffic_group name: [traffic_group]\"\n}","returnValue":""},
{"commandName":"translate","description":"Enables, disables, or queries (as specified) destination address or\nport translation\n\nSyntax\n\ntranslate address|port|service [enable|disable]\n\n     * Enables, disables, or queries (as specified) destination address or\n       port translation\n\n   Note: port and service are synonyms and have an identical effect.","examples":"when CLIENT_ACCEPTED {\n    if { [IP::addr [IP::remote_addr] equals 10.0.8.0/24] } {\n        translate address disable\n    }\n}","returnValue":""},
{"commandName":"urlcatquery","description":"This command is similar in functionality to whereis command of geoip.\nThis will be available from HTTP_REQUEST irule event. It takes the URL\nas the input. The input could be a URL string or an IPV4 address. IPV6\naddresses are not currently supported. iRule returns the URL categories\nreturned by the urlcat library.\n\nSyntax\n\n\nurlcatquery INPUT_URL\n\n     * Query the URL for URL categorization","examples":"when HTTP_REQUEST {\n    set input_url [HTTP::host][HTTP::uri]\n    set urlcat [urlcatquery  $input_url]\n    log local0. \"INPUT-URL: $input_url\"\n    log local0. \"Category - $urlcat\"\n    CLASSIFY::urlcat add $urlcat\n}","returnValue":""},
{"commandName":"use","description":"This is a BIG-IP 4.X statement, provided for backward-compatibility. The use statement must be paired with certain BIG-IP 9.X commands such as node, pool, rateclass, snat, and snatpool.\n\nThe use command is not required on BIG-IP 9.X systems.","examples":"when HTTP_REQUEST {\n    if { [HTTP::uri] contains \"aol\" } {\n        use pool aol_pool\n    } else {\n        use pool all_pool\n    }\n}","returnValue":""},
{"commandName":"when","description":"Used to specify an event in an iRule. All BIG-IP 9.X iRules begin with a when command. You can specify multiple when commands within a single iRule.\n\ntiming and priority are optional parameters which can enable|disable timing and set the priority for the declared event.","examples":"when CLIENT_ACCEPTED {\n    if { [IP::addr [IP::client_addr] equals 10.10.10.10] } {\n        pool my_pool\n    }\n}","returnValue":""},
{"commandName":"whereis","description":"Returns the geographic location of a specific IP address.\nFor more information on using whereis in LTM, you can check Jason\nRahm's article\n\nLegal usage notes\n\n   The data is purchased by F5 for use on BIG-IP systems and products for\n   traffic management. The key to understanding EULA compliance is to\n   figure out where the geolocation decision is being made. It is a direct\n   violation of the EULA to use F5’s data to embed geolocation information\n   or codes representing geolocation information into the requests such\n   that another application or server could make the decision on what to\n   do with that data. Customers wishing to use geolocation data on their\n   webservers or in their applications to make decisions in those products\n   should reach out to their account team. F5’s traffic management\n   products have a lot of power and flexibility and can make lots of\n   decisions about traffic using the geolocation data on the BIG-IP. For\n   example, a geolocation lookup can be used to route traffic requests to\n   a different site, different server, different URL, or even substitute a\n   different image, object, etc in the stream. The key is that the BIG-IP\n   is making use of the data to make a decision to take some action. These\n   are all allowed and in fact, intended usage of the geolocation data.\n   Passing the data looked up to another system or displaying it back\n   publicly is a violation of the basic data EULA. To summarize, all usage\n   of the data must remain local to the system with the following two\n   exceptions:\n     * Location can be placed in an encrypted cookie for reference ONLY by\n       other BIG-IP devices\n     * Logging data can contain location info and collected into a central\n       logging solution for analysis of F5 logs.\n\n   Note that you can get a waiver of the EULA from F5. In the near future,\n   F5 expects to have expanded data sets available with less restrictions\n   on the use cases. If you’re unsure, run your use case by your sales\n   engineer.\n\nSyntax\n\n   As of 10.1.0, the maximum length of the returned list is 8 fields. If\n   more than 8 fields are needed, call whereis a second time with the\n   remaining parameters.\n\n   Note: In GTM, prior to version 10, even when the country and continent\n   keywords are specified the list of {Continent Country} is still\n   returned. In earlier versions just use whereis and lindex to extract\n   the appropriate field for your use case. An example is provided below.\n\n   Note: In GTM, as of version 11.0, the ldns option can be used instead\n   of an IP address.\n\n   Note: Prior to version 10.1, only \"country\" and \"continent\" parameters\n   are valid.\n\nwhereis <ip> [country | continent | state | abbrev | city | zip | area_code |\n   latitude | longitude | isp | org | country_cf | state_cf | city_cf | proxy_type]+\n\nwhereis <ip>\n\n     * In GTM, returns a Tcl list containing continent followed by country\n       code. In LTM, returns a Tcl list containing continent, country\n       code, region name (if available), and city (if available).\n       GTM: {Asia JP}\n       LTM: {NA US Washington {}}\n\nwhereis <ip> country\n\n     * Returns a string containing the two-letter country code (JP)\n     * Country codes are defined in ISO-3166:\n     * Country Decoding Table\n\nwhereis <ip> continent\n\n     * Returns a string containing the continent (Asia)\n\nwhereis <ip> state\n\n     * Returns a string containing the state (Washington)\n\nwhereis <ip> abbrev\n\n     * Returns a string containing the state abbreviation (WA)\n\nwhereis <ip> city\n\n     * Returns a string containing the city\n\nwhereis <ip> zip\n\n     * Returns a string containing the zip code\n\nwhereis <ip> area_code\n\n     * Returns a string containing the area code\n\nwhereis <ip> latitude\n\n     * Returns a string (not a floating point) containing the latitude. To\n       convert to degrees, divide the string by 10000. (the decimal is\n       significant)\n\nwhereis <ip> longitude\n\n     * Returns a string (not a floating point) containing the longitude.\n       To convert to degrees, divide the string by 10000. (the decimal is\n       significant)\n\nwhereis <ip> isp\n\n     * Returns a string containing the ISP\n\nwhereis <ip> org\n\n     * Returns a string containing the organization\n\nwhereis <ip> country_cf\n\nwhereis <ip> state_cf\n\nwhereis <ip> city_cf\n\nwhereis <ip> proxy_type\n\n     * Returns a string containing the proxy type, or \"unknown\" if no\n       information is available.\n\nwhereis <ip> continent country state\n\n     * Returns a list containing the continent, country and state in that\n       order.\n\nwhereis <ip> continent ISP state latitude\n\n     * Returns a string continent, ISP, state and latitude, in that order.\n\n   Note: Any combination or order of place parameters is valid, however\n   only 8 values will be returned at once. Note: Some or all of these data\n   may not be available for a given IP address. Unless otherwise\n   specified, in such an event an empty string is returned for a string\n   value, or a zero is returned for a numeric value. Note: Some of these\n   data are not available unless a geographic IP database has been loaded\n   onto your system. Please contact F5 Networks to obtain this database.","examples":"","returnValue":""},
{"commandName":"AAA::acct_result","description":"This command is used to check whether the accounting information is sent successfully to IVS(internal virtual server) or not.","examples":"when HTTP_REQUEST_DATA {\n    set aaa_result [AAA::acct_result $request_id]\n    if { $aaa_result == \"INPROGRESS\"  } {\n        after 200\n        continue\n    }\n\n    if { $aaa_result == \"OK\" } {\n        # request was successfull\n    } else {\n        # handle errors\n    }\n}","returnValue":"There are 4 possible return values for this command (All STRING type):\n    \"OK\"            - the request was successful.\n    \"FAIL\"          - the request has been rejected.\n    \"INPROGRESS\"    - the request is still in progress (asyncronous).\n    \"ERROR\"         - there was an error during the request."},
{"commandName":"AAA::acct_send","description":"This command is used to send user accouting information to IVS(internal virtual server). The accounting information can be identified by one or more of the following attributes:\n    - user-name\n    - framed-ip-address\n    - framed-ipv6-prefix\n    - event-timestamp\n    - acct-status-type\n    - acct-session-id\n    - acct-input-octets\n    - acct-output-octets\n    - 3gpp-imsi\n    - 3gpp-imeisv\n    - 3gpp-user-location-info\n\nSyntax:\n    AAA::acct_send <ivs-name> [user-name <string>] [framed-ip-address <ipv4 address>] [framed-ipv6-prefix <ipv6 address>] [event-timestamp <integer>] [acct-status-type <integer>] [acct-session-id <string>] [acct-input-octets <64-bit integer>] [acct-output-octets <64-bit integer>] [3gpp-imsi <string>] [3gpp-imeisv <string>] [3gpp-user-location-info <string>]","examples":"when HTTP_REQUEST_DATA {\n    set request_id [AAA::acct_send $internal_radius_aaa_vip user-name $username\n                                                            framed-ip-address $framed-ip\n                                                            acct-status-type 1]\n\n    set aaa_result [AAA::acct_result $request_id]\n    if { $aaa_result == \"OK\" } {\n        # request was successfull\n    } else {\n        # handle errors\n    }\n}","returnValue":"request_id  - the id of the current connection that can be used to check the status later with AAA::acct_result command"},
{"commandName":"AAA::auth_result","description":"This command is used to check the result of an authentication request. It can be used to determine whether the user was successfully authenticated, or if the authentication failed or if the system encountered an error.","examples":"when HTTP_REQUEST_DATA {\n    set aaa_result [AAA::auth_result $request_id]\n    if { $aaa_result == \"INPROGRESS\" } {\n        after 200\n        continue\n    }\n\n    if { $aaa_result == \"OK\" } {\n        # request was successfull\n    } else {\n        # handle errors\n    }\n}","returnValue":"There are 4 possible return values for this command (All STRING type):\n    \"OK\"            - User was successfully authenticated\n    \"FAIL\"          - Authentication failed\n    \"INPROGRESS\"    - the request is still in progress (asyncronous).\n    \"ERROR\"         - there was an error during the request."},
{"commandName":"AAA::auth_send","description":"This command is used to send user authentication information to IVS(internal virtual server).","examples":"when HTTP_REQUEST_DATA {\n    set request_id [AAA::auth_send $internal_radius_aaa_vip $username $password]\n\n    set aaa_result [AAA::auth_result $request_id]\n    if { $aaa_result == \"OK\" } {\n        # request was successfull\n    } else {\n        # handle errors\n    }\n}","returnValue":"request_id  - the id of the current connection that can be used to check the status later with AAA::auth_result command"},
{"commandName":"ACCESS::log","description":"ACCESS::log [component.][loglevel] <message>\n\nLogs the specified message using the optionally specified APM component name\nand log level as specified in the log setting for the access profile that is\nassigned to the virtual server.\nThe message is sent to the destination specified in the log setting.\nIf component is specified, it must be one of the supported values (see below)\nand must end with a dot character. If not specified, the accesscontrol component\nis assumed.\nIf log level is specified, it must be one of the supported values (see below).\nIf not specified, notice level is assumed.\nIf there is no access profile assigned on the virtual server, then\ndefault-log-setting is used.\nRequires APM to be provisioned.\n\nList of supported values for <component> and corresponding Log Setting:\n    <component>         | Log Setting\n    --------------------------------------\n    accesscontrol       | Access Policy\n    accessperrequest    | Per-Request Policy\n    apmacl              | ACL\n    eca                 | ECA\n    mdm                 | Endpoint Management System\n    oauth               | OAuth\n    paa                 | PingAccess\n    sso                 | SSO\n    swg                 | Secure Web Gateway\n    vdi                 | VDI\n\nList of supported values for <loglevel> and their descriptions:\n    <loglevel>      | description\n    -----------------------------\n    emerg           | Emergency\n    alert           | Alert\n    crit            | Critical\n    error           | Error\n    warn            | Warning\n    notice          | Notice\n    info            | Informational\n    debug           | Debug\n\nCommand Syntax\n\nACCESS::log <component>.<loglevel> <message>\n\n\n    * Logs the specified message using specified component and log level.\n      The message is logged, however, according to log setting configuration.\n      If a given log level does not match the log level specified in the log setting,\n      the message is not logged.\n      The command uses the log setting of the access profile if one is assigned\n      to the virtual server that runs the command, otherwise default-log-setting is used.\n\nACCESS::log <component>. <message>\n\n    * Logs the specified message using specified component and default log level (notice).\n      The message is logged, however, according to log setting configuration.\n      If a given log level does not match the log level specified in the log setting,\n      the message is not logged.\n      The command uses the log setting of the access profile if one is assigned\n      to the virtual server that runs the command, otherwise default-log-setting is used.\n\nACCESS::log <loglevel> <message>\n\n    * Logs the specified message using default component (accesscontrol) and the specified log level.\n      The message is logged, however, according to log setting configuration.\n      If a given log level does not match the log level specified in the log setting,\n      the message is not logged.\n      The command uses the log setting of the access profile if one is assigned\n      to the virtual server that runs the command, otherwise default-log-setting is used.\n\nACCESS::log <message>\n\n    * Logs the specified message using default component (accesscontrol) and default log level (notice).\n      The message is logged, however, according to log setting configuration.\n      If a given log level does not match the log level specified in the log setting,\n      the message is not logged.\n      The command uses the log setting of the access profile if one is assigned\n      to the virtual server that runs the command, otherwise default-log-setting is used.","examples":"when HTTP_REQUEST {\n    ACCESS::log debug \"an Access Control debug log\"\n    ACCESS::log sso.error \"an SSO error log\"\n    ACCESS::log eca. \"an ECA notice log\"\n    ACCESS::log \"an Access Control notice log\"\n}","returnValue":""},
{"commandName":"ACCESS::acl","description":"The ACCESS::acl commands allow you to poll, query or enforce ACLs for a\ngiven connection.\n\n\nACCESS::acl result\n\n     * Returns the result of ACL match for a particular URI in\n       ACCESS_ACL_ALLOWED and ACCESS_ACL_DENIED events.\n     * This result can have one of the following values\n     * - Allow\n     * - Reject\n\nACCESS::acl lookup\n\n     * Returns the name of all the assigned ACLs for a particular session.\n\nACCESS::acl eval $acl_name\n\n     * Allows admin to enforce an ACL to a user request from iRule. Using\n       this command, admin can specify extra ACL to be enforced to user's\n       request.\n\nACCESS::acl matched\n\n    Returns the name of the ACL that was matched.\n\n * Requires APM module","examples":"when ACCESS_ACL_ALLOWED {\n      ACCESS::acl eval \"additional_acl\"\n}","returnValue":""},
{"commandName":"ACCESS::disable","description":"This command disables the access control enforcement for a particular\nrequest URI. The request is passed through access control module\nwithout any access control checks (excludes valid session check as well\nas policy allowed check).\n\n\nACCESS::disable\n\n     * Disable the access control enforcement for a particular request\n       URI.\n\n\n * Requires APM module","examples":"when HTTP_REQUEST {\n\n       # Check the requested HTTP path\n       switch -glob [string tolower [HTTP::path]] {\n              \"/apm_uri1*\" -\n              \"/apm_uri2*\" -\n              \"/apm_uri3*\" {\n                     # Enable APM for these paths\n                     ACCESS::enable\n              }\n              default {\n                     # Disable APM for all other paths\n                     ACCESS::disable\n              }\n       }\n}","returnValue":""},
{"commandName":"ACCESS::enable","description":"This command enables the access control enforcement for a particular\nrequest URI.\n\n\nACCESS::enable\n\n     * Enables the access control enforcement for a particular request\n       URI.\n\n\n * Requires APM module","examples":"when HTTP_REQUEST {\n\n       # Check the requested HTTP path\n       switch -glob [string tolower [HTTP::path]] {\n              \"/apm_uri1*\" -\n              \"/apm_uri2*\" -\n              \"/apm_uri3*\" {\n                     # Enable APM for these paths\n                     ACCESS::enable\n              }\n              default {\n                     # Disable APM for all other paths\n                     ACCESS::disable\n              }\n       }\n}","returnValue":""},
{"commandName":"ACCESS::perflow","description":"This command can be used to either set or return the value of a perflow variable that has been set inside the Access Per-Request Policy that is being run.\n\n            ACCESS::perflow get <var> will return the value of any perflow variable that has already been set. A perflow variable with no value set will return an empty string. An invalid perflow variable name will give a connection reset.\n\n            ACCESS::perflow set <var> <val> will set the value of the custom perflow variable. Currently the only perflow variables that can be set are \"perflow.custom\" and \"perflow.scratchpad\". All other variables will return a connection reset.","examples":"when ACCESS_PER_REQUEST_AGENT_EVENT {\n                set id [ACCESS::perflow get perflow.irule_agent_id]\n\n                if { $id eq \"irule_agent_one\" } {\n                    log local0. \"Made it to iRule agent in perrequest policy.\"\n                    ACCESS::perflow set perflow.custom \"agent_one\"\n                }\n            }","returnValue":"ACCESS::perflow get will return the string of perflow variable; empty if value isn't set"},
{"commandName":"ACCESS::policy","description":"The ACCESS::policy commands allow you to retrieve information about the\naccess policies in place for a given connection.\n\n\nACCESS::policy agent_id\n\n     * Returns the identifier for the agent raising the\n       ACCESS_POLICY_AGENT_EVENT.\n\nACCESS::policy result\n\n     * Returns back the result of an access policy. The result will be one\n       of following:\n     * - allow\n     * - deny\n     * - redirect\n\nACCESS::policy uri\n\n     * Returns TRUE if current request URI is internal to ACCESS (v11+\n       only).\n\nACCESS::policy evaluate\n\n     * Executes an access policy using an APM profile and an existing APM\n       session. The flags sid and profile are required, and the profile\n       selection should include the folder path\n       (\"/Common/access-policy-name\"). The policy will evaluate in\n       clientless mode (i.e., no logon pages or message boxes). You can\n       insert multiple session variable keys and values that will be used\n       during policy evaluation.\n\n\n * Requires APM module","examples":"when RULE_INIT {\n    # Set a static username and password for testing.\n    set static::username user1\n    set static::password password1\n}\nwhen CLIENT_ACCEPTED {\n    # When we accept a connection, create an Access session and save the session ID.\n    set flow_sid [ACCESS::session create -timeout 600 -lifetime 3600]\n}\n\nwhen HTTP_REQUEST {\n    # Under the previously saved session ID for the created session, use the \"/Common/test\" access\n    # policy to evaluate the connection. Set the session variables \"username\", \"password\", and \"landinguri\"\n    # to something so the policy has something to evaluate.\n    ACCESS::policy evaluate -sid $flow_sid -profile /Common/test session.logon.last.username $static::username session.logon.last.password $static::password session.server.landinguri [string tolower [HTTP::uri]]\n    # Check the outcome of the access policy evaluation. Throw a response basedon what we learn.\n    switch [ACCESS::policy result -sid $flow_sid] {\n        \"allow\" {\n              HTTP::respond 200 content \"<html><body>You made it ($flow_sid)!</body></html>\"\n        }\n        \"deny\" {\n             HTTP::respond 200 content \"<html><body>Go away ($flow_sid)!</body></html>\"\n        }\n        default {\n             HTTP::respond 200 content \"<html><body>Different result than expected - check your configuration. ($flow_sid)</body></html>\"\n        }\n    }\n}\n\nwhen CLIENT_CLOSED {\n    # To avoid clutter, remove the access session for the flow.\n    ACCESS::session remove -sid $flow_sid\n}","returnValue":""},
{"commandName":"ACCESS::respond","description":"This command generates new respond and automatically overrides the\ndefault respond. This command only can be used only once per HTTP\nrequest, and subsequent calls to this command will return an error.\nNotes:\n\nAdditional capabilities:\n\n     * ACCESS::respond will ignores empty header name, but not header\n       value. e.g. ACCESS::respond 200 content $body $header_name\n       $header_value. If $header_name is empty, ACCESS::respond will also\n       ignore $header_value.\n     * By default keeping connection alive is determined by HTTP hudfilter\n       via http_keepalive(). The admin can override Keep-Alive state to\n       force connection close via specifying header Connection Close.\n       Currrently we don't support forcing connection to be keep-alive.\n     * For 401, This command will automatically insert this header\n       WWW-Authenticate: Basic realm=\"\". This can be overriden by\n       specifying WWW-Authenticate header value.\n\nChanged behavior on ACCESS\n\n     * As above, this command will override the default respond. If there\n       is no respond, such as forwarding the request to the backend\n       server, this command will cancel that forwarding.\n     * ACCESS default response is actually closing the connection. When\n       this command is used, ACCESS will no longer close the connection\n       unless admin force to close it via Connection header.\n\n\nACCESS::respond <status code> [content <content>] [noserver] [<header name> <header value>]\n\n\n * Requires APM module","examples":"when ACCESS_POLICY_COMPLETED {\n    set policy_result [ACCESS::policy result]\n    switch $policy_result {\n    \"allow\" {\n    # Do nothing\n    }\n    \"deny\" {\n        ACCESS::respond 401 content \"<html><body>Error: Failure in Authentication</body></html>\" Connection Close\n    }\n    }\n}","returnValue":""},
{"commandName":"ACCESS::restrict_irule_events","description":"During access policy execution, ACCESS creates requests to various URIs\nrelated to various access policy processing. These includes /my.policy\nand other pages (logon, message box etc.) shown to the end user. By\ndefault from 11.0.0 onward, HTTP and higher layer iRule events are not\nraised for the internal access control URIs. All events except\nACCESS_SESSION_STARTED, ACCESS_SESSION_CLOSED,\nACCESS_POLICY_AGENT_EVENT, ACCESS_POLICY_COMPLETED are blocked (not\nraised) for internal access control URI.\nThis command allows admin to overwrite the default behavior.\nACCESS::restrict_irule_events disable\nDisables the default behavior and enables admin to enable HTTP and\nhigher layer iRule events for the internal access control URI. Admin\ncan use this to\nhandle these URIs in their iRules if needed. Please note that changing\nprocessing for these internal URIs can interfere with access policy.\nScope of this command is per flow. Once enabled for a flow, all\nsubsequent internal access control URI requests will have events raised\nduring processing\n\n\n\nACCESS::restrict_irule_events [enable|disable]\n\n     * todo\n\n\n * Requires APM module","examples":"This iRule allows a customer to hide some error pages from the\nend-user. For e.g. Invalid SID error page is shown to user by\nredirecting user to /my.logout.php3?errorcode=19. In one case, user\nhits this error url if they were to bookmark /my.policy instead of the\nroot, APM responds saying \"you have an invalid session, click here to\nlog in\". Admin can change that just 302 user back to /. Redirect to \"/\"\nwith invalid SID starts a new session.\n\nwhen CLIENT_ACCEPTED {\n    ACCESS::restrict_irule_events disable\n}\n\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] ends_with \"/my.logout.php3?errorcode=19\" }{\n     HTTP::redirect \"/\"\n   }\n}","returnValue":""},
{"commandName":"ACCESS::session","description":"The different permutations of the ACCESS::session command allow you to\naccess or manipulate different portions of session information when\ndealing with APM requests.\n\n\nACCESS::session data get\n\n     * Returns the value of session variable.\n\nACCESS::session data set [ ]\n\n     * Sets the value of session variable to be the given.\n\nACCESS::session exists\n\n     * This commands returns TRUE when the session with provided sid\n       exists, and returns FALSE otherwise. This command is allowed to be\n       executed in different events other then ACCESS events. This command\n       added in version 10.2\n\nACCESS::session remove\n\n     * Removes (deletes) the user session and all associated session\n       variables. Once this command is called, ACCESS_SESSION_CLOSED\n       event is triggered.\n\nACCESS::session create [-flow] <timeout> <lifetime>\n\n     * In versions prior to v11.4, the timeout and lifetime values are\n       indicated directly following the command.\n\n     * In v11.4+, the flags -timeout and -lifetime are supplied, and\n       control the idle timeout and total session lifetime, respectively.\n       Supplying them with a value of 0 (zero) disables that timeout\n       check. The command will return the created SID.\n\n     * In v13.0, a new -flow flag is added. When specified, it associates\n       the created ACCESS session with the connection flow. This allows\n       other ACCESS::session commands to be used without the -sid\n       argument. The ACCESS session ID is automatically obtained\n       from the connection flow.\n\nACCESS::session sid\n\n     * Returns session id associated with current flow if it exists.\n\nACCESS::session modify <timeout> <lifetime | remaining>\n\n     * Modifies the timeout, lifetime, or remaining values of a session. -lifetime and -remaining cannot be used together.\n\n\n * Requires APM module","examples":"when ACCESS_SESSION_STARTED {\n    set user_subnet [ACCESS::session data get \"session.user.clientip\"]\n    if { ($user_subnet & 0xffffff00) != \"192.168.255.0\" } {\n        log local0.notice \"Unauthorized subnet\"\n        ACCESS::session remove\n    }\n}\n\n\nwhen ACCESS_POLICY_AGENT_EVENT {\n            if { [ACCESS::policy agent_id] eq \"lastLogon\" } {\n                        # our limit in seconds\n                        set 2weeks 1209600\n                        # diff in 100 nanosecond increments between MS time attribute (year 1601) and start of epoch\n                        set offset 11644473600000\n                        set adtime \"[ACCESS::session data get session.ad.last.attr.lastLogon]\"\n                        # convert adtime to milliseconds\n                        set millisecs [expr {$adtime / 10000}]\n                        # subtract offset\n                        set lastlogintime [expr {$millisecs - $offset}]\n                        # convert to seconds because milliseconds for 'now' were negative (maybe vmware issue)\n                        set secs [expr {$lastlogintime / 1000}]\n                        set now [clock seconds]\n                        # finally calculate the difference\n                        set diff [expr {$now - $secs}]\n                        log local0. \"lastLogon: $diff seconds from current time\"\n                        if { $diff > $2weeks } {\n                                    ACCESS::session data set session.custom.lastLogonWithin2Weeks 0\n                        } else {\n                                    ACCESS::session data set session.custom.lastLogonWithin2Weeks 1\n                        }\n            }\n}\n\nOne scenario when this command is useful is when the admin tries to\nsupport non-standard browser HTTP application. Admins can verify the\nMRHSession cookie using this command and provide a customized response\nwhich tells the client to re-authenticate.\n\nwhen HTTP_REQUEST {\n    set apm_cookie [HTTP::cookie value MRHSession]\n    if { $apm_cookie != \"\" && ! [ACCESS::session exists $apm_cookie] } {\n        HTTP::respond 401 WWW-Authenticate \"Basic realm=\\\"www.example.com\\\"\"\n        return\n    }\n}\n\nInsert a session variable into an HTTP header (the username in this\nexample):\n\nwhen ACCESS_ACL_ALLOWED {\nset user [ACCESS::session data get \"session.logon.last.username\"]\nHTTP::header insert \"X-USERNAME\" $user\n}","returnValue":""},
{"commandName":"ACCESS::uuid","description":"Enumerates the session IDs that belongs to a specified uuid key by the\norder of its creation and provides them in a Tcl list. By default, the\nuuid created by AAC is using the following format.\n  * {profile_name}.{user_name}\n\nHowever, the admin can manually override this by specifying their own\nuuid key via assigning that value to session.user.uuid session\nvariable. This can be done via iRule using ACCESS::session data set\nsession.user.uuid or via VPE using Variable Assignment Agent. The\nreturn value of ACCESS::uuid getsid is a Tcl list. When there is no\nsession ID associated with that uuid key, it will return an empty list.\n\n\nACCESS::uuid getsid \"{profile_name}.{user_name}\"\n\n\n * Requires APM module","examples":"when HTTP_REQUEST {\n    set apm_cookie_list [ ACCESS::uuid getsid \"[PROFILE::access name].[HTTP::username]\" ]\n    log local0. \"[PROFILE::access name].[HTTP::username] => session number [llength $apm_cookie_list]\"\n    for {set i 0} {$i < [llength $apm_cookie_list]} {incr i} {\n        log local0. \"MRHSession => [ lindex $apm_cookie_list $i]\"\n    }\n}\n\nJan 24 19<!--:36:03 local/tmm info tmm[23333]: Rule _test <HTTP_REQUEST>: simpleAD_withSSO.domain\\lie => session number 1-->\nJan 24 19<!--:36:03 local/tmm info tmm[23333]: Rule _sys_APM_activesync <HTTP_REQUEST>: MRHSession => 51539106083c66c3926e3305d60addae-->","returnValue":""},
{"commandName":"ACCESS::user","description":"The ACCESS::user commands return user ID information.\n\n\nACCESS::user getsid <key>\n\n     * Returns the list of created external SIDs which is associated wit\n       the specified key\n\nACCESS::user getkey <sid_hash>\n\n     * Returns the original SID for specified hash of SID\n     * This command works for clientless mode only\n\n\n * Requires APM module","examples":"when HTTP_REQUEST {\n    set http_path                       [string tolower [HTTP::path]]\n\n    if { $http_path == \"/protected-uri\" } {\n    }\n    else return\n\n    set apm_username                    [ string tolower [HTTP::username] ]\n    set apm_password                    [HTTP::password]\n\n    set user_key {}\n    append user_key $apm_username \".\" $user_hash\n    unset user_hash\n\n    set f_insert_clientless_mode    0\n    # Get a list of internal session ids which are associated with user_key\n    # which in this case is user credential.\n    set apm_cookie_list             [ ACCESS::user getsid $user_key ]\n    if { [ llength $apm_cookie_list ] != 0 } {\n        # Use the first entry in the list, and convert the internal session id\n        # into external session id.\n        set apm_cookie [ ACCESS::user getkey [ lindex $apm_cookie_list 0 ] ]\n        if { $apm_cookie != \"\" } {\n        # And insert it as cookie to be passed into APM.\n            HTTP::cookie insert name MRHSession value $apm_cookie\n        } else {\n            set f_insert_clientless_mode 1\n        }\n    } else {\n        set f_insert_clientless_mode 1\n    }\n    # Execute access policy in clientless mode.\n    if { $f_insert_clientless_mode == 1 } {\n        HTTP::header insert \"clientless-mode\" 1\n        HTTP::header insert \"username\" $apm_username\n        HTTP::header insert \"password\" $apm_password\n    }\n    unset f_insert_clientless_mode\n}\nwhen ACCESS_SESSION_STARTED {\n    # Associate the user_key with the session by assigning the value.\n    if { [ info exists user_key ] } {\n        ACCESS::session data set \"session.user.uuid\" $user_key\n    }\n}","returnValue":""},
{"commandName":"ACCESS::oauth","description":"OAuth related ACCESS iRule\n\nACCESS::oauth sign [ -header <raw-data> ] -payload <raw-data> -key <JWK object>\n                   [ -alg <signing algorithm> ] [ -ignore-cert-expiry ]\n\n     * Returns a JSON Web Signature token based on provided payload and signed\n       with provided JWK object. When the specified JWK object does not specify\n       a JWS signing algorithm, an additional signing algorithm is required\n       and must be provided with the -alg option. Unless specified with the\n       -header option, JOSE header section of JWS will be derived and auto-generated\n       from the available JWK object and signing algorithm, and the generated JOSE\n       header will include a signing algorithm, and JWK key ID or certificate\n       SHA-1 thumbprint or SHA-256 thumbprint whichever is available first in that\n       order.  When the specified JWK object contains a certificate, this command\n       by default ensures that only a certificate with a valid expiration is allowed\n       to be used , unless the -ignore-cert-expiry option is specified.\n\n     * Requires APM module","examples":"when RULE_INIT {\n    # This is an example of using ACCESS::oauth sign command to perform\n    # JWT access token resigning.\n    # Here we predefined the list of incoming claims which BIG-IP\n    # needs to include in the JWT. Here we assumed there is an OAuth Scope\n    # Agent configured, which produces the session variables for each claim.\n    # Once the JWT payload is constructed, here we use ACCESS::oauth sign\n    # command to sign the payload, and produce a JWS.\n    set static::claim_list_string { {sub} {name} }\n    set static::claim_list_boolean_int { {admin} }\n    set static::jws_cache {oauth-sign-test-jws_cache}\n    set static::jwt_issuer {https://myissuer.com}\n    set static::jwt_sess_var_name {session.oauth.scope.last.jwt}\n    set static::jwt_expires_in 10\n    set static::jwt_leeway 0\n    set static::jwt_sdb_timeout_adjustment 3\n}\n\nproc gettimeofday {} {\n    return [ clock seconds ]\n}\n\nproc generate_payload { claim_list_string claim_list_boolean_int } {\n    set payload \"\\{\"\n    append payload {\"issuer\":\"} $static::jwt_issuer {\"}\n    set iat [ call gettimeofday ]\n    append payload {,\"iat\":} $iat\n    append payload {,\"exp\":} [ expr { $iat + $static::jwt_expires_in } ]\n    append payload {,\"nbf\":} [ expr { $iat - $static::jwt_leeway } ]\n    foreach claim $claim_list_string {\n        set value [ ACCESS::session data get \"$static::jwt_sess_var_name.$claim\" ]\n        if { [ string length value ] == 0 } {\n            continue\n        }\n        append payload {,\"} $claim {\":\"} $value {\"}\n    }\n    foreach claim $claim_list_boolean_int {\n        set value [ ACCESS::session data get \"$static::jwt_sess_var_name.$claim\" ]\n        if { [ string length value ] == 0 } {\n            continue\n        }\n        append payload {,\"} $claim {\":} $value\n    }\n    append payload \"\\}\"\n    return $payload\n}\n\nproc generate_jws {} {\n    set payload [ call generate_payload $static::claim_list_string $static::claim_list_boolean_int ]\n    return [ ACCESS::oauth sign -payload $payload -alg RS512 -key /Common/jwk-rsa-2 -ignore-cert-expiry ]\n}\n\nproc get_user_key {} {\n    set data [ ACCESS::session sid ]\n    binary scan [ md5 $data ] H* data\n    return $data\n}\n\nproc get_user_key_from_sdb {} {\n    return [ ACCESS::session data get {session.jwt.cache.user_key} ]\n}\n\nproc set_user_key_to_sdb {} {\n    ACCESS::session data set {session.jwt.cache.user_key} [ call get_user_key ]\n}\n\nproc calc_sdb_timeout {} {\n    return [ expr { $static::jwt_expires_in - $static::jwt_sdb_timeout_adjustment } ]\n}\n\nproc get_jws_from_cache {} {\n    set user_key [ call get_user_key ]\n    set jws [ table lookup -notouch -subtable $static::jws_cache $user_key ]\n    if { [ string length $jws ] != 0 } {\n        return $jws\n    }\n    return [ table set -notouch -subtable $static::jws_cache -excl $user_key [ call generate_jws ] [ call calc_sdb_timeout ]  [ call calc_sdb_timeout ] ]\n}\n\nproc get_jws { from_cache } {\n    if { $from_cache == \"yes\" } {\n        return [ call get_jws_from_cache ]\n    } else {\n        return [ call generate_jws ]\n    }\n}\n\nproc delete_jws_cache {} {\n    set user_key [ call get_user_key_from_sdb ]\n    ACCESS::log \"Delete cache for $user_key\"\n    table delete -subtable $static::jws_cache $user_key\n}\n\nwhen ACCESS_SESSION_STARTED {\n    call set_user_key_to_sdb\n}\n\nwhen ACCESS_ACL_ALLOWED {\n    set jws [call get_jws \"yes\" ]\n    HTTP::header replace Authorization \"Bearer $jws\"\n}\n\nwhen ACCESS_SESSION_CLOSED {\n    call delete_jws_cache\n}","returnValue":"JSON Web Signature string."},
{},
{"commandName":"ACL::action","description":"The ACL::action command allows you to determine the ACL action in the\nFLOW_INIT event. This command requires the Advanced Firewall\nManager module.\n\nSyntax\n\nACL::action\n\n     * without providing an action, the command will return an integer\n       value corresponding to an action that will be taken\n          + 0 is a drop\n          + 1 is reset (or reject)\n          + 2 is allow (or accept)\n          + 3 is allow-final (or accept-decisively)\n\nACL::action [default | drop | reset | allow | allow-final]\n\n     * sets the action to take on the ACL this rule is applied to. This\n       command does not return a value.\n          + default - takes the default action on the ACL within current\n            context effectively skipping any defined rules\n          + drop - drops the connection\n          + reset - resets the connection\n          + allow - allows the connection and proceeds to the next ACL.\n          + allow-final - allows the connection and bypasses further ACL\n            processing\n          + staged - retrieves the current staged action\n\n   If the ACL action is modified, running ACL::action will return the new\n   action to be taken.","examples":"when FLOW_INIT {\n        set ipaddr [IP::client_addr]\n        set locale [whereis $ipaddr country]\n        log local0. \"IP Address/Counry $ipaddr/$locale\"\n        switch $locale {\n                \"US\" -\n                \"CA\" { return }\n                \"GB\" { ACL::action drop }\n                default { ACL::action reset }\n        }\n}\n\n\nwhen FLOW_INIT {\n  if { [IP::addr [IP::client_addr] equals 172.29.97.151] } {\n    ACL::action allow\n    virtual /Common/my_http_vs\n    log \"FLOW_INIT: ACL allow to /Common/my_http_vs\"\n  }\n}","returnValue":"When no argument is provided, the command will return an integer value corresponding to an action that will be taken:\n  + 0 is a drop\n  + 1 is reset (or reject)\n  + 2 is allow (or accept)\n  + 3 is allow-final (or accept-decisively)"},
{"commandName":"ACL::eval","description":"The ACL::eval command allows admin to enforce ACLs for a\ngiven connection through APM network access tunnels.\n\n * Requires APM module and network access\n\nSyntax\nACL::eval\n    evaluates L4 ACLs\n\nACL::eval -l7\n    When -l7 flag is given, ACL::eval will abort if it encounters an L7 ACL\n    and the irule will return 1. It will not perform any ACL Actions (Allow, Reject, etc).\n    If ACL::eval does not encounter any L7 ACLs, it will process the ACL action and return 0.","examples":"when CLIENT_ACCEPTED {\n    ACL::eval\n}\n\nwhen CLIENT_ACCEPTED {\n    if { [ACL::eval -l7] == 0 } {\n        HTTP::disable\n    }\n}","returnValue":""},
{"commandName":"ADAPT::allow","description":"The ADAPT::allow command sets or returns the value of one\nof a set of boolean 'allow' properties for the current or\nspecified side of the virtual server connection for which\nthe iRule is being executed. They are not part of the profile\nand therefore cannot be accessed via tmsh or the GUI.\n\nSyntax:\n\nADAPT::allow [<context>] <property>\n\n    * Gets the property value for the current side\n\nADAPT::allow [<context>] <property> request\n\n    * Gets the property value for the request-adapt side\n\nADAPT::allow [<context>] <property> response\n\n    * Gets the property value for the response-adapt side\n\nADAPT::allow [<context>] <property> <bool>\n\n    * Sets the property value for the current side\n\nADAPT::allow [<context>] <property> request <bool>\n\n    * Sets the property value for the request-adapt side\n\nADAPT::allow [<context>] <property> response <bool>\n\n    * Sets the property value for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).\n\nA <bool> value may be described by any of these notations:\n    * 0 / 1\n    * false / true\n    * disable / enable (recommended)\n    * no / yes\n\nThe following <property> values are supported:\n\n  http_v1.0\n\n    Allow adaptation of HTTP v1.0 requests/responses.\n    By default, only HTTP v1.1 requests and responses are\n    sent to the IVS for adaptation.","examples":"when HTTP_REQUEST {\n    ADAPT::allow http_v1.0 enable\n    ADAPT::allow http_v1.0 response enable\n}\n\nwhen HTTP_RESPONSE {\n    ADAPT::allow http_v1.0 yes\n}","returnValue":"Returns the current of modified value of the property."},
{"commandName":"ADAPT::context_create","description":"Creates a new dynamic adaptation context in the ADAPT filter on\nthe current or specified side of the virtual server connection\nfor which the iRule is being executed. Maybe called mulitple\ntimes to dynamically create chains of adaptation contexts.\n\nSyntax:\n\nADAPT::context_create <name>\n\n    * Creates a dynamic context on the current side.\n      This must be called from the request-adapt side, so has\n      the same effect as ADAPT::context_create request <name>.\n\nADAPT::context_create request <name>\n\n    * Creates a dynamic context on the request-adapt side\n      and inserts it last in the chain of contexts.\n\nADAPT::context_create response <name>\n\n    * Creates a dynamic context on the response-adapt side\n      and inserts it first in the chain of contexts.\n\nADAPT::context_create only be called from a request-adapt\n(client side) event. Response-adapt (server side) contexts\nmust be created from a request-adapt (client side) event.\n\nThe <name> string should uniquely identify a dynamic context\nwithin a virtual server and is useful for debug logging.","examples":"when HTTP_REQUEST {\n    # Create and configure dynamic contexts (on request side)\n    # for both request and response adaptation.\n    set req_ctx1 [ADAPT::context_create my_req_ctx1]\n    ADAPT::select $req_ctx1 ivs-icap-req1\n    set req_ctx2 [ADAPT::context_create my_req_ctx2]\n    ADAPT::select $req_ctx2 ivs-icap-req2\n    set rsp_ctx1 [ADAPT::context_create my_rsp_ctx1]\n    ADAPT::select $rsp_ctx1 response ivs-icap-rsp1\n    set rsp_ctx2 [ADAPT::context_create my_rsp_ctx2]\n}\n\nwhen HTTP_RESPONSE {\n    # Configure a response context from the current (response) side.\n    ADAPT::select $rsp_ctx2 ivs-icap-rsp2\n    ADAPT::timeout $rsp_ctx2 2000\n}","returnValue":"Returns the context handle."},
{"commandName":"ADAPT::context_current","description":"Obtains a handle for the current context. The current context\nis usually that in which the event occurred from which this\ncommand was issued.\n\nSyntax:\n\nADAPT::context_current","examples":"when ADAPT_REQUEST_RESULT {\n    set ctx [ADAPT::context_current]\n    if {$ctx == $req_ctx2 && $need_another_ctx} {\n        set req_ctx3 [ADAPT::context_create my_req_ctx3]\n        ADAPT::select $req_ctx3 ivs-icap-req3\n    }\n}","returnValue":"Returns the handle of the current context."},
{"commandName":"ADAPT::context_delete_all","description":"Deletes all dynamic contexts on both sides of the virtual\nserver, making the static context the current context. This\nis done automatically when the last of a connection flow and\nits peer is torn down, so normally need not be called.\n\nSyntax:\n\nADAPT::context_delete_all","examples":"# Conditionally revert to static contexts after request processed\n# (contrived example, probably not useful).\nwhen HTTP_PROXY_REQUEST {\n    if {$revert_to_profile} {\n        ADAPT::context_delete_all\n    }\n}","returnValue":""},
{"commandName":"ADAPT::context_name","description":"Obtains the name of an adaptation context. The name of a\ndynamic context was specified when it was created. The name\nof a static (profile) context is that of the ADAPT profile\non the side of the virtual server where the context resides.\n\nSyntax:\n\nADAPT::context_name <context>","examples":"when ADAPT_RESPONSE_RESULT {\n   set ctx [ADAPT::context_current]\n   set ctx_name [ADAPT::context_name $ctx]\n   log local0. \"ADAPT_RESPONSE_RESULT in context $ctx_name\"\n}","returnValue":"Returns the context name."},
{"commandName":"ADAPT::context_static","description":"Obtains a handle for the static context on the current\nor specified side. The static context is the profile-based\ncontext that applies when there are no dynamic contexts on that\nside. Returns a null string if the connection flow has not\nyet been initialized (for example, if the command was issued\nfrom a request-adapt (client side) event and the server side\nconnection has not yet been established).\n\nSyntax:\n\nADAPT::context_static\n\n    * Gets the static context on the current side.\n\nADAPT::context_static request\n\n    * Gets the static context on the request-adapt side.\n\nADAPT::context_static response\n\n    * Gets the static context on the response-adapt side.","examples":"when ADAPT_REQUEST_RESULT {\n    set static_ctx [ADAPT::context_static]\n    set ctx [ADAPT::context_current]\n    if {$ctx == $static_ctx} {\n        log local0. \"No dynamic contexts have been created.\"\n    }\n}","returnValue":"Returns the handle of the static context, or a null string."},
{"commandName":"ADAPT::enable","description":"The ADAPT::enable command enables, disables or returns the enable\nstate of the ADAPT filter on the current or specified side of the\nvirtual server connection for which the iRule is being executed.\n\nSyntax\n\nA <bool> value may be described by any of these notations:\n    * 0 / 1\n    * false / true\n    * disable / enable (recommended)\n    * no / yes\n\nADAPT::enable [<context>]\n\n    * Gets the enable state for the current side\n\nADAPT::enable [<context>] request\n\n    * Gets the enabled state for the request-adapt side\n\nADAPT::enable [<context>] response\n\n    * Gets the enabled state for the response-adapt side\n\nADAPT::enable [<context>] <bool>\n\n    * Disable or enable the current side\n\nADAPT::enable [<context>] request <bool>\n\n    * Disable or enable the request-adapt side\n\nADAPT::enable [<context>] response <bool>\n\n    * Disable or enable the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when HTTP_REQUEST {\n     ADAPT::enable true\n     ADAPT::enable response false\n}\n\nwhen HTTP_RESPONSE {\n     if { [HTTP::header \"Content-Type\"] contains \"image\" } {\n        ADAPT::enable true\n     }\n     if { [HTTP::header \"Content-Type\"] contains \"video\" } {\n        ADAPT::enable true\n     }\n}","returnValue":"Returns the current of modified enable state."},
{"commandName":"ADAPT::preview_size","description":"The ADAPT::preview_size command sets or returns the preview-size\nattribute of the ADAPT filter on the current or specified side of\nthe virtual server connection for which the iRule is being executed.\n\nSyntax\n\nADAPT::preview_size [<context>]\n\n    * Gets the preview-size attribute for the current side\n\nADAPT::preview_size [<context>] request\n\n    * Gets the preview-size attribute for the request-adapt side\n\nADAPT::preview_size [<context>] response\n\n    * Gets the preview-size attribute for the response-adapt side\n\nADAPT::preview_size [<context>] <number>\n\n    * Sets the preview-size attribute for the current side\n\nADAPT::preview_size [<context>] request <number>\n\n    * Sets the preview-size attribute for the request-adapt side\n\nADAPT::preview_size [<context>] response <number>\n\n    * Sets the preview-size attribute for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when HTTP_RESPONSE {\n    if { [HTTP::header \"Content-Type\"] contains \"image\" } {\n        ADAPT::select ivs-icap-image\n        ADAPT::preview_size 10000\n    }\n    if { [HTTP::header \"Content-Type\"] contains \"video\" } {\n       ADAPT::select ivs-icap-video\n       ADAPT::preview_size 30000\n    }\n}","returnValue":"Returns the current or modified preview size (bytes)."},
{"commandName":"ADAPT::result","description":"The ADAPT::result command sets or returns the adaptation result\ncode of the ADAPT filter on the current or specified side of the\nvirtual server connection for which the iRule is being executed.\n\nPossible result codes are:\n    * unknown - The internal virtual server has not returned a\n      result yet. It is not possible to change the result code\n      to this value.\n    * bypass - The internal virtual server does not need to modify\n      the request or response. If the iRule sets this value, ADAPT\n      immediately goes into a bypass mode where it does not send\n      any more payload to the IVS and gnores any further payload\n      returned from the IVS. Any payload in a preview buffer is\n      first replayed to the HTTP destination (server or client),\n      but if there is no preview or it has been dropped, any payload\n      previously sent to the IVS is lost. In some use-cases that is\n      OK because the IVS response will be replaced by an iRule that\n      overrides that response. Whenever bypass mode is engaged while\n      there is outstanding payload not buffered in a preview, that\n      might have been lost, a warning message is logged.\n      Prior to Big-IP version 13.0, ADAPT would abort the HTTP\n      connection when payload could might be lost. From 13.0 on,\n      the HTTP connection is not aborted and the user has the\n      opportunity to handle the situation via iRules.\n      It is recommended that bypass mode only be set by an iRule\n      when the entire payload from the IVS is to be replaced.\n    * modify - The internal virtual server is modifying the request\n      or result. It is not possible to change the result code to\n      this value.\n    * respond - (request-adapt only) The internal virtual server is\n      returning a HTTP response for the provided HTTP request. It\n      is not possible to change the result code to this value.\n    * close - The adaptation server closed the connection before\n      receiving an answer. The adaptation profile will respond\n      to this state as directed by the service-down-action\n      mode. Changing the result code to this value will force\n      the service_down_action to be applied.\n    * reset - The connection with the adaptation server was reset\n      before receiving an answer. The adaptation profile will\n      respond to this state as directed by the service-down-action\n      mode. It is not possible to change the result code to\n      this value.\n    * timeout - A timeout occurred before the adaptation server\n      was reset before receiving an answer. The adaptation\n      profile will respond to this state as directed by the\n      service-down-action mode. It is not possible to change the\n      result code to this value.\n\nSyntax\n\nADAPT::result [<context>]\n\n    * Gets the result code for the current side\n\nADAPT::result [<context>] request\n\n    * Gets the result code for the request-adapt side\n\nADAPT::result [<context>] response\n\n    * Gets the result code for the response-adapt side\n\nADAPT::result [<context>] <code>\n\n    * Sets the result code for the current side\n\nADAPT::result [<context>] request <code>\n\n    * Sets the result code for the request-adapt side\n\nADAPT::result [<context>] response <code>\n\n    * Sets the result code for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when ADAPT_REQUEST_RESULT {\n     if {[ADAPT::result] == \"respond\"} {\n        # Force ADAPT to ignore any direct response from IVS\n        # (contrived example, probably not useful as-is).\n        ADAPT::result bypass\n     }\n}","returnValue":"Returns the current or modified result code."},
{"commandName":"ADAPT::select","description":"The ADAPT::select command returns or selects the name of\nthe internal virtual server (IVS) associated with the ADAPT\nfilter on the current or specified side of the virtual server\nconnection for which the iRule is being executed.\n\nSyntax\n\nADAPT::select [<context>]\n\n    * Gets the IVS name for the current side\n\nADAPT::select [<context>] request\n\n    * Gets the IVS name for the request-adapt side\n\nADAPT::select [<context>] response\n\n    * Gets the IVS name for the response-adapt side\n\nADAPT::select [<context>] <name>\n\n    * Sets the IVS by name for the current side\n\nADAPT::select [<context>] request <name>\n\n    * Sets the IVS by name for the request-adapt side\n\nADAPT::select [<context>] response <name>\n\n    * Sets the IVS by name for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when HTTP_RESPONSE {\n     if { [HTTP::header \"Content-Type\"] contains \"image\" } {\n        ADAPT::select ivs-icap-image\n        ADAPT::preview_size 10000\n        ADAPT::enable yes\n     }\n     if { [HTTP::header \"Content-Type\"] contains \"video\" } {\n        ADAPT::select ivs-icap-video\n        ADAPT::preview_size 30000\n        ADAPT::enable yes\n     }\n}","returnValue":"Returns the current or new internal virtual server (IVS) name."},
{"commandName":"ADAPT::service_down_action","description":"The ADAPT::service_down_action command sets or returns the\nservice-down-action attribute of the ADAPT filter on the\ncurrent or specified side of the virtual server connection\nfor which the iRule is being executed.\n\nPossible service-down-actions aare:\n    * ignore - Do not send the HTTP request or response to the\n      internal virtual server (bypass). Pass it through unchanged.\n    * reset - Reset (RST) the connection.\n    * drop - Drop (FIN) the connection.\n\nSyntax\n\nADAPT::service_down_action [<context>]\n\n    * Gets the service-down-action for the current side\n\nADAPT::service_down_action [<context>] request\n\n    * Gets the service-down-action for the request-adapt side\n\nADAPT::service_down_action [<context>] response\n\n    * Gets the service-down-action for the response-adapt side\n\nADAPT::service_down_action [<context>] {ignore|drop|reset}\n\n    * Sets the service-down-action for the current side\n\nADAPT::service_down_action [<context>] request {ignore|drop|reset}\n\n    * Sets the service-down-action for the request-adapt side\n\nADAPT::service_down_action [<context>] response {ignore|drop|reset}\n\n    * Sets the service-down-action for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when ADAPT_REQUEST_HEADERS {\n     # Cause connection to be dropped if ICAP server handling\n     # response is down for requests with a custom HTTP header\n     # (which might have been resulted from request adaptation).\n     if {[HTTP::header exists \"X-Drop-if-down\"]} {\n        ADAPT::service_down_action response drop\n     }\n}","returnValue":"Returns the current or modified service-down-action."},
{"commandName":"ADAPT::timeout","description":"The ADAPT::timeout command sets or returns the timeout attribute\nof the ADAPT filter on the current or specified side of the\nvirtual server connection for which the iRule is being executed.\nThe timeout (in milliseconds) is how long ADAPT will wait for\na result from the internal virtual server before deciding the\nservice is down.\n\nSyntax\n\nADAPT::timeout [<context>]\n\n    * Gets the timeout attribute for the current side\n\nADAPT::timeout [<context>] request\n\n    * Gets the timeout attribute for the request-adapt side\n\nADAPT::timeout [<context>] response\n\n    * Gets the timeout attribute for the response-adapt side\n\nADAPT::timeout [<context>] <number>\n\n    * Sets the timeout attribute for the current side\n\nADAPT::timeout [<context>] request <number>\n\n    * Sets the timeout attribute for the request-adapt side\n\nADAPT::timeout [<context>] response <number>\n\n    * Sets the timeout attribute for the response-adapt side\n\nThe optional <context> argument applies the command to a\nspecific context. Useful when there are dynamic contexts.\nIf \"request\" or \"response\" is specified, the context must\nbe on the appropriate side (client or server, respectively).","examples":"when HTTP_RESPONSE {\n     if { [HTTP::header \"Content-Type\"] contains \"image\" } {\n        ADAPT::select ivs-icap-image\n        ADAPT::timeout 500\n     }\n     if { [HTTP::header \"Content-Type\"] contains \"video\" } {\n        ADAPT::select ivs-icap-video\n        ADAPT::timeout 2000\n     }\n }","returnValue":"Returns the current or modified timeout in milliseconds."},
{"commandName":"AES::decrypt","description":"Decrypt the data using an AES key.\n\nSyntax\n\nAES::decrypt <key> <data>\n\n     * <key> will be interpreted as an AES key and used directly if it is\n       a string formatted as an AES::key or an object generated from\n       AES::key.\n     * <key> will otherwise be interpreted as a pass phrase and used to\n       generate an AES key. This does not work due to bug 224113.\n     * Decrypt the <data> using the AES key either supplied or generated\n       from <key>.\n\n\nCaution\n\n   This function is affected by ID241924 and ID242479, and should not be\n   used in BIG-IP v10.1.x or earlier.\n   This function is also affected by ID224113, and a workaround is\n   necessary. The workaround is to not use a passphrase, but to specify a\n   key directly, in the form of \"AES <key length> <key in hex>\", where\n   <key length> is 128, 192, or 256. For example, \"AES 128\n   e467128783ea04aba33aded4e6e457a5\", would be a valid 128-bit key.","examples":"when HTTP_REQUEST {\n  set key \"AES 128 43047ad71173be644498b98de6a32fe3\"\n  set decryptedData [AES::decrypt $key $encryptedData]\n  log local0. \"The decrypted data is $decryptedData\"\n}","returnValue":"Returns the decrypted data."},
{"commandName":"AES::encrypt","description":"Encrypt the data using an AES key.\n\nSyntax\n\nAES::encrypt <key> <data>\n\n     * <key> will be interpreted as an AES key and used directly if it is\n       a string formatted as an AES::key or an object generated from\n       AES::key.\n     * <key> will otherwise be interpreted as a pass phrase and used to\n       generate an AES key. This does not work in versions prior to BIG-IP\n       11.2.0 due to bug 224113.\n     * Encrypt the <data> using the AES key either supplied or generated\n       from <key>.\n\n\nCaution\n\n   This function is affected by ID241924 and ID242479, and should not be\n   used in BIG-IP v10.1.x or earlier.\n   This function is also affected by ID224113, and a workaround is\n   necessary. The workaround is to not use a passphrase, but to specify a\n   key directly, in the form of \"AES <key length> <key in hex>\", where\n   <key length> is 128, 192, or 256. For example, \"AES 128\n   e467128783ea04aba33aded4e6e457a5\", would be a valid 128-bit key. This\n   was fixed in BIG-IP v11.2.0.","examples":"when SERVER_DATA {\n  set key \"AES 128 43047ad71173be644498b98de6a32fe3\"\n  set encryptedData [AES::encrypt $key [TCP::payload]]\n  TCP::payload replace 0 [TCP::payload length] $encryptedData\n}","returnValue":"Returns the encrypted data."},
{"commandName":"AES::key","description":"Creates an AES key of the specified length for use in\nencryption/decryption operations.\n\nSyntax\n\nAES::key < 128 | 192 | 256 >\n\n     * Creates an AES key of the specified length (in bits) for use in\n       encryption/decryption operations.\n     * Default key length is 128 bits","examples":"In this example, any time the rule is saved, a new encryption key is\ncreated and all existing encrypted strings become invalid:\nNote: this example is NOT CMP-COMPATIBLE as it uses GLOBAL variable\n\nwhen RULE_INIT {\n    set ::key [AES::key 128]\n}\n\nThe next example avoids this issue, by adding logic to only create a\nnew key if there isn't an existing one. If there was a failover to the\npeer, a new key would still be generated though.\n\nwhen RULE_INIT {\n   set ::encryption_debug 2\n\n   # Create an encryption key if one doesn't exist already\n   if {[info exists ::global_encrypt_key_v1] and [string length $::global_encrypt_key_v1]}{\n\n      if {$::encryption_debug > 1}{log local0. \"Using existing key: $::global_encrypt_key_v1\"}\n\n   } else {\n      # Key didn't exist so create one\n      set ::global_encrypt_key_v1 [AES::key 128]\n      if {$::encryption_debug > 1}{log local0. \"Created new encryption key: $::global_encrypt_key_v1\"}\n   }\n}\n\nYou can replace the functionality of AES::key by specifying a key as a\nproperly formatted string. The advantage is that the key value is\nconstant regardless of which unit is active. The proper format is \"AES\n   <128 | 192 | 256> <string of 32, 48, or 64 HEX digits respectively>\"\nHere is an example:\n\nwhen RULE_INIT {\n\n    # Save a 128 bit key as a string\n    set key_string \"AES 128 b55c4753cba6adaa0e4ea7640504d9b4\"\n\n    # Encrypt another test string with the key in hex\n    set encrypted [AES::encrypt $key_string \"decrypted text\"]\n\n    # Log the decrypted value\n    log local0. \"\\$decrypted: [AES::decrypt $key_string $encrypted]\"\n}\n\nLog output:\n\nRule aes-key <RULE_INIT>: $decrypted: decrypted text","returnValue":"Returns the created key."},
{},
{},
{},
{},
{},
{},
{},
{"commandName":"ANTIFRAUD::disable","description":"disables the anti-fraud plugin","examples":"when HTTP_REQUEST {\n                # Disable request with Antifraud-Disable header (bypass antifraud plugin)\n                if { [HTTP::header exists \"Antifraud-Disable\" ] } {\n                    ANTIFRAUD::disable\n                }\n}","returnValue":""},
{"commandName":"ANTIFRAUD::enable","description":"enables the anti-fraud plugin","examples":"when HTTP_REQUEST {\n                # apply default anti-fraud profile on the transaction with Antifraud-Foo HTTP header\n                if { [HTTP::header exists \"Antifraud-Foo\" ] } {\n                    ANTIFRAUD::enable\n                }\n                # apply /Common/antifraud_bar profile on the transaction with Antifraud-Bar HTTP header\n                if { [HTTP::header exists \"Antifraud-Bar\" ] } {\n                    ANTIFRAUD::enable /Common/antifraud_bar\n                }\n}","returnValue":"ANTIFRAUD::enable\n                Applies the default anti-fraud profile attached to the virtual server.\n\nANTIFRAUD::enable <profile>\n                Applies the specified anti-fraud profile to the flow instead of the default profile attached to the virtual server."},
{"commandName":"ANTIFRAUD::disable_malware","description":"disables malware detection for the current transaction.","examples":"when HTTP_REQUEST {\n                if { [HTTP::header exists \"Antifraud-Disable-Malware\" ] } {\n                    ANTIFRAUD::disable_malware\n                    log local0. \"Malware Detection disabled\"\n                }\n            }","returnValue":"disables malware detection for the current transaction."},
{"commandName":"ANTIFRAUD::disable_phishing","description":"disables phishing detection for the current transaction.","examples":"when HTTP_REQUEST {\n                if { [HTTP::header exists \"Antifraud-Disable-Phishing\" ] } {\n                    ANTIFRAUD::disable_phishing\n                    log local0. \"Phishing Detection disabled\"\n                }\n            }","returnValue":"disables phishing detection for the current transaction."},
{"commandName":"ANTIFRAUD::disable_app_layer_encryption","description":"disables application layer encryption for the current transaction.","examples":"when HTTP_REQUEST {\n                if { [HTTP::header exists \"Antifraud-Disable-AppLayerEncryption\" ] } {\n                    ANTIFRAUD::disable_app_layer_encryption\n                    log local0. \"Application Layer Encryption disabled\"\n                }\n            }","returnValue":"disables application layer encryption for the current transaction."},
{"commandName":"ANTIFRAUD::disable_auto_transactions","description":"disables automatic transactions for the current transaction.","examples":"when HTTP_REQUEST {\n                if { [HTTP::header exists \"Antifraud-Disable-AutoTransactions\" ] } {\n                    ANTIFRAUD::disable_auto_transactions\n                    log local0. \"Automatic Transactions disabled\"\n                }\n            }","returnValue":"disables automatic transactions for the current transaction."},
{"commandName":"ANTIFRAUD::username","description":"ANTIFRAUD::username\n                returns username value, only in context of ANTIFRAUD_LOGIN event.\n\nANTIFRAUD::username USERNAME_ALIAS ;\n                replaces existing username with USERNAME_ALIAS, only in context of ANTIFRAUD_LOGIN event.","examples":"when ANTIFRAUD_LOGIN {\n                log local0. \"Username [ANTIFRAUD::username] tried to log in.\"\n                ANTIFRAUD::username username_alias\n                log local0. \"Username alias is [ANTIFRAUD::username].\"\n}","returnValue":"ANTIFRAUD::username\n                returns username value, only in context of ANTIFRAUD_LOGIN event.\n\nANTIFRAUD::username <username_alias>\n                no return value (replaces existing username with <username_alias>), only in context of ANTIFRAUD_LOGIN event."},
{"commandName":"ANTIFRAUD::guid","description":"returns GUID value, only in context of ANTIFRAUD_LOGIN event.","examples":"when ANTIFRAUD_LOGIN {\n                log local0. \"Infected username with GUID [ANTIFRAUD::guid] tried to log in.\"\n}","returnValue":"returns GUID value, only in context of ANTIFRAUD_LOGIN event."},
{"commandName":"ANTIFRAUD::fingerprint","description":"returns fingerprint data collected on client side.","examples":"when ANTIFRAUD_LOGIN {\n                log local0. \"Client fingerprint: [ANTIFRAUD::fingerprint].\"\n            }","returnValue":"returns fingerprint data collected on client side."},
{"commandName":"ANTIFRAUD::result","description":"returns result of login validation (passed or failed).","examples":"when ANTIFRAUD_LOGIN {\n                log local0. \"Username tried to log in with result [ANTIFRAUD::result].\"\n            }","returnValue":"returns result of login validation (passed or failed)."},
{"commandName":"ANTIFRAUD::disable_alert","description":"disables the current alert","examples":"when ANTIFRAUD_ALERT {\n                ANTIFRAUD::disable_alert\n}","returnValue":"disables the current alert"},
{"commandName":"ANTIFRAUD::alert_id","description":"returns an alert id. For example d4.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert ID: [ANTIFRAUD::alert_id].\"\n}","returnValue":"returns an alert id. For example d4."},
{"commandName":"ANTIFRAUD::alert_type","description":"returns alert type.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert type: [ANTIFRAUD::alert_type].\"\n}","returnValue":"returns alert type."},
{"commandName":"ANTIFRAUD::alert_component","description":"returns the error type according to alert_type.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert component: [ANTIFRAUD::alert_component].\"\n}","returnValue":"returns the error type according to alert_type."},
{"commandName":"ANTIFRAUD::alert_details","description":"returns alert details.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert details: [ANTIFRAUD::alert_details].\"\n}","returnValue":"returns alert details."},
{"commandName":"ANTIFRAUD::alert_guid","description":"returns GUID that is used to identify which users have been infected with malware before the user logs in.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert GUID: [ANTIFRAUD::alert_guid].\"\n}","returnValue":"returns GUID that is used to identify which users have been infected with malware before the user logs in."},
{},
{"commandName":"ANTIFRAUD::alert_license_id","description":"returns crc32 of the license id in hex","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert license ID: [ANTIFRAUD::alert_license_id].\"\n}","returnValue":"returns crc32 of the license id in hex"},
{"commandName":"ANTIFRAUD::alert_score","description":"returns the alert severity","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert score: [ANTIFRAUD::alert_score].\"\n}","returnValue":"returns the alert severity"},
{"commandName":"ANTIFRAUD::alert_transaction_data","description":"returns key-value list of all parameters marked to be attached.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert transaction data: [ANTIFRAUD::alert_transaction_data].\"\n}","returnValue":"returns key-value list of all parameters marked to be attached."},
{"commandName":"ANTIFRAUD::alert_username","description":"returns a username and for phishing also additional fields.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert username: [ANTIFRAUD::alert_username].\"\n}","returnValue":"returns a username and for phishing also additional fields."},
{"commandName":"ANTIFRAUD::alert_http_referrer","description":"returns HTTP referrer.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert HTTP referrer: [ANTIFRAUD::alert_http_referrer].\"\n}","returnValue":"returns HTTP referrer."},
{"commandName":"ANTIFRAUD::alert_additional_info","description":"returns a list of keys and values that describes integrity parameters check failure or parameter values too long error.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert additional info: [ANTIFRAUD::alert_additional_info].\"\n}","returnValue":"returns a list of keys and values that describes integrity parameters check failure or parameter values too long error."},
{},
{},
{"commandName":"ANTIFRAUD::alert_html","description":"for js_vhtml alert: returns the whole HTML in an escaped base64 format.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert HTML: [ANTIFRAUD::alert_html].\"\n}","returnValue":"for js_vhtml alert: returns the whole HTML in an escaped base64 format."},
{"commandName":"ANTIFRAUD::alert_defined_value","description":"returns defined (configured) value.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert defined value: [ANTIFRAUD::alert_defined_value].\"\n            }","returnValue":"returns defined (configured) value."},
{"commandName":"ANTIFRAUD::alert_resolved_value","description":"returns resolved (actual) value.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert resolved value: [ANTIFRAUD::alert_resolved_value].\"\n            }","returnValue":"returns resolved (actual) value."},
{"commandName":"ANTIFRAUD::alert_transaction_id","description":"returns HTTP transaction ID.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert transaction ID: [ANTIFRAUD::alert_transaction_id].\"\n            }","returnValue":"returns HTTP transaction ID."},
{"commandName":"ANTIFRAUD::alert_expected_value","description":"returns expected (verified) value, for example in strong integrity check.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert expected value: [ANTIFRAUD::alert_expected_value].\"\n            }","returnValue":"returns expected (verified) value, for example in strong integrity check."},
{"commandName":"ANTIFRAUD::alert_fingerprint","description":"returns fingerprint data collected on client side.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert fingerprint: [ANTIFRAUD::alert_fingerprint].\"\n            }","returnValue":"returns fingerprint data collected on client side."},
{"commandName":"ANTIFRAUD::alert_min","description":"returns variable data from client side, e.g. forbidden added HTML element for the external_sources alert or bait signatures for the trojan_bait alert.","examples":"when ANTIFRAUD_ALERT {\n                if {[ANTIFRAUD::alert_type] eq \"js_vhtml\"} {\n                    if {[ANTIFRAUD::alert_component] eq \"external_sources\"} {\n                        log local0. \"Alert forbidden added element: [ANTIFRAUD::alert_min]\"\n                    }\n                    elseif {[ANTIFRAUD::alert_component] eq \"trojan_bait\"} {\n                        log local0. \"Alert bait signatures: [ANTIFRAUD::alert_min]\"\n                    }\n                }\n            }","returnValue":"returns variable data from client side, e.g. forbidden added HTML element for the external_sources alert or bait signatures for the trojan_bait alert."},
{"commandName":"ANTIFRAUD::alert_origin","description":"returns the origin of the alert, e.g. clientside, serverside or secure alert cookie.","examples":"when ANTIFRAUD_ALERT {\n                log local0. \"Alert origin: [ANTIFRAUD::alert_origin].\"\n            }","returnValue":"returns the origin of the alert, e.g. clientside, serverside or secure alert cookie."},
{"commandName":"ASM::client_ip","description":"Returns the IP address of the end client that sent the request.\nNote that this IP address is not necessarily equal to the address\nreturned by the command IP::client_addr, which is the IP address of the\nimmediate client found in the IP header as received by BIG-IP. The\nlatter can be a proxy, in which case the end client IP address is\nextracted from one of the HTTP headers, typically, X-Forwarded-For.\n\nSyntax\n\nASM::client_ip","examples":"when ASM_REQUEST_DONE {\n  log local0. \"Src IP: [IP::client_addr], End-client IP: [ASM::client_ip]\"\n}","returnValue":"Returns the IP address of the end client that sent the request."},
{"commandName":"ASM::fingerprint","description":"Get the fingerprint of the client device as seen by ASM when it's available.\nThe fingerprint is a unique identifier given to specific client machine. The fingerprint will be available to iRule only for web application that have web scraping turned on with the finger print usage activated.","examples":"when ASM_REQUEST_DONE {\n    log local0.[ASM::fingerprint]\n}","returnValue":"Returns the fingerprint of the client device or 0 if it's not available."},
{"commandName":"ASM::signature","description":"Returns the list of signatures.\n\nSyntax\n\nASM::signature ids\n\n     * Returns the ids of signatures.\n\nASM::signature names\n\n     * Returns a list with the names of the signatures found in the\n       transaction.\n\nASM::signature set_names\n\n     * Returns a list with the set names of the signatures.\n\nASM::signature staged_ids\n\n     * Returns the ids of staged signatures.\n\nASM::signature staged_names\n\n     * Returns a list with the names of the staged signatures found in the\n       transaction.\n\nASM::signature staged_set_names\n\n     * Returns a list with the set names of the staged signatures.","examples":"when ASM_REQUEST_DONE {\n    log local0. \"ids=[ASM::signature ids] names=[ASM::signature names] set_names=[ASM::signature set_names]\"\n    log local0. \"staged_ids=[ASM::signature staged_ids] staged_names=[ASM::signature staged_names] staged_set_names=[ASM::signature staged_set_names]\"\n}","returnValue":""},
{"commandName":"ASM::disable","description":"Disables the ASM plugin processing for the current TCP connection.\nASM will remain disabled on the current TCP connection until it is closed or\nASM::enable is called.\n\nSyntax\n\nASM::disable\n\n     * Disables plugin processing for the duration of the TCP connection\n       or until ASM::enable is called.\n\n    Note: ASM::disable deprecates PLUGIN::disable ASM","examples":"# for 11.4.0+ the command should be used in HTTP_REQUEST event\nwhen HTTP_CLASS_SELECTED {\n  ASM::enable\n  # Disable ASM for HTTP paths ending in .jpg\n  if { [HTTP::path] ends_with \".jpg\" } {\n    ASM::disable\n  }\n}\n\n# This example iRule disables ASM if the client IP address\n# is part of an address type datagroup named bypass_asm_class.\n# The bypass_asm_class datagroup must be created before this iRule is created.\n# To debug the iRule, uncomment the log lines.\n# The iRule is for ASM 10.0.1 or higher only\nwhen CLIENT_ACCEPTED {\n    #log local0. \"[IP::client_addr]:[TCP::client_port]: New TCP connection to [virtual name] [IP::local_addr]:[TCP::local_port]\"\n    # Check if client IP is in the bypass_asm_class\n    if {[matchclass [IP::client_addr] equals bypass_asm_class]}{\n      # Set a variable to track that we'll disable ASM\n      #   when a class with ASM enabled is matched\n      set disable_asm 1\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: Client matched bypass_asm_class datagroup.\"\n   } else {\n      set disable_asm 0\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: Client did not match bypass_asm_class datagroup.\"\n   }\n}\nwhen HTTP_CLASS_SELECTED {\n    # As ASM can only be enabled/disabled in HTTP_CLASS_SELECTED (HTTP_REQUEST starting from 11.4.0+ - sol14381),\n    # check the variable set in CLIENT_ACCEPTED.\n    # Also verify ASM is enabled on the matched class before trying to disable ASM\n    if {[HTTP::class asm]==1}{\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: [HTTP::class] has ASMenabled.\"\n\n      if {$disable_asm==1}{\n         #log local0. \"[IP::client_addr]:[TCP::client_port]: Disabling ASM for this request.\"\n         ASM::disable\n      } else {\n         #log local0. \"[IP::client_addr]:[TCP::client_port]: Not disabling ASM for this request.\"\n         ASM::enable\n      }\n   }\n}","returnValue":""},
{"commandName":"ASM::enable","description":"Enables the ASM plugin processing for the current TCP connection.\nASM will remain enabled on the current TCP connection until it is closed or\nASM::disable is called.\n\nSyntax\n\nASM::enable\n\n     * Enables plugin processing on the connection. ASM will remain\n       enabled on the current TCP connection until it is closed or\n       ASM::disable is called.\n\nASM::enable <policy>\n\n     * Beginning in v11.4, the policy is a required argument. Enables\n       plugin processing on the connection. ASM will remain enabled on the\n       current TCP connection until it is closed or ASM::disable is\n       called.\n     * Since HTTP_CLASS_SELECTED is not available in these versions, you\n       can use ASM::enable and ASM::disable in HTTP_REQUEST\n     * This requires that you have at least a minimal ASM Policy attached\n       to the Virtual Server for the ASM commands to become available.\n\n   Note: The request will fail ASM::enable is called when the currently\n   matched HTTP class does not have ASM enabled. You can check if ASM is\n   enabled by default on the currently selected class using [HTTP::class asm]==1.\n\n   Note: ASM::enable deprecates PLUGIN::enable ASM","examples":"# for 11.4.0+ the command should be used in HTTP_REQUEST event\nwhen HTTP_CLASS_SELECTED {\n  ASM::enable\n  # Disable ASM for HTTP paths ending in .jpg\n  if { [HTTP::path] ends_with \".jpg\" } {\n    ASM::disable\n  }\n}\n\n#Enabling an asm policy called asmb in the Common partition in v11.4.x and Later\nwhen HTTP_REQUEST {\n    ASM::enable \"/Common/asmb\"\n}\n\n# This example iRule disables ASM if the client IP address\n# is part of an address type datagroup named bypass_asm_class.\n# The bypass_asm_class datagroup must be created before this iRule is created.\n# To debug the iRule, uncomment the log lines.\n# The iRule is for ASM 10.0.1 or higher only\nwhen CLIENT_ACCEPTED {\n   #log local0. \"[IP::client_addr]:[TCP::client_port]: New TCP connection to [virtual name] [IP::local_addr]:[TCP::local_port]\"\n   # Check if client IP is in the bypass_asm_class\n   if {[matchclass [IP::client_addr] equals bypass_asm_class]}{\n      # Set a variable to track that we'll disable ASM\n      #   when a class with ASM enabled is matched\n      set disable_asm 1\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: Client matched bypass_asm_class datagroup.\"\n   } else {\n      set disable_asm 0\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: Client did not match bypass_asm_class datagroup.\"\n   }\n}\nwhen HTTP_CLASS_SELECTED {\n   # ASM can only be disabled in HTTP_CLASS_SELECTED (HTTP_REQUEST starting from 11.4.0+ - sol14381),\n   # check the variable set in CLIENT_ACCEPTED.\n   # Also verify ASM is enabled on the matched class before trying to disable ASM\n   if {[HTTP::class asm]==1}{\n\n      #log local0. \"[IP::client_addr]:[TCP::client_port]: [HTTP::class] has ASMenabled.\"\n\n      if {$disable_asm==1}{\n         #log local0. \"[IP::client_addr]:[TCP::client_port]: Disabling ASM for this request.\"\n         ASM::disable\n      } else {\n         #log local0. \"[IP::client_addr]:[TCP::client_port]: Not disabling ASM for this request.\"\n         ASM::enable\n      }\n   }\n}","returnValue":""},
{"commandName":"ASM::payload","description":"This command retrieves or replaces the payload collected by ASM.\n\nSyntax\n\nASM::payload [[<offset>] <length>]\n\n     * The command will retrieve up to length bytes of payload starting at\n       offset. If offset is not specified, a value of offset 0 will be\n       used. If neither length nor offset are specified, then all of the\n       payload will be returned.\n\nASM::payload length\n\n     * The command will return the length of the payload that is currently\n       collected\n\nASM::payload replace <offset> <length> <string>\n\n     * The command will replace <length> bytes of payload starting at\n       <offset> with whatever is specified in string. To get insert\n       behavior leave the <length> argument at zero. To get the same\n       behavior as delete use an empty string.","examples":"This example replaces the request payload with another string in case a\nspecific violation is detected.\n\nwhen ASM_REQUEST_VIOLATION\n{\n  set x [ASM::violation_data]\n  if {([lindex $x 0] contains \"VIOLATION_EVASION_DETECTED\")}\n   {\n      ASM::payload replace 0 0 \"1234567890\"\n   }\n}","returnValue":""},
{"commandName":"ASM::policy","description":"Returns the name of the ASM policy that was applied on the request. It can be used to detect which CPM rules are applied or ASM::enable commands are applied on a request.","examples":"when ASM_REQUEST_BLOCKING{\n    log local0. \"The request was bloced using the [ASM::policy] policy\"\n}","returnValue":"Returns the ASM policy applied on the request or null string if ASM is disabled."},
{"commandName":"ASM::raise","description":"Issues a user-defined violation on the request. The violation\nis added to other possible violations, either raised by the ASM or by\nprevious invocations of this command. The consequent action is\ndetermined by the blocking setting per the raised violation, e.g. if\nthe violation was set to block, then the request will be blocked.\n\nSyntax\n\nASM::raise <violation-name>\n\n     * The name attribute of the violation. It must be a user-defined\n       (custom) violation.\n\nASM::raise <violation-name> [<violation-details>]\n\n     * A multimap, that is a list of key-value pairs, each pair being a\n       list of two elements, adding information on the violation, where it\n       occurred and what exactly caused it. For example offset and length\n       into the original request, header name in which the problem was\n       found, parameter name or value etc. The details are completely\n       opaque to ASM which simply copies them to the log. No check is done\n       on the completeness or validity of the list - it is the\n       responsibility of the iRule developer to maintain it. The maximum\n       number of elements in the array is 20. Note that the same key may\n       have more than one value.\n\n   Notes:\n     * If Session Awareness feature is enabled, then the raised violation\n       will disregard any of the Session Awareness accounting and\n       decisions.\n     * Raising a blocking violation will not prevent the request from\n       being sent to Antivirus scanning (if configured). This is different\n       than the behavior when a built-in violation is detected by ASM in\n       which case the request does not undergo antivirus scanning.","examples":"Buildup of the violation details and then issuing the violation:\n\nwhen ASM_REQUEST_DONE {\n  set x []\n  set y []\n  set z []\n  lappend y key1 value1\n  lappend z key1 value2\n  lappend x $y $z\n  log local0. $x\n\n  ASM::raise my_custom_violation $x\n}\n\nThe logged message will show:\n\n{key1 value1} {key1 value2}\n\nThis is a more concrete example: it counts the number of violations,\nand if it exceeds 3, it issues a custom \"too many violations\"\nviolation.\n\nwhen ASM_REQUEST_DONE {\n   if {[ASM::violation count] > 3 and [ASM::severity] eq \"Error\"} {\n      ASM::raise VIOLATION_TOO_MANY_VIOLATIONS\n   }\n}","returnValue":""},
{"commandName":"ASM::severity","description":"Returns the overall severity of the violations found in the transaction\n(both request and response). This equals to the maximum severity of all\nthese violations\n\nSyntax\n\nASM::severity\n\n     * Returns one of the following values (or null string in case there\n       was no violation until the time the command is invoked)\n          + Emergency\n          + Alert\n          + Critical\n          + Error\n          + Warning\n          + Notice\n          + Informational","examples":"when ASM_REQUEST_DONE {\n   if {[ASM::violation count] > 3 and [ASM::severity] eq \"Error\"} {\n      ASM::raise VIOLATION_TOO_MANY_VIOLATIONS\n   }\n}","returnValue":"+ Null string (in case there was no violation until the time the command is invoked)\n+ Emergency\n+ Alert\n+ Critical\n+ Error\n+ Warning\n+ Notice\n+ Informational"},
{"commandName":"ASM::status","description":"Returns the current status of the request or response\nReturns one of the following values:\n  + Alarm - there are violations and alarm has been raised, but\n    request or response is not blocked. This does not apply to\n    violations that are in staging mode. This value will also be\n    returned if the request had violations but was unblocked using\n    a previously called ASM::unblock command.\n  + Blocked - violations caused the request/response to be\n    blocked. This does not apply to violations that are in staging\n    mode.\n  + Clear - no violations found\n\nSyntax\n\nASM::status","examples":"when ASM_REQUEST_DONE {\n    #log local0.debug \"\\[ASM::status\\] = [ASM::status]\"\n    if { [ASM::status] equals \"alarmed\" } {\n        set x [ASM::violation_data]\n        HTTP::header insert X-ASM \"violation=[lindex $x 0] supportid=[lindex $x 1]\"\n        #log local0.debug \"DEBUG02: violation=[lindex $x 0] supportid=[lindex $x 1]\"\n    }\n}","returnValue":"* Alarm\n* Blocked\n* Clear"},
{"commandName":"ASM::support_id","description":"Returns the support id of the HTTP transaction, a unique\nidentifier assigned by ASM to the transaction, regardless of whether\nviolations were found in the transaction or not. The support id can be\nused to correlate the transaction with its corresponding entry in the\nrequest log and with the blocking page returned to the user in case of\nblocking violations\n\nSyntax\n\nASM::support_id","examples":"","returnValue":""},
{"commandName":"ASM::unblock","description":"Overrides the blocking action for a request that had blocking\nviolations. Consequently, the request will be forwarded to the origin\nserver and also marked with a special \"unblocked\" flag which can be\nviewed in the request log. If the present request was not supposed to\nbe blocked then the command has no effect.\n\nSyntax\n\nASM::unblock\n\n * Notes\n      + Violations from an unblocked request will not be learned for\n        policy modification, neither manually nor automatically.\n      + The command applies to requests only. It is not possible to\n        unblock a response in which violations were found.\n      + The command does not apply to requests that are part of\n        attacks such as Web Scraping or Brute Force login attacks.\n      + An unblocked request will not be sent to Antivirus scanner.\n      + The command takes effect even if it is followed by\n        ASM::raise command with a blocking violation.","examples":"when ASM_REQUEST_DONE {\n  set i 0\n  foreach {viol} [ASM::violation names]{\n  if {$viol eq VIOLATION_ILLEGAL_PARAMETER} {\n    set details [lindex [ASM::violation details] $i]\n    set param_name [b64decode [llookup $details \"param_data.param_name\"]]\n    #remove the bad parameter from the QS - does not work right in all cases, just for illustration!\n    regsub -all \"\\?.*($param_name=^\\&*)\" [HTTP::uri] \"?\" $new_uri\n    HTTP::uri $new_uri\n    ASM::unblock\n  }\n  set i [expr {$i+1}]\n  }\n\n}","returnValue":""},
{"commandName":"ASM::captcha","description":"Responds to the client with a CAPTCHA challenge. \n            Note although ASM will send the CAPTCHA challenge screen back to the user, the enforcement is not always done automatically. \n            To enforce the correct CAPTCHA response, the ASM::captcha_status command should be used.\n\n         Syntax\n\n            ASM::captcha","examples":"# This example counts the number of violations, and if it exceeds 3,\n            # it issues a CAPTCHA action.\n            when ASM_REQUEST_DONE {\n                if {[ASM::violation count] > 3 and [ASM::severity] eq \"Error\"} {\n                    ASM::captcha\n                }\n            }","returnValue":"Returns a string signifying if the challenge was sent successfully:\n            \"ok\" - CAPTCHA challenge was sent successfully \n            \"nok asm blocked request\" -  CAPTCHA challenge was not sent, because a blocking page action was performed\n            \"nok asm uncaptcha command was raised\" -  CAPTCHA challenge was not sent, because uncaptcha command was called\n            \"nok request unqualified for captcha\" - CAPTCHA challenge was not sent, because request is not qualified for CAPTCHA action"},
{"commandName":"ASM::captcha_age","description":"Returns the age of the CAPTCHA challenge in seconds. This is only relevant if the value of ASM::captcha_status is \"correct\"; otherwise, -1 is returned.\n\n         Syntax\n            ASM::captcha_age","examples":"# EXAMPLE: Send CAPTCHA challenge and validate the response, but to avoid\n            # blocking requests to which CAPTCHA challenge cannot be sent (non-HTML pages),\n            # send the CAPTCHA challenge on HTML pages after 30 seconds of aging, which is\n            # before the expiration of the answer.\n            when ASM_REQUEST_DONE {\n                if {[ASM::captcha_status] eq \"correct\"} {\n                    if {[ASM::captcha_age] >= 30} {\n                        ASM::captcha\n                    }\n                } else {\n                    if {[ASM::captcha] ne \"ok\"} {\n                         log local0. \"cannot send captcha_challenge: \\\"$res\\\"\"\n                    }\n                }\n            }","returnValue":"Returns the age of the CAPTCHA challenge in seconds, or -1 if not applicable."},
{"commandName":"ASM::uncaptcha","description":"Overrides the CAPTCHA action for a request mitigated during a Brute-Force attack. \n            Consequently, the request will be forwarded to the origin server. \n            If the present request was not supposed to be mitigated by CAPTCHA then the command has no effect.\n\n         Syntax\n\n         ASM::uncaptcha","examples":"when ASM_REQUEST_DONE {\n                set i 0\n                foreach {viol} [ASM::violation names] {\n                    if {$viol eq VIOLATION_ILLEGAL_PARAMETER} {\n                        set details [lindex [ASM::violation details] $i]\n                        set param_name [b64decode [llookup $details \"param_data.param_name\"]]\n                        #remove the bad parameter from the QS - does not work right in all cases, just for illustration!\n                        regsub -all \"\\?.*($param_name=^\\&*)\" [HTTP::uri] \"?\" $new_uri\n                        HTTP::uri $new_uri\n                        ASM::uncaptcha\n                    }\n                    set i [expr {$i+1}]\n                }\n            }","returnValue":""},
{"commandName":"ASM::captcha_status","description":"Returns the status of the user's answer to the CAPTCHA challenge. The returned value is one of the following strings:\n            not_received - the answer to the CAPTCHA challenge did not appear in the request; this is the normal result, before the CAPTCHA challenge is sent to the client\n            correct - the answer is correct\n            incorrect - the answer is incorrect\n            empty - an empty answer was given, or if the user clicked on the CAPTCHA Refresh button\n            expired - the answer has expired; in this case, the answer is not validated and may be correct or incorrect\n            invalid - the cookie containing the CAPTCHA answer cannot be parsed; this could mean that it was modified by an attacker, or that it is older than two days, or due to a configuration change\n\n         Syntax\n\n            ASM::captcha_status","examples":"# EXAMPLE: Send a CAPTCHA challenge on the login page, and only allow the\n            # login if the user passed the CAPTCHA challenge\n            when ASM_REQUEST_DONE {\n                if {[ASM::captcha_status] ne \"correct\"} {\n                    if {[HTTP::uri] eq \"/t/login.php\"} {\n                        set res [ASM::captcha]\n                        if {$res ne \"ok\"} {\n                            log local0. \"cannot send captcha_challenge: \\\"$res\\\"\"\n                        }\n                    }\n                }\n            }","returnValue":"Returns a string signifying the status of the CAPTCHA challenge."},
{"commandName":"ASM::violation","description":"Returns the list of violations found in the request or response together with details on each one.\n\nSyntax\n\nASM::violation count\n\n     * Returns the number of violations found in the request.\n\nASM::violation names\n\n     * Returns a list with the names of the violations found in the\n       transaction, both built-in and custom (user-defined). The expected\n       names of the available violations can be obtained by looking up the\n       list of violations on the BIG-IP device. If a violation happens\n       more than once, it will appear as many times as the number of\n       occurrences in the request or response. The order of the violations\n       in the list is consistent throughout the other subcommands below\n       that return lists. Thus, violation appearing in index i of the list\n       returned by ASM::violation names will have its corresponding attack\n       type also in index i of the list returned by ASM::violation\n       attack_types and its other details are in index i in the list\n       returned by ASM::violation details.\n\nASM::violation attack_types\n\n     * Returns a list with the attack types corresponding to the\n       violations returned in ASM::violation names.\n\nASM::violation details\n\n     * Returns a list of multimaps, each multimap containing key-value\n       pairs of details on the violations returned by ASM::violation\n       names.\n     * The schema of the details in each multimap, that is, the expected\n       keys in the depends on the type of violation and is derived from\n       the logger violation detail XML schema within the occurrences of\n       the \"violation_type\" element. Each key is the XML element name,\n       with flattened nested structure, such that elments within elements\n       are spearated by dots, as in C structs. For example:\n          + Attack signature violations have the following keys:\n               o sig_data.sig_id\n               o sig_data.blocking_mask\n               o sig_data.kw_data_buffer\n               o sig_data.kw_data_offset\n               o sig_data.kw_data_length\n          + Length violations on parameters have the following keys:\n               o expected_value_length\n               o actual_value_length\n               o parameter_data.name\n               o parameter_data.value\n     * Note that in case of custom violation, the violation details\n       multimap is formatted differently than the multimap used in the\n       ASM::raise command! Rather than having each attribute be\n       represented by its name and value like\n       {{n1 v1} {n2 v2}}\n       there will be recurring fixed variables named\n       \"customParameter.name\" and \"customParameter.value\", following the\n       respective XML elements pointing to the name and value of the\n       respective original custom parameters (see the \"Raising custom\n       violation\" section). A particular name belongs to the value that\n       follows just after it. So the previous example the result of\n       \"ASM::violation details\" will be:\n       {{customParameter.name n1} {customParameter.value v1} {customParameter.name n2}{customParameter.value v2}}","examples":"when ASM_REQUEST_DONE {\n  set i 0\n  foreach {viol} [ASM::violation names]{\n    if {$viol eq \"VIOLATION_ILLEGAL_PARAMETER\"} {\n      set details [lindex [ASM::violation details] $i]\n      set param_name [b64_decode [llookup $details \"param_data.param_name\"]]\n      #remove the bad parameter from the QS - does not work right in all cases,just for illustration!\n      regsub -all \"\\?.*($param_name=[^\\&]*)\" [HTTP::uri] \"?\" $new_uri\n      HTTP::uri $new_uri\n      ASM::unblock\n    }\n    set i [expr {$i+1}]\n  }\n}","returnValue":""},
{"commandName":"ASM::violation_data","description":"This command exposes violation data using a multiple buffers instance.\n\nNote: Starting version 11.5.0 this command is deprecated and replaced by\nASM::violation, ASM::support_id, ASM::severity and ASM::client_ip, which\nhave more convenient syntax and enhanced options. It is kept for\nbackward compatibility.\n\n#Position   Field       Description\n0   Violation           String that contains list of comma separated violations, see below the rquest side and response side violations for value options\n1   support_id          Unique id given for a transaction\n2   web_application     ASM Web application name\n3   Severity            The most critical severity of all the transaction violations, possible values: Emergency, Alert, Critical, Error, Warning, Notice and Informational\n4   source_ip           Client IP. (in case trust xff option is enabled on the policy, this will be the xff ip\n5   attack_type         String that contains list of comma separated attack types, see below for value options\n6   request_status      Can be \"blocked\" or \"alarmed\"\n\n\nRequest Side Violations Table\n\n   Violation Name                           Description\n   VIOLATION_EVASION_DETECTED               Evasion technique detected\n   VIOLATION_REQUEST_TOO_LONG               Request length exceeds defined buffer size\n   VIOLATION_ILLEGAL_INGRESS_OBJECT         Login URL bypassed\n   VIOLATION_PARSER_EXPIRED_INGRESS_OBJECT  Login URL expired\n   VIOLATION_RESPONSE_SCRUBBING             response scrubbing\n   VIOLATION_ILLEGAL_SOAP_ATTACHMENT        Illegal attachment in SOAP message\n   VIOLATION_MISSING_MANDATORY_HEADER       Mandatory HTTP header is missing\n   VIOLATION_HTTP_SANITY_CHECK_FAILED       HTTP protocol compliance failed\n   VIOLATION_CHAR_CONV                      Failed to convert character\n   VIOLATION_MALFORMED_XML                  Malformed XML data\n   VIOLATION_XML_WSDL                       XML data does not comply with schema or WSDL document\n   VIOLATION_XML_FORMAT_SETTING             XML data does not comply with format settings\n   VIOLATION_PARSER_FAILED_SOAP_SECURITY    Soap security parser failed\n   VIOLATION_SOAP_METHOD_NOT_ALLOWED        SOAP method not allowed\n   VIOLATION_BRUTE_FORCE_ATTACK_DETECTED    Maximum login attempts are exceeded\n   VIOLATION_WEB_SCRAPING_DETECTED          Web scraping detection\n   VIOLATION_OBJ_LEN                        Illegal URL length\n   VIOLATION_COOKIE_LEN                     Illegal cookie length\n   VIOLATION_REQ_LEN                        Illegal request length\n   VIOLATION_QS_LEN                         Illegal query string length\n   VIOLATION_POST_DATA_LEN                  Illegal POST data length\n   VIOLATION_MULTI_PART_PARAM_VAL           Null in multi-part parameter value\n   VIOLATION_HEADER_LEN                     Illegal header length\n   VIOLATION_METACHAR_IN_OBJ                Illegal meta character in URL\n   VIOLATION_METACHAR_IN_PARAM_NAME         Illegal meta character in parameter name\n   VIOLATION_METACHAR_IN_DEF_PARAM          Illegal meta character in parameter value\n   VIOLATION_OBJ_TYPE                       Illegal file type\n   VIOLATION_OBJ_DOESNT_EXIST               Non-existent URL\n   VIOLATION_FLOW_TO_OBJ                    Illegal flow to URL\n   VIOLATION_ILLEGAL_METHOD                 Illegal method\n   VIOLATION_SESSSION_ID_IN_URL             Illegal session ID in URL\n   VIOLATION_QS_OR_POST_DATA                Illegal query string or POST data\n   VIOLATION_PARAM                          Illegal parameter\n   VIOLATION_EMPTY_PARAM_VALUE              Illegal empty parameter value\n   VIOLATION_STATIC_PARAM_VALUE             Illegal static parameter value\n   VIOLATION_DYN_PARAM_VALUE                Illegal dynamic parameter value\n   VIOLATION_PARAM_VALUE_LEN                Illegal parameter value length\n   VIOLATION_PARAM_DATA_TYPE                Illegal parameter data type\n   VIOLATION_PARAM_NUMERIC_VALUE            Illegal parameter numeric value\n   VIOLATION_ATTACK_SIGNATURE_DETECTED      Attack signature detected\n   VIOLATION_NUM_OF_MANDATORY_PARAMS        Illegal number of mandatory parameters\n   VIOLATION_PARAM_VALUE_NOT_MATCHING_REGEX Parameter value does not comply with regular expression\n   VIOLATION_MOD_ASM_COOKIE                 Modified ASM cookie\n   VIOLATION_MOD_DOMAIN_COOKIE              Modified domain cookie(s)\n   VIOLATION_NOT_RFC_COOKIE                 Cookie not RFC-compliant\n   VIOLATION_ENTRY_POINT                    Illegal entry point\n   VIOLATION_MSG_KEY                        ASM Cookie Highjacking\n   VIOLATION_EXPIRED_TIMESTAMP              Expired timestamp\n   VIOLATION_METACHAR_IN_HEADER             Illegal meta character in header\n   VIOLATION_HTTP_STATUS_IN_RESPONSE        Illegal response http status code\n   VIOLATION_DOS_ATTACK_STARTED             Dos attack detected\n\n\nResponse Side Violations Table\n\n   Violation Name                      Description\n   VIOLATION_RESPONSE_SCRUBBING        Information leakage detected\n   VIOLATION_HTTP_STATUS_IN_RESPONSE   Illegal HTTP status in response\n   VIOLATION_ATTACK_SIGNATURE_DETECTED Attack signature detected\n   VIOLATION_DOS_ATTACK_STARTED        Dos attack detected\n\n\nAttack-Type Table\n\n   The attack type field can have the following value\n   Attack-Type Name                                 Description\n   ATTACK_TYPE_REMOTE_FILE_INCLUDE                  Remote File Include\n   ATTACK_TYPE_NON_BROWSER_CLIENT                   Non-browser client\n   ATTACK_TYPE_OTHER_APPLICATION_ATTACKS            Other Application Attacks\n   ATTACK_TYPE_TROJAN_BACKDOOR_SPYWARE              Trojan/Backdoor/Spyware\n   ATTACK_TYPE_DETECTION_EVASION                    Detection Evasion\n   ATTACK_TYPE_VULNERABILITY_SCAN                   Vulnerability Scan\n   ATTACK_TYPE_ABUSE_OF_FUNCTIONALITY               Abuse of Functionality\n   ATTACK_TYPE_AUTHENTICATION_AUTHORIZATION_ATTACKS Authentication/Authorization Attacks\n   ATTACK_TYPE_BUFFER_OVERFLOW                      Buffer Overflow\n   ATTACK_TYPE_PREDICTABLE_RESOURCE_LOCATION        Predictable Resource Location\n   ATTACK_TYPE_INFORMATION_LEAKAGE                  Information Leakage\n   ATTACK_TYPE_DIRECTORY_INDEXING                   Directory Indexing\n   ATTACK_TYPE_PATH_TRAVERSAL                       Path Traversal\n   ATTACK_TYPE_XPATH_INJECTION                      XPath\n   ATTACK_TYPE_LDAP_INJECTION                       LDAP Injection\n   ATTACK_TYPE_SERVER_SIDE_CODE_INJECTION           Server Side Code Injection\n   ATTACK_TYPE_COMMAND_EXECUTION                    Command Execution\n   ATTACK_TYPE_SQL_INJECTION                        SQL-Injection\n   ATTACK_TYPE_CROSS_SITE_SCRIPTING                 Cross Site Scripting (XSS)\n   ATTACK_TYPE_DENIAL_OF_SERVICE                    Denial of Service\n   ATTACK_TYPE_OTHER_APPLICATION_ACTIVITY           Other Application Activity\n   ATTACK_TYPE_HTTP_PARSER_ATTACK                   HTTP Parser Attack\n   ATTACK_TYPE_HTTP_REQUEST_SMUGGLING_ATTACK        Request smuggling attack\n   ATTACK_TYPE_FORCEFUL_BROWSING                    Forceful Browsing\n   ATTACK_TYPE_BRUTE_FORCE_ATTACK                   Brute Force Attack\n   ATTACK_TYPE_INJECTION_ATTEMPT                    Injection Attempt\n   ATTACK_TYPE_PARAMETER_TAMPERING                  Parameter Tampering\n   ATTACK_TYPE_XML_PARSER_ATTACK                    XML Parser Attack\n   ATTACK_TYPE_SESSION_HIJACKING                    Session Hijacking\n   ATTACK_TYPE_HTTP_RESPONSE_SPLITTING_ATTACK       Http response splitting attack\n   ATTACK_TYPE_WEB_SCRAPING                         Web scraping\n   ATTACK_TYPE_DOS_ATTACK_STARTED                   Dos attack started\n   ATTACK_TYPE_MALICIOUS_FILE_UPLOAD                Virus upload\n\n\nSyntax\n\nASM::violation_data\n\n     * Returns the list of violations data","examples":"when ASM_REQUEST_VIOLATION\n{\n    set x [ASM::violation_data]\n\n    foreach i $x {\n      log local0. \"i=$i\"\n    }\n}\n\n\nwhen ASM_REQUEST_VIOLATION\n{\n  set x [ASM::violation_data]\n\n  for {set i 0} { $i < 7 } {incr i} {\n      switch $i {\n      0         { log local0. \"violation=[lindex $x $i]\" }\n      1         { log local0. \"support_id=[lindex $x $i]\" }\n      2         { log local0. \"web_application=[lindex $x $i]\" }\n      3         { log local0. \"severity=[lindex $x $i]\" }\n      4         { log local0. \"source_ip=[lindex $x $i]\" }\n      5         { log local0. \"attack_type=[lindex $x $i]\" }\n      6         { log local0. \"request_status=[lindex $x $i]\" }\n\n   }}\n\nif {([lindex $x 0] contains \"VIOLATION_EVASION_DETECTED\")}\n   {\n      log local0. \"VIOLATION_EVASION_DETECTED detected, uri=[HTTP::uri]\"\n      log local0. \"Decided to sanitize headers\"\n      HTTP::header sanitize\n      HTTP::header insert header_1 value_1\n      ASM::payload replace 0 0 \"1234567890\"\n   } else {\n      log local0. \"violation=[lindex $x 0]\"\n      log local0. \"Decided to route is to different pool\"\n      HTTP::uri /index.php\n      pool phpauction\n   }\n}","returnValue":""},
{"commandName":"ASN1::decode","description":"This command is used to decode ASN.1 records. element specifies the\ndata to decode. It can be either a byte array (like is returned from\nTCP::payload), or an element object returned by one of the other\ncommands. The bytes are decoded according to formatString, and the\nresults are stored in variables whose names are provided as command\narguments. If a variable with a name specified doesn't exist, it will\nbe created in the current scope. If the variable does exist, it's value\nwill be overwritten. The command returns the number of elements\ndecoded. If decoding iteratively, you will likely want to use\nASN1::element next with this returned value to move to the next\nappropriate element for further decoding.\n\n\nformatString can have the following characters:\n  * a - Octet String\n  * B - Bit String\n  * b - Boolean\n  * e - Enum\n  * i - Integer\n  * l - Length of next element\n  * t - Tag of next element\n  * x - Skip Element. No corresponding parameter is specified\n  * ? - Don't output the component if the corresponding value is empty\n  * ?hex-tag - Denotes that the specifier which follows is for an\n    optional component. This is used for encoding or decoding an ASN.1\n    Set or Sequence which contains nested OPTIONAL or DEFAULT\n    components. hex-tag, is a two-character hex byte of the expected\n    tag. When used with the decode command, if the component\n    corresponding to the optional specifier is not found, the\n    corresponding tcl variable will be unset. This allows the iRule to\n    use the Tcl info exists command to test the variable to determine\n    if the component was found. See the following section for more\n    details and examples.\n  * ( - Begin Sequence. No corresponding parameter is specified. The\n    initial sequence tag and length are skipped.\n  * ) - End Sequence. No corresponding parameter is specified.\n  * < - Begin Set. No corresponding parameter is specified. The initial\n    sequence tag and length are skipped.\n  * > - End Set. No corresponding parameter is specified.","examples":"ASN1::decode $ele \"?a?aa?b\" ruleId type matchValue dnAttrs\nif {![info exists ruleId] && ![info exists type]} {\n  log local0. \"ERR: extensibleMatch must contain either a matchingRule or type component\"\n}\n# Handle default value for dnAttributes component\nif {![info exists dnAttrs]} {\n  set dnAttrs 0\n}","returnValue":""},
{"commandName":"ASN1::element","description":"This command returns ASN1.1 record elements.\n\n\nASN1::element init encodingType\n\n     * Returns an element (Tcl_Obj) handle used by the remaining commands.\n       encodingType specifies the encoding type that subsequent commands\n       should use (BER|DER).\n\nASN1::element next element ?numberOfElements?\n\n     * Returns the next element found after element. If numberOfElements\n       is specified, the command will move ahead that many elements,\n       otherwise, the default is 1.\n\nASN1::element byte_offset element ?offset?\n\n     * Returns the byte offset within the payload. This is often useful\n       when using the encode command along with the TCP::payload replace\n       command where a byte offset is used to indicate the location within\n       the payload. If offset is specified, the element offset is set to\n       the specified value. Changing the byte offset is generally\n       discouraged and should be done with caution as it affects the\n       behavior of any other command which takes an element object as an\n       argument.\n\nASN1::element tag element\n\n     * Returns the id (integer) of the leading tag found in element.\n\nASN1::element size element\n\n     * Returns the size (in number of bytes) of the element's full TLV.\n       This is useful for passing to TCP::release.\n\nASN1::element length element ?length?\n\n     * Returns the length (in number of bytes) of the element's value.\n       This is the L coded in the TLV. If length is specified, the length\n       of the element is modified. Changing the byte offset is generally\n       discouraged and should be done with caution as it could affect the\n       behvior of any other command which takes an element object as an\n       argument.","examples":"Optimize LDAP performance allowing reuse of server connections by detaching clients upon client unbind\n\nwhen CLIENT_ACCEPTED {\n  TCP::collect\n}\nwhen CLIENT_DATA {\n set ele [ASN1::element init BER]\n  # Skip ahead two elements and check for an unbind tag (0x62)\n  if { [ASN1::element tag [ASN1::element next $ele 2]] == 0x62 } {\n    log local0. \"unbind =&gt; detach\"\n    TCP::payload replace 0 [TCP::payload length] \"\"\n    LB::detach\n  }\n  TCP::release\n  TCP::collect\n}\n\n\nChange LDAP protocol version upon bindRequest\n\nwhen CLIENT_ACCEPTED {\n  TCP::collect\n}\nwhen CLIENT_DATA {\n  set ldap_msg [ASN1::element init BER]\n  set ele [ASN1::element next $ldap_msg 2]\n  set tag [ASN1::element tag $ele]\n\n  if { $tag == 0x60} {  # bindRequest\n    # Offset of the version number\n    set version_ele [ASN1::element next $ele]\n    set offset [ASN1::element byte_offset $version_ele]\n\n    # Set the version to v2\n    set buf [ASN1::encode BER \"i\" 0x02]\n    set size [ASN1::element size $version_ele]\n\n    # Replace the original version TLV\n    TCP::payload replace $offset $size $buf\n  }\n  TCP::release\n  TCP::collect\n}","returnValue":""},
{"commandName":"ASN1::encode","description":"This command is used to encode ASN.1 records. Data is formatted according to formatString.\n\n\nformatString can have the following characters:\n\n    a - Octet String\n    B - Bit String\n    b - Boolean\n    e - Enum\n    i - Integer\n    t - Tag of next element\n    ? - Don't output the component if the corresponding value is empty\n    ?hex-tag - Denotes that the specifier which follows is for an optional component. This is used for encoding or decoding an ASN.1 Set or Sequence which contains nested OPTIONAL or DEFAULT components. hex-tag, is a two-character hex byte of the expected tag. When used with the decode command, if the component corresponding to the optional specifier is not found, the corresponding tcl variable will be unset. This allows the iRule to use the Tcl info exists command to test the variable to determine if the component was found. See the following section for more details and examples.\n    ( - Begin Sequence. No corresponding parameter is specified. The initial sequence tag and length are skipped.\n    ) - End Sequence. No corresponding parameter is specified.\n    < - Begin Set. No corresponding parameter is specified. The initial sequence tag and length are skipped.\n    > - End Set. No corresponding parameter is specified.\n\nASN1::encode encodingType formatString ?value value ...?\n\n     * Used to encode ASN.1 records. encodingType specifies the encoding\n       type (BER|DER). Data is provided via the listed values and\n       formatted according to formatString. Returns a byte array\n       containing the encoded data.\n\nASN1::encode insert element offset formatString ?value value ...?\n\n     * Insert encoded data at the location specified by element and offset.\n       Prependding can be accomplished by specifying an offset of 0.\n       Returns TCL status.\n\nASN1::encode replace element offset formatString ?value value ...?\n\n     * Replace existing encoded data at the location specified by element and offset.\n       Returns TCL status.","examples":"# LDAP String Modify\nappend base_mod $base \",dc=supercalafragalisticexpialadoshus\"\nASN1::encode replace $ele 1 \"a\" $base_mod\n\n# LDAP Encode/Rewrite - The size field is 4 elements forward from $ele\nASN1::encode replace $ele 4 \"i\" [incr size 2]\n\n# LDAP Encode/Rewrite - The time field is 5 elements forward from $ele\nASN1::encode replace $ele 5 \"i\" [expr $time + 100]\n\n# Encode an LDAP SearchRequest Extensible Match filter where RuleId and Type are optional,\n# matchValue is mandatory and dnAttrs is optional with a default value of FALSE\nif { $dnAttrs == 0 } {\n  # dnAttrs is 0 (False) which is the ASN.1 defined default, so set it to \"\" so it won't be encoded\n  set dnAttrs \"\"\n}\nASN1::encode \"?a?aa?b\" $ruleId $type $matchValue $dnAttrs","returnValue":""},
{"commandName":"AUTH::abort","description":"Cancels any outstanding auth operations in this authentication session,\nand generates an AUTH_FAILURE event if there was an outstanding\nauthentication query in progress. This command invalidates the\nspecified authentication session ID, which should be discarded upon\ncalling this command.\n\n\nAUTH::abort authid\n\n     * Cancels any outstanding auth operations in this authentication\n       session, and generates an AUTH_FAILURE event if there was an\n       outstanding authentication query in progress. This command\n       invalidates the specified authentication session authentication ID,\n       which should be discarded upon calling this command.","examples":"This rule demonstrates one possible implementation of a 2-out-of-3\nauthentication scheme. 3 auth servers are contacted simultaneously. The\nconnection is permitted to proceed as soon as 2 servers report success.\n\nwhen CLIENT_ACCEPTED {\n    set auth_http_successes 0\n    set auth_http_sufficient_successes 2\n}\nwhen HTTP_REQUEST {\n    if {$auth_http_successes >= $auth_http_sufficient_successes} {\n        return\n    }\n\n    set auth_sid [AUTH::start pam default_ldap]\n    set auth_http_sids(ldap) $auth_sid\n    AUTH::username_credential $auth_sid [HTTP::username]\n    AUTH::password_credential $auth_sid [HTTP::password]\n    AUTH::authenticate $auth_sid\n\n    set auth_sid [AUTH::start pam default_radius]\n    set auth_http_sids(radius) $auth_sid\n    AUTH::username_credential $auth_sid [HTTP::username]\n    AUTH::password_credential $auth_sid [HTTP::password]\n    AUTH::authenticate $auth_sid\n\n    set auth_sid [AUTH::start pam default_tacacs]\n    set auth_http_sids(tacacs) $auth_sid\n    AUTH::username_credential $auth_sid [HTTP::username]\n    AUTH::password_credential $auth_sid [HTTP::password]\n    AUTH::authenticate $auth_sid\n\n    HTTP::collect\n    set auth_http_collect_count 3\n}\nwhen AUTH_RESULT {\n    if {[array size auth_http_sids] == 0} {\n        return\n    }\n    set auth_sid [AUTH::last_event_session_id]\n    if {[AUTH::status] == 0} {\n        incr auth_http_successes\n        if {$auth_http_successes >= $auth_http_sufficient_successes} {\n            foreach {type sid} [array get auth_http_sids] {\n                unset auth_http_sids($type)\n                if {$sid != -1} {\n                    AUTH::abort $sid\n                }\n            }\n            set auth_http_collect_count 0\n            HTTP::release\n            return\n        }\n    }\n    foreach {type sid} [array get auth_http_sids] {\n        if {$sid == $auth_sid} {\n            unset auth_http_sids($type)\n            AUTH::abort $sid\n            incr auth_http_collect_count -1\n            if {$auth_http_collect_count == 0} {\n                HTTP::respond 401\n            }\n            break\n        }\n    }\n}","returnValue":""},
{"commandName":"AUTH::authenticate","description":"Performs a new authentication operation. This command returns an error\nif attempted for a standby system or while an authentication operation\nis already in progress for this authentication session.\n\n\nAUTH::authenticate <authid>\n\n     * Performs a new authentication operation. This command returns an\n       error if attempted for a standby system or while an authentication\n       operation is already in progress for this authentication session.","examples":"when HTTP_REQUEST {\n  AUTH::username_credential $auth_id [HTTP::username]\n  AUTH::password_credential $auth_id [HTTP::password]\n  AUTH::authenticate $auth_id\n  HTTP::collect\n}\n\n\nwhen CLIENTSSL_CLIENTCERT {\n  AUTH::cert_credential $tmm_auth_ssl_ocsp_sid [SSL::cert 0]\n  AUTH::cert_issuer_credential $tmm_auth_ssl_ocsp_sid [SSL::cert issuer 0]\n  AUTH::authenticate $tmm_auth_ssl_ocsp_sid\n  SSL::handshake hold\n  set id [SSL::sessionid]\n}","returnValue":""},
{"commandName":"AUTH::authenticate_continue","description":"Continues an authentication operation by providing the specified string\nas the credential response for the most recent authorization prompt.\nThis command is only available when the event AUTH_WANTCREDENTIAL is\nthe most recent event generated, and no AUTH::credential commands have\nbeen issued since the event, for the specified authentication ID.\nUnlike the AUTH::credential commands, the string credential provided by\nthis command does not get cached, even if the desired credential type\nhad been identified (see the AUTH::wantcredential_type command).\nThis command is especially useful in providing authentication services\nto interactive protocols (such as telnet, ftp, and so on), where the\nactual text prompts and responses might be directly communicated with\nthe remote user.\n\n\nAUTH::authenticate_continue <authid> <string>\n\n     * Continues an authentication operation by providing the specified\n       string as the credential response for the most recent authorization\n       prompt.","examples":"The example below is less efficient than the builtin system auth rules,\nand should be considered only a demonstration of\nAUTH::authenticate_continue. The AUTH::authenticate_continue command\nserves limited purpose at this time since as of this writing, the\nauthentication modules present on BIG-IP are primarily\nusername/password based. Since the authentication credential prompts\nare well-known, one can always provide the credentials in advance of\ncalling AUTH::authenticate.\n\nwhen CLIENT_ACCEPTED {\n    set auth_stage 0\n}\nwhen HTTP_REQUEST {\n    if {$auth_stage > 0} {\n        return\n    }\n    set auth_sid [AUTH::start pam some_interactive_pam_auth_service]\n    set http_username [HTTP::username]\n    set http_password [HTTP::password]\n    AUTH::authenticate $auth_sid\n    HTTP::collect\n}\nwhen AUTH_RESULT {\n    set auth_status [AUTH::status]\n    if {$auth_status == 0} {\n        incr auth_stage\n        AUTH::abort $auth_sid\n        HTTP::release\n    } elseif {$auth_status == 2} {\n        set auth_prompt [string tolower [string range [AUTH::wantcredential_prompt $auth_sid] 0 7]]\n        if {($auth_prompt == \"username\") and ($http_username != \"\")} {\n            AUTH::authenticate_continue $auth_sid $http_username\n        } elseif {($auth_prompt == \"password\") and ($http_password != \"\")} {\n            AUTH::authenticate_continue $auth_sid $http_password\n        } else {\n            HTTP::respond 401\n        }\n    } else {\n        HTTP::respond 401\n    }\n}","returnValue":""},
{"commandName":"AUTH::cert_credential","description":"Sets the peer certificate credential to the value of ''' for a\nfuture AUTH::authenticate call. See also the SSL::cert\ncommand. This command returns an error if attempted for a standby\nsystem.\n\n\nAUTH::cert_credential authid <peer certificate>\n\n     * Sets the peer certificate credential to the value of ''' for a\n       future AUTH::authenticate call.","examples":"when CLIENTSSL_CLIENTCERT {\n  set ldap_sid [AUTH::start pam $myprofilename]\n  AUTH::cert_credential $ldap_sid [SSL::cert 0]\n  AUTH::authenticate $ldap_sid\n}","returnValue":""},
{"commandName":"AUTH::cert_issuer_credential","description":"Sets the peer certificate issuer credential to the value of <peer\ncertificate> for a future AUTH::authenticate call. This command\nreturns an error if attempted for a standby system.\n\n\nAUTH::cert_issuer_credential authid <peer certificate>\n\n     * Sets the peer certificate issuer credential to <peer certificate>\n       for a future AUTH::authenticate call.","examples":"when CLIENTSSL_CLIENTCERT {\n  set ldap_sid [AUTH::start pam $myprofilename]\n  AUTH::cert_credential $ldap_sid [SSL::cert 0]\n  AUTH::cert_issuer_credential $ldap_sid [SSL::cert issuer 0]\n  AUTH::authenticate $ldap_sid\n}","returnValue":""},
{"commandName":"AUTH::last_event_session_id","description":"This command returns the session ID of the last auth event, which can\nthen be used to relate to the user behind each session.\n\n\nAUTH::last_event_session_id\n\n     * Returns the session ID of the last auth event","examples":"when AUTH_SUCCESS {\n  if {$auth_id eq [AUTH::last_event_session_id]} {\n    log local0. \"auth success event\"\n    set authorized 1\n  }\n}","returnValue":""},
{"commandName":"AUTH::password_credential","description":"Sets the password credential to the specified string for a future\nAUTH::authenticate call. This command returns an error if\nattempted for a standby system.\n\n\nAUTH::password_credential authid <string>\n\n     * Sets the password credential to the specified string for a future\n       AUTH::authenticate call.","examples":"when HTTP_REQUEST {\n  AUTH::password_credential $auth_id [HTTP::password]\n}","returnValue":""},
{"commandName":"AUTH::response_data","description":"AUTH::response_data returns the a set of name/value query results from\nthe most recent query. This command would normally be called from the\nAUTH_RESULT event. The format of the data returned is suitable for\nsetting as the value of a TCL array.\nAUTH::subscribe must first be called to register interest in query\nresults prior to calling AUTH::authenticate. As a convenience when\nusing the builtin system auth rules, these rules will call\nAUTH::subscribe if the variable tmm_auth_subscription is set. Instead\nof calling AUTH::subscribe directly, we recommend setting\ntmm_auth_subscription to \"\" as a local variable when using the builtin\nsystem auth rules in the interest of forward-compatibility. This can be\ndone in a non- RULE_INIT event like CLIENT_ACCEPTED using\n'set tmm_auth_subscription \"*\"'.\nTypically, response data is only useful if the result of the auth query\nwas success. As of v9.4.0, the following modules provide response data:\n\nLDAP (username/password-based):\n   All name/value pairs from the LDAP query response returned by the\n   server from a successful query, returned in the form of\n   ldap:attr:<name> <value>. Unsuccessful LDAP queries will not return\n   response data.\n\nRADIUS\n   All name/value pairs from the RADIUS query response returned by the\n   server from a successful query, returned in the form of\n   radius:attr:<name> <value>. Unsuccessful RADIUS queries will not return\n   response data.\n\nTACACS\n   All name/value pairs from the TACACS query response returned by the\n   server from a successful query, returned in the form of\n   tacplus:attr:<name> <value>. Unsuccessful TACACS queries will not\n   return response data.\n\nKerberos\n   All name/value pairs from the Kerberos query response returned by the\n   server from a successful query, returned in the form of\n   krbdelegate:attr:<name> <value>. Unsuccessful Kerberos queries will not\n   return response data.\n\nLDAP (client certificate-based):\n   ccldap:reply:status <status>\n   where <status> is one of the following strings (without quotation\n   marks):\n    \"OK\"\n    \"Error (No such user)\"\n    \"Error (Non-unique user (db integrity))\"\n    \"Error (Internal Error)\"\n    \"Error (LDAP Error)\"\n    \"Error (No Certificate Supplied)\"\n    \"Error (Error Accessing Certificate)\"\n    \"Error (User not in required group(s))\"\n    \"Error (User does not have required role(s))\"\n    \"Error (In Deny-All mode)\"\n    \"Error (Error out of range)\"\n\nOCSP (client certificate-based):\n   ocsp:reply:status <status>\n   where <status> is one of the following strings (without quotation\n   marks):\n    \"OK\"\n    \"Error (Could not connect to server)\"\n    \"Error (Unknown client certificate)\"\n   ccldap:reply:username <username>\n   where <username> is the query username corresponding to the BIG-IP 4.x\n   \"set auth hdr enable\" feature.\n\n\nAUTH::response_data [<authid>]\n\n     * Returns the a set of name/value query results from the most recent\n       query.","examples":"Example 1\nThe rule below mimics the behavior of a BIG-IP 4.x authz configuration\n   \"set auth hdr enable\" and \"onfailure username defaultuser\". This rule\nwould be used in conjunction with client certificate LDAP auth.\n\nrule http_insert_cc_ldap_username {\n    when CLIENT_ACCEPTED {\n        set cc_ldap_username \"defaultuser\"\n        set tmm_auth_subscription \"*\"\n    }\n    when AUTH_RESULT {\n        array set auth_response_data [AUTH::response_data]\n        set username [lindex [array get auth_response_data ccldap<!--:reply:username] 1]-->\n        if {username ne \"\"} {\n            set cc_ldap_username $username\n        }\n    }\n    when HTTP_REQUEST {\n        HTTP::header insert \"Authorization: [b64encode $cc_ldap_username:password]\"\n    }\n}\n\nSimilar rule logic to the above example would be used with this data to\nmimic the 4.x authz configuration \"insert client status enable\".\nExample 2\nThe rule below demonstrates how group membership might be used to\ninfluence a load balancing decision. This rule would be used in\nconjunction with username/password LDAP auth.\n\nrule http_lb_ldap_group {\n    when CLIENT_ACCEPTED {\n        set tmm_auth_subscription \"*\"\n    }\n    when AUTH_RESULT {\n        array set auth_response_data [AUTH::response_data]\n        set ldap_group [lindex [array get auth_response_data ldap<!--:attr:isMemberOf] 1]-->\n        if {ldap_group eq \"admin\"} {\n            use pool admin_pool\n        }\n    }\n}\n\nExample 3\nThe rule below demonstrates how multi-pass auth might be performed.\nAdditional error checking of the group name would be necessary in a\nproduction-ready rule.\n\nrule multi_pass_auth {\n    when HTTP_REQUEST {\n        if {not [info exists auth_pass]} {\n            set auth_sid [AUTH::start pam auth_method_user]\n            AUTH::subscribe $auth_sid\n            set auth_username [HTTP::username]\n            set auth_password [HTTP::password]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::authenticate $auth_sid\n            set auth_pass 1\n        }\n    }\n    when AUTH_RESULT {\n        if {[AUTH::status] != 1} {\n            if {$auth_pass == 1} {\n                HTTP::respond 401\n            } else {\n                reject\n            }\n        }\n        if {$auth_pass == 1} {\n            array set auth_response_data [AUTH::response_data]\n            set auth_group [lindex [array get auth_response_data ldap<!--:attr:isMemberOf] 1]-->\n            AUTH::abort $auth_sid\n            set auth_sid [AUTH::start pam $auth_group]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::unsubscribe $auth_sid\n            AUTH::authenticate $auth_sid\n            set auth_pass 2\n        } else {\n            HTTP::release\n            set auth_pass 3\n        }\n    }\n}\n\nExample 4\nThe rule below demonstrates how to grant access based on a combination\nof source network and LDAP group membership. This rule would need to be\nused in conjunction with an LDAP auth profile.\n\nrule ldap_auth_by_net_and_group {\nwhen RULE_INIT {\n      array set ::auth_conf {\n         {default_mask}       {255.0.0.0}\n         {group_attribute}    {ldap<!--:attr:isMemberOf}-->\n      }\n      array set ::auth_class {\n         {10.0.0.0}        {Marketing Sales}\n         {20.0.0.0}        {Engineers Developers}\n         {30.0.0.0}        {Engineers}\n      }\n   }\nwhen CLIENT_ACCEPTED {\n      set tmm_auth_subscription \"*\"\n      set auth_client_addr [IP::addr [IP::client_addr] mask $::auth_conf(default_mask)]\n   }\nwhen AUTH_RESULT {\n      if { [AUTH::status] != 0 } {\n         HTTP::respond 401\n         return\n      }\n      if { not [info exists ::auth_class($auth_client_addr)] } {\n         HTTP::respond 401\n         return\n      }\n      array set auth_data [AUTH::response_data]\n\n      foreach group $::auth_class($auth_client_addr) {\n         if { $auth_data($::auth_conf(group_attribute)) eq $group } {\n            use pool validated\n         }\n      }\n      HTTP::respond 401\n   }\n}","returnValue":""},
{"commandName":"AUTH::ssl_cc_ldap_status","description":"Returns the status from the last successful client certificate-based\nLDAP query for the specified authorization session <authid>. The system\nreturns an empty string if the last successful query did not perform a\nclient certificate-based LDAP query, or if no query has yet been\nperformed. This command has been deprecated in favor of\nAUTH::response_data.\n\n\nAUTH::ssl_cc_ldap_status <authid>\n\n     * Returns the status from the last successful client\n       certificate-based LDAP query for the specified authorization\n       session <authid>.","examples":"The rule below mimics the behavior of a BIG-IP 4.x authz configuration\n   \"insert client status enable\". This rule would be used in conjunction\nwith client certificate LDAP auth.\n\nwhen RULE_INIT {\n    set tmm_auth_subscription \"*\"\n}\nwhen AUTH_RESULT {\n    array set auth_response_data [AUTH::response_data]\n    # set cc_ldap_status [AUTH::ssl_cc_ldap_status]\n    set cc_ldap_status [lindex [array get auth_response_data ccldap<!--:reply:status] 1]-->\n}\nwhen HTTP_REQUEST {\n    HTTP::header insert \"SSLClientAuthorizationStatus: $cc_ldap_status\"\n}","returnValue":""},
{"commandName":"AUTH::ssl_cc_ldap_username","description":"Returns the user name that the system retrieved from the LDAP database\nfrom the last successful client certificate-based LDAP query for the\nspecified authorization session <authid>. The system returns an empty\nstring if the last successful query did not perform a successful client\ncertificate-based LDAP query, or if no query has yet been performed.\nThis command has been deprecated in favor of AUTH::response_data.\n\n\nAUTH::ssl_cc_ldap_username <authid>\n\n     * Returns the user name that the system retrieved from the LDAP\n       database from the last successful client certificate-based LDAP\n       query for the specified authorization session <authid>.","examples":"The rule below mimics the behavior of a BIG-IP 4.x authz configuration\n   \"set auth hdr enable\" and \"onfailure username defaultuser\". This rule\nwould be used in conjunction with client certificate LDAP auth.\n\nwhen RULE_INIT {\n    set cc_ldap_username \"defaultuser\"\n    set tmm_auth_subscription \"*\"\n}\nwhen AUTH_RESULT {\n    array set auth_response_data [AUTH::response_data]\n    # set username [AUTH::ssl_cc_ldap_username]\n    set username [lindex [array get auth_response_data ccldap<!--:reply:username] 1]-->\n    if {username ne \"\"} {\n        set cc_ldap_username $username\n    }\n}\nwhen HTTP_REQUEST {\n    HTTP::header insert \"Authorization: [b64encode $cc_ldap_username:password]\"\n}\n\nSimilar rule logic to the above example would be used with this data to\nmimic the 4.x authz configuration \"insert client status enable\".","returnValue":""},
{"commandName":"AUTH::start","description":"Initializes an authentication session. This command returns the\nauthentication session ID, which must be specified to other\nauthentication commands. Multiple simultaneous authentication sessions\n(up to 10) can be opened for a single connection, but it is the user’s\nresponsibility to keep track of their respective session IDs. This\ncommand returns an error if attempted for a standby system.\n\n\nAUTH::start <type> <PAM service>\n\n     * Returns the authentication session ID, which must be specified to\n       other authentication commands. The value pam is currently the only\n       supported value for <type>. The value of <PAM_service> must be the\n       name of the PAM service from which to apply authorization settings.","examples":"when CLIENT_ACCEPTED {\n  set auth_id [AUTH::start pam default_radius]\n}","returnValue":""},
{"commandName":"AUTH::status","description":"Returns authentication status. The returned status is a value of 0, 1,\n-1, or 2, corresponding to success, failure, error, or not-authed,\nbased on the result of the most recent authorization that the system\nperformed for the specified authorization session .\nIn the case of a not-authed result, the authentication process desires\na credential not yet provided. Specifics of the requested credential\ncan be determined using the AUTH::wantcredential_ commands. The\nauthentication process could be continued using\nAUTH::authenticate_continue*.\n\n\nAUTH::status <authid>\n\n     * Returns authentication status. The returned status is a value of 0,\n       1, -1, or 2, corresponding to success, failure, error, or\n       not-authed, based on the result of the most recent authorization\n       that the system performed for the specified authorization session\n       <authid>.","examples":"when HTTP_RESPONSE {\n  set authStatus [AUTH::status $authSessionId]\n}","returnValue":""},
{"commandName":"AUTH::subscribe","description":"AUTH::subscribe registers interest in auth query results.\nAUTH::response_data will only return data from query results for\nwhich a subscription has been made prior to calling\nAUTH::authenticate. As a convenience when using the built-in\nsystem auth rules, these rules will call AUTH::subscribe if the\nvariable tmm_auth_subscription is set. Instead of calling\nAUTH::subscribe directly, we recommend setting tmm_auth_subscription to\n\"*\" when using the built-in system auth rules in the interest of\nforward-compatibility. Also see AUTH::unsubscribe.\n\n\nAUTH::subscribe <authid>\n\n     * Registers interest in auth query results.","examples":"The rule below demonstrates how multi-pass auth might be performed.\nAdditional error checking of the group name would be necessary in a\nproduction-ready rule.\n\nrule multi_pass_auth {\n    when HTTP_REQUEST {\n        if {not [info exists auth_pass]} {\n            set auth_sid [AUTH::start pam auth_method_user]\n            AUTH::subscribe $auth_sid\n            set auth_username [HTTP::username]\n            set auth_password [HTTP::password]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::authenticate $auth_sid\n            set auth_pass 1\n        }\n    }\n    when AUTH_RESULT {\n        if {[AUTH::status] != 1} {\n            if {$auth_pass == 1} {\n                HTTP::respond 401\n            } else {\n                reject\n            }\n        }\n        if {$auth_pass == 1} {\n            array set auth_response_data [AUTH::response_data]\n            set auth_group [lindex [array get auth_response_data ldap<!--:attr:isMemberOf] 1]-->\n            AUTH::abort $auth_sid\n            set auth_sid [AUTH::start pam $auth_group]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::unsubscribe $auth_sid\n            AUTH::authenticate $auth_sid\n            set auth_pass 2\n        } else {\n            HTTP::release\n            set auth_pass 3\n        }\n    }\n}","returnValue":""},
{"commandName":"AUTH::unsubscribe","description":"AUTH::unsubscribe cancels interest in auth query results.\nAUTH::response_data will not return data from query results for\nwhich a subscription has been cancelled before AUTH::authenticate\nhas been called. Also see AUTH::subscribe.\n\n\nAUTH::unsubscribe <authid>\n\n     * Cancels interest in auth query results.","examples":"The rule below demonstrates how multi-pass auth might be performed.\nAdditional error checking of the group name would be necessary in a\nproduction-ready rule.\n\nrule multi_pass_auth {\n    when HTTP_REQUEST {\n        if {not [info exists auth_pass]} {\n            set auth_sid [AUTH::start pam auth_method_user]\n            AUTH::subscribe $auth_sid\n            set auth_username [HTTP::username]\n            set auth_password [HTTP::password]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::authenticate $auth_sid\n            set auth_pass 1\n        }\n    }\n    when AUTH_RESULT {\n        if {[AUTH::status] != 1} {\n            if {$auth_pass == 1} {\n                HTTP::respond 401\n            } else {\n                reject\n            }\n        }\n        if {$auth_pass == 1} {\n            array set auth_response_data [AUTH::response_data]\n            set auth_group [lindex [array get auth_response_data ldap<!--:attr:isMemberOf] 1]-->\n            AUTH::abort $auth_sid\n            set auth_sid [AUTH::start pam $auth_group]\n            AUTH::username_credential $auth_sid $auth_username\n            AUTH::password_credential $auth_sid $auth_password\n            AUTH::unsubscribe $auth_sid\n            AUTH::authenticate $auth_sid\n            set auth_pass 2\n        } else {\n            HTTP::release\n            set auth_pass 3\n        }\n    }\n}","returnValue":""},
{"commandName":"AUTH::username_credential","description":"Sets the username credential to the specified string, for a future\nAUTH::authenticate call. This command returns an error if\nattempted for a standby system.\n\n\nAUTH::username_credential authid <string>\n\n     * Sets the username credential to the specified string, for a future\n       AUTH::authenticate call.","examples":"when HTTP_REQUEST {\n  AUTH::username_credential $asid [HTTP::username]\n}","returnValue":""},
{"commandName":"AUTH::wantcredential_prompt","description":"Returns the authorization session authid’s credential prompt string\nthat the system last requested (when the system generated an\nAUTH_WANTCREDENTIAL event). An example of a promopt string is\nUsername:. The AUTH::wantcredential_prompt command is especially\nhelpful in providing authentication services to interactive protocols\n(for example, telnet and ftp), where the actual text prompts and\nresponses may be directly communicated with the remote user.\n\n\nAUTH::wantcredential_prompt <authid>\n\n     * Returns the specified authorization session authid’s credential\n       prompt string that the system last requested (when the system\n       generated an AUTH_WANTCREDENTIAL event). An example of a prompt\n       string is Username:*.","examples":"when AUTH_WANTCREDENTIAL {\n  HTTP::respond 401 \"WWW-Authenticate\" \"Basic realm=\\\"\\\"\"\n}\nwhen AUTH_FAILURE {\n  log local0. \"Auth failed: \\\n       Auth type was \\\"[AUTH::wantcredential_type $authid]\\\" \\\n       Auth prompt was \\\"[AUTH::wantcredential_prompt $authid]\\\"\\\n       Auth prompt style was \\\"[AUTH::wantcredential_prompt_style $authid]\\\"\\\n\"\n}","returnValue":""},
{"commandName":"AUTH::wantcredential_prompt_style","description":"Returns the authorization session authid’s credential prompt style that\nthe system last requested (when the system generated an\nAUTH_WANTCREDENTIAL event). The value of the <authid> argument is\neither echo_on, echo_off, or unknown. This command is especially\nhelpful in providing authentication services to interactive protocols\n(or example, telnet and ftp), where the actual text prompts and\nresponses may be directly communicated with the remote user.\n\n\nAUTH::wantcredential_prompt_style <authid>\n\n     * Returns the authorization session authid’s credential prompt style\n       that the system last requested (when the system generated an\n       AUTH_WANTCREDENTIAL event). The value of the <authid> argument is\n       either echo_on, echo_off, or unknown*.","examples":"when AUTH_WANTCREDENTIAL {\n  HTTP::respond 401 \"WWW-Authenticate\" \"Basic realm=\\\"\\\"\"\n}\nwhen AUTH_FAILURE {\n  log local0. \"Auth failed: \\\n       Auth type was \\\"[AUTH::wantcredential_type $authid]\\\" \\\n       Auth prompt was \\\"[AUTH::wantcredential_prompt $authid]\\\"\\\n       Auth prompt style was \\\"[AUTH::wantcredential_prompt_style $authid]\\\"\\\n\"\n}","returnValue":""},
{"commandName":"AUTH::wantcredential_type","description":"Returns the authorization session authid’s credential type that the\nsystem last requested (when the system generated an AUTH_WANTCREDENTIAL\nevent). The value of the <authid> argument is either username,\npassword, x509, x509_issuer, or unknown, based upon the system’s\nassessment of the credential prompt string and style.\n\n\nAUTH::wantcredential_type <authid>\n\n     * Returns the authorization session authid’s credential type that the\n       system last requested (when the system generated an\n       AUTH_WANTCREDENTIAL event). The value of the <authid> argument is\n       either username, password, x509, x509_issuer, or unknown*.","examples":"when AUTH_WANTCREDENTIAL {\n  HTTP::respond 401 \"WWW-Authenticate\" \"Basic realm=\\\"\\\"\"\n}\nwhen AUTH_FAILURE {\n  log local0. \"Auth failed: \\\n       Auth type was \\\"[AUTH::wantcredential_type $authid]\\\" \\\n       Auth prompt was \\\"[AUTH::wantcredential_prompt $authid]\\\"\\\n       Auth prompt style was \\\"[AUTH::wantcredential_prompt_style $authid]\\\"\\\n\"\n}","returnValue":""},
{"commandName":"AVR::disable","description":"Disables the AVR plugin for the current connection. AVR will remain\ndisabled on the current connection until it is closed or\nAVR::enable is called. This means that the connection will not be\ncounted by AVR and thus excluded from statistics gathering.\n\nSyntax\n\nAVR::disable","examples":"","returnValue":""},
{"commandName":"AVR::disable_cspm_injection","description":"The CSPM (Client Side Performance Monitoring) feature injects JavaScript into HTTP responses to track the Page Load Time metric. This command disables CSPM JavaScropt injection.\n\nSyntax\n\nAVR::disable_cspm_injection","examples":"To make decisons based on request headers use event AVR_CSPM_INJECTION\n\nwhen AVR_CSPM_INJECTION {\n    if { [HTTP::header \"User-Agent\"] contains \"MSIE\" } {\n        AVR::disable_cspm_injection\n    }\n}\n\nTo make decisions based on response headers use HTTP_RESPONSE\n\nwhen HTTP_RESPONSE {\n    if { [HTTP::status] == 404 } {\n        AVR::disable_cspm_injection\n    }\n}","returnValue":""},
{"commandName":"AVR::enable","description":"Enables the AVR plugin for the current connection. AVR will remain\nenabled on the current connection until it is closed or\nAVR::disable is called.\n\nNote that enabling AVR alone within the iRule only ensures the\nmessage reaches the AVR plugin, it doesn't ensure that statistics\nwill be gathered.\n\nSyntax\n\nAVR::enable","examples":"","returnValue":""},
{},
{"commandName":"BIGPROTO::enable_fix_reset","description":"When set to disabled, TCP RST frame will not be sent when BIG-IP detects there is a hash collision on ePVA offloading of FIX flows. Instead, it will try to re-offload the connection.","examples":"when CLIENT_ACCEPTED {\n    BIGPROTO::enable_fix_reset true\n    BIGPROTO::enable_fix_reset false\n            }","returnValue":"none"},
{"commandName":"BIGTCP::release_flow","description":"This command releases a flow from BIGTCP's control. After calling this method, the flow will be in passthrough mode.  In this mode, no more data will be processed by any filters or iRules.","examples":"when CLIENT_ACCEPTED {\n    BIGTCP::release_flow;\n}","returnValue":""},
{"commandName":"BOTDEFENSE::disable","description":"Disables processing and blocking of the request by Bot Defense, for the duration of the current TCP connection, or until BOTDEFENSE::enable is called.\n\nSyntax\n\nBOTDEFENSE::disable","examples":"# EXAMPLE: Disabling Bot Defense for a netmask of client IP addresses\nwhen CLIENT_ACCEPTED {\n    if {[IP::addr [IP::client_addr] equals 10.10.10.0/24]} {\n        BOTDEFENSE::disable\n    }\n}","returnValue":""},
{"commandName":"BOTDEFENSE::enable","description":"Enables processing and blocking of the request by Bot Defense, for the duration of the current TCP connection, or until BOTDEFENSE::disable is called.\n\nSyntax\n\nBOTDEFENSE::enable","examples":"# EXAMPLE: Re-enable Bot Defense on the connection if a request arrives with a certain URL prefix.\nwhen HTTP_REQUEST {\n    if {[HTTP::uri] starts_with \"/t/\"} {\n        BOTDEFENSE::enable\n    }\n}","returnValue":""},
{"commandName":"BOTDEFENSE::cs_possible","description":"Returns \"true\" or \"false\" based on whether it is possible to take one of the client-side actions (browser challenge, or CAPTCHA challenge). Certain characteristics of a request makes it impossible to respond with a browser or CAPTCHA challenge, in which case \"false\" is returned.\n\nSetting to a client-side action with BOTDEFENSE::action, while the value of BOTDEFENSE::cs_possible is \"false\", will fail.\n\nSyntax\n\nBOTDEFENSE::cs_possible","examples":"# EXAMPLE: Prevent blocking of requests that cannot be responded with a\n# client-side challenge.\nwhen BOTDEFENSE_ACTION {\n    if {    ([BOTDEFENSE::action] eq \"tcp_rst\") &&\n            (not [BOTDEFENSE::cs_possible])} {\n        BOTDEFENSE::action allow\n    }\n}","returnValue":"Returns a boolean value (0 or 1), whether taking a client-side action is possible."},
{"commandName":"BOTDEFENSE::cs_allowed","description":"Returns or sets if the client-side actions (browser challenge or CAPTCHA challenge) are allowed on this request. By default, only requests to URLs which are detected as HTML URLs are cs_allowed, but this command can override this detection. Bot Defense uses this variable when deciding on the action to take, so, setting it before the BOTDEFENSE_ACTION event may affect the action taken by Bot Defense.\n\nWhen forcing an action using the BOTDEFENSE::action command, the cs_allowed value is ignored. That is, it is possible to force a client-side action even if cs_allowed is \"false\". The cs_allowed value only affects the default decision made by Bot Defense, before the BOTDEFENSE_ACTION event is raised.\n\nSyntax\n\nBOTDEFENSE::cs_allowed\n\n    * Returns a boolean value whether it is allowed for Bot Defense to take a client-side action.\n\n    * Calling the command without any arguments is only allowed from the BOTDEFENSE_REQUEST event or the BOTDEFENSE_ACTION event. Calling this command without any arguments from any other event will result in a runtime TCL exception.\n\nBOTDEFENSE::cs_allowed <value>\n\n    * Allows or disallows Bot Defense to take a client-side action on the request. The <value> is a boolean, which accepts any of the following formats:\n        + 0 / 1\n        + false / true\n        + disable / enable\n        + disabled / enabled\n        + no / yes\n\n    * Normally, overriding the cs_allowed value, would be done from either the HTTP_REQUEST or the BOTDEFENSE_REQUEST events. It is, however, allowed on any event. Overriding the value from the BOTDEFENSE_ACTION event will have no effect, because the Bot Defense already decided on the default action.\n\n    * If this command is called with a \"true\" argument, while the value of BOTDEFENSE::cs_possible is \"false\", the command will be ignored, and the value of BOTDEFENSE::cs_allowed will remain \"false\".","examples":"# EXAMPLE: Always allow client-side actions to be taken on URLs with the .html extension.\nwhen BOTDEFENSE_REQUEST {\n    if {[HTTP::uri] ends_with \".html\"} {\n        BOTDEFENSE::cs_allowed true\n    }\n}","returnValue":"* When called without any arguments: Returns whether a client-side action is allowed to be taken by Bot Defense. If the value was overridden, the returned value is the overridden one.\n    * When called with an argument for overriding the value of cs_allowed, no value is returned."},
{"commandName":"BOTDEFENSE::cs_attribute","description":"Queries for or sets attributes for the client-side challenge. These attributes are only effective if a client-side action is taken on the current request. Otherwise, these attributes are silently ignored.\n\nSyntax\n\nBOTDEFENSE::cs_attribute device_id [enable | disable]\n\n    * Sets or gets the value of the \"device_id\" attribute. When enabled, the client-side challenge will collect data from the client and attempt to retrieve the device_id.","examples":"# EXAMPLE: Make sure that the data for the device_id is always collected when taking a client-side action.\nwhen BOTDEFENSE_REQUEST {\n    BOTDEFENSE::cs_attribute device_id enable\n}","returnValue":"* When called without any arguments, returns the value of the requested attribute.\n    * When called with an argument, the requested attribute is overridden, and no value is returned."},
{"commandName":"BOTDEFENSE::cookie_status","description":"Returns the status of the Bot Defense cookie that is received on the request. The returned value is one of the following strings:\n    * not_received - the cookie did not appear in the request\n    * valid - the cookie is valid and not expired\n    * invalid - the cookie cannot be parsed; this could mean that it was modified by an attacker, or that it is older than two days, or due to a configuration change\n    * expired - the cookie is valid, but is expired\n    * valid_redirect_challenge - the cookie of the redirect was validated\n\nSyntax\n\nBOTDEFENSE::cookie_status","examples":"# EXAMPLE: In case of an invalid cookie, send a message to High Speed Logging\nwhen BOTDEFENSE_REQUEST {\n    if {[BOTDEFENSE::cookie_status] eq \"invalid\"} {\n        HSL::send $hsl \"invalid botdefense cookie from IP [IP::client_addr]\"\n    }\n}","returnValue":"A string signifying the status of the Bot Defense cookie."},
{"commandName":"BOTDEFENSE::client_type","description":"Returns the client type. The returned value is one of the following strings:\n    * bot - if the client was detected as a bot.\n    * mobile_app - if the client is a mobile app using F5 Anti Bot mobile  SDK.\n    * browser - if the client is a Web browser.\n    * uncategorized - if the client type could not be determined.\n\nSyntax\n\nBOTDEFENSE::client_type","examples":"# EXAMPLE: Redirect bots to a honeypot page\n when BOTDEFENSE_ACTION {\n     if {[BOTDEFENSE::client_type] eq \"bot\"} {\n         set log \"Request from a Bot on \"\n         append log \"IP [IP::client_addr]\"\n         HSL::send $hsl $log\n         HTTP::redirect \"https://www.example.com/honeypot.html\"\n      }\n }","returnValue":"A string signifying the client type."},
{"commandName":"BOTDEFENSE::cookie_age","description":"Returns the age of the Bot Defense cookie in seconds. This is only relevant if the value of BOTDEFENSE::cookie_status is either \"valid\" or \"expired\"; otherwise, -1 is returned.\n\nSyntax\n\nBOTDEFENSE::cookie_age","examples":"# EXAMPLE: In case of an expired cookie, log the age of the cookie\nwhen BOTDEFENSE_REQUEST {\n    if {[BOTDEFENSE::cookie_status] eq \"expired\"} {\n        set log \"expired botdefense cookie (from [BOTDEFENSE::cookie_age]\"\n        append log \" seconds ago) from IP [IP::client_addr]\"\n        HSL::send $hsl $log\n    }\n}","returnValue":"Returns the age of the Bot Defense cookie in seconds, or -1 if not applicable."},
{"commandName":"BOTDEFENSE::device_id","description":"Returns a number, representing the Device ID of the client, as retrieved from the request. If the Device ID is unknown, 0 is returned. By default, the Device ID is collected from the client, if it is enabled in the configuration. However, this can be overridden using the BOTDEFENSE::cs_attribute command.\n\nSyntax\n\nBOTDEFENSE::device_id","examples":"# EXAMPLE: Log the Device ID of the client, upon each request, if it is known.\nwhen BOTDEFENSE_REQUEST {\n    if {[BOTDEFENSE::device_id] != 0} {\n        set log \"botdefense device_id of client IP [IP::client_addr] is\"\n        append log \" [BOTDEFENSE::device_id]\"\n        HSL::send $hsl $log\n    }\n}","returnValue":"Returns the Device ID of the client, or 0 if the Device ID is unknown."},
{"commandName":"BOTDEFENSE::support_id","description":"Returns a number, representing the support ID of the request.\n\nSyntax\n\nBOTDEFENSE::support_id","examples":"# EXAMPLE: Log the support ID of the request.\nwhen BOTDEFENSE_REQUEST {\n    set log \"support id is\"\n    append log \" [BOTDEFENSE::support_id]\"\n    HSL::send $hsl $log\n}","returnValue":"Returns the support ID of the reuqest."},
{"commandName":"BOTDEFENSE::previous_action","description":"Returns the action taken by the previous request; this is applicable if the current request is a follow-up to a challenge.\n\n\nSyntax\n\nBOTDEFENSE::previous_action","examples":"# EXAMPLE: Log the previous action.\nwhen BOTDEFENSE_REQUEST {\n    set log \"botdefense previous action is\"\n    append log \" [BOTDEFENSE::previous_action]\"\n    HSL::send $hsl $log\n}","returnValue":"The values are the same values as in the BOTDEFENSE::action command, or the value \"undetermined\" if this is not a follow-up to a challenge."},
{"commandName":"BOTDEFENSE::previous_support_id","description":"Returns the Support ID of the previous request; this is applicable if the current request is a follow-up to a challenge. Otherwise, \"0\" is returned.\n\nSyntax\n\nBOTDEFENSE::previous_support_id","examples":"# EXAMPLE: Log the Support ID of the previous request.\nwhen BOTDEFENSE_REQUEST {\n    set log \"botdefense previous support ID is\"\n    append log \" [BOTDEFENSE::previous_support_id]\"\n    HSL::send $hsl $log\n}","returnValue":"Returns the support ID of the previous request, or 0 if not applicable."},
{"commandName":"BOTDEFENSE::previous_request_age","description":"Returns the number of seconds that passed since the previous request was received; this is applicable if the current request is a follow-up to a challenge. Otherwise, \"0\" is returned\n\nSyntax\n\nBOTDEFENSE::previous_request_age","examples":"# EXAMPLE: Log the previous request age.\nwhen BOTDEFENSE_REQUEST {\n    if {[BOTDEFENSE::previous_request_age] != 0} {\n        set log \"botdefense previous request age is\"\n        append log \" [BOTDEFENSE::previous_request_age]\"\n        HSL::send $hsl $log\n    }\n}","returnValue":"Returns the number of seconds that passed since the previous request was received or 0 if not applicable."},
{"commandName":"BOTDEFENSE::bot_signature","description":"Returns the name of the detected Bot Signature, or an empty string if no bot signature was detected.\n\nSyntax\n\nBOTDEFENSE::bot_signature","examples":"# EXAMPLE: Log the bot signature.\nwhen BOTDEFENSE_REQUEST {\n    set log \"botdefense bot_signature is\"\n    append log \" [BOTDEFENSE::bot_signature]\"\n    HSL::send $hsl $log\n}","returnValue":"Returns the name of the detected Bot Signature, or an empty string if no bot signature was detected."},
{"commandName":"BOTDEFENSE::bot_signature_category","description":"Returns the name of the detected Bot Signature Category, or an empty string if no bot signature was detected.\n\nSyntax\n\nBOTDEFENSE::bot_signature_category","examples":"# EXAMPLE: Log the bot signature category.\nwhen BOTDEFENSE_REQUEST {\n    set log \"botdefense bot_signature_category is\"\n    append log \" [BOTDEFENSE::bot_signature_category]\"\n    HSL::send $hsl $log\n}","returnValue":"Returns the name of the detected Bot Signature Category, or an empty string if no bot signature was detected."},
{"commandName":"BOTDEFENSE::captcha_status","description":"Returns the status of the user's answer to the CAPTCHA challenge. The returned value is one of the following strings:\n    * not_received - the answer to the CAPTCHA challenge did not appear in the request; this is the normal result, before the CAPTCHA challenge is sent to the client\n    * correct - the answer is correct\n    * incorrect - the answer is incorrect\n    * empty - an empty answer was given, or if the user clicked on the CAPTCHA Refresh button\n    * expired - the answer has expired; in this case, the answer is not validated and may be correct or incorrect\n    * invalid - the cookie containing the CAPTCHA answer cannot be parsed; this could mean that it was modified by an attacker, or that it is older than two days, or due to a configuration change\n\nSyntax\n\nBOTDEFENSE::captcha_status","examples":"# EXAMPLE: Send a CAPTCHA challenge on the login page, and only allow the\n# login if the user passed the CAPTCHA challenge\nwhen BOTDEFENSE_ACTION {\n    if {[BOTDEFENSE::action] eq \"allow\"} {\n        if {[BOTDEFENSE::captcha_status] ne \"correct\"} {\n            if {[HTTP::uri] eq \"/t/login.php\"} {\n                set res [BOTDEFENSE::action captcha_challenge]\n                if {$res ne \"ok\"} {\n                    log local0. \"cannot send captcha_challenge: \\\"$res\\\"\"\n                    BOTDEFENSE::action tcp_rst\n                }\n            } elseif {[HTTP::uri] eq \"/t/do_login.php\"} {\n                set res [BOTDEFENSE::action custom_response {\n                    login failed because you may not be human\n                }]\n                if {$res ne \"ok\"} {\n                    log local0. \"cannot send blocking page: \\\"$res\\\"\"\n                    BOTDEFENSE::action tcp_rst\n                }\n            }\n        }\n    }\n}","returnValue":"Returns a string signifying the status of the CAPTCHA challenge."},
{"commandName":"BOTDEFENSE::captcha_age","description":"Returns the age of the CAPTCHA challenge in seconds. This is only relevant if the value of BOTDEFENSE::captcha_status is \"correct\"; otherwise, -1 is returned.\n\nSyntax\n\nBOTDEFENSE::captcha_age","examples":"# EXAMPLE: Send CAPTCHA challenge and validate the response, but to avoid\n# blocking requests to which CAPTCHA challenge cannot be sent (non-HTML pages),\n# send the CAPTCHA challenge on HTML pages after 30 seconds of aging, which is\n# before the expiration of the answer.\nwhen BOTDEFENSE_ACTION {\n    if {[BOTDEFENSE::action] eq \"allow\"} {\n        if {[BOTDEFENSE::captcha_status] eq \"correct\"} {\n            if {    ([BOTDEFENSE::cs_allowed]) &&\n                    ([BOTDEFENSE::captcha_age] >= 30)} {\n                BOTDEFENSE::action captcha_challenge\n            }\n        } else {\n            if {[BOTDEFENSE::action captcha_challenge] ne \"ok\"} {\n                if {[BOTDEFENSE::action custom_response {\n                    login failed because you may not be human\n                }] ne \"ok\"} {\n                    BOTDEFENSE::action tcp_rst\n                }\n            }\n        }\n    }\n}","returnValue":"Returns the age of the CAPTCHA challenge in seconds, or -1 if not applicable."},
{"commandName":"BOTDEFENSE::action","description":"Returns or overrides the action to be taken by Bot Defense.\n\nOverriding the action may fail on certain cases. For example, overriding to the \"browser_challenge\" action, may only be done on requests to which the value of BOTDEFENSE::cs_possible is \"true\". When overriding the action, the command returns \"ok\" if the action was successfully set. Otherwise, the action is not changed, and the reason for failure is returned.\n\nAfter a successful action override (resulting in the \"ok\" string), the action cannot be overridden again. Attempting to override the action after it was successfully overridden will fail, and the \"already forced by irule\" string will be returned.\n\nSyntax\n\nBOTDEFENSE::action\n\n    * Returns the action to be taken by Bot Defense: how the received HTTP request is handled. The returned value is one of the following strings:\n        + undetermined - the action has not yet been determined; this should only be returned upon an error\n        + allow - the HTTP request is allowed to go up the chain\n        + browser_challenge - a browser challenge (HTML + JavaScript) is to be responded to the client\n        + captcha_challenge - a CAPTCHA challenge is to be responded to the client\n        + redirect_challenge - a redirection challenge (307 redirect) is to be responded to the client\n        + tcp_rst - the TCP connection is to be closed using TCP RST\n        + redirect_to_referring_domain - a 307 redirect response is to be sent to the client, redirecting it to the referring domain\n        + internal_bigip_response - a response is to be sent to the client, without forwarding the HTTP request up the chain; the response is an internal part of the Bot Defense mechanism\n        + redirect_with_cookie - a 307 redirect response is to be sent to the client, and this response is an internal port of the Bot Defense mechanism\n        + custom_response - a custom response is to be sent to the client\n        + custom_redirect - a custom redirect response is to be sent to the client\n\nBOTDEFENSE::action allow\n\n    * Allows the request to go up the chain\n\nBOTDEFENSE::action browser_challenge\n\n    * Responds to the client with a browser challenge (HTML + JavaScript).\n\nBOTDEFENSE::action captcha_challenge\n\n    * Responds to the client with a CAPTCHA challenge.\n\n    * Note that although Bot Defense will send the CAPTCHA challenge screen back to the user, the enforcement is not always done automatically. To enforce the correct CAPTCHA response, the BOTDEFENSE::captcha_status command should be used.\n\n    * Also note that this action may bypass the default Bot Defense challenge and validation, and this may cause other requests to be blocked in some cases. Therefore, it is recommended to first check the action, and only use the CAPTCHA challenge if the default action is \"allow\". That is, use the CAPTCHA as a secondary validation stage, the first being the default browser challenge. See the example in the BOTDEFENSE::captcha_status and BOTDEFENSE::captcha_age commands.\n\nBOTDEFENSE::action redirect_challenge\n\n    * Responds to the client with the Bot Defense \"redirect challenge\", which\n    * is a method of challenging bots that does not require JavaScript.\n\nBOTDEFENSE::action tcp_rst\n\n    * Aborts the transaction (closes the TCP connection) by sending a TCP RST message to the client.\n\nBOTDEFENSE::action custom_response <content> [<http-status-code>]\n\n    * Responds to the client with a custom HTTP response.\n    * This is normally used to send a blocking page to the client, instead of aborting the connection.\n    * The <content> is the payload of the HTTP response, and me be given between double-quotes \"\", or braces {}.\n    * The <http-status-code> is 200 if not supplied.\n    * The response is sent with the default Bot Defense non-caching headers. If manipulation of the headers or HTTP version is required, this can be done from the HTTP_RESPONSE_RELEASE event, using the HTTP:: commands. See the examples below.\n    * Note that the command may fail on some cases. So, it is recommended to verify the return status of the command. See below for the blocking-page example.\n\nBOTDEFENSE::action custom_redirect <location> [<http-status-code>]\n\n    * Responds to the client with a custom HTTP redirect.\n    * This is normally used to redirect the client to a blocking page, instead of aborting the connection.\n    * The <location> is the URL to place in the Location header of the HTTP response.\n    * The <http-status-code> is 307 if not supplied.\n    * The response is sent with the default Bot Defense non-caching headers. If manipulation of the headers or HTTP version is required, this can be done from the HTTP_RESPONSE_RELEASE event, using the HTTP:: commands. See the examples below.\n    * Note that the command may fail on some cases. So, it is recommended to verify the return status of the command. See below for the blocking-page example.","examples":"# EXAMPLE 1: Bypassing enforcement on URL pattern\nwhen BOTDEFENSE_ACTION {\n    if {[HTTP::uri] starts_with \"/t/\"} {\n        log local0. \"bypassing enforcement for URI [HTTP::uri]\"\n        set res [BOTDEFENSE::action allow]\n        log local0. \"set action to allow, result \\\"$res\\\"\"\n        log local0. \"resulting action [BOTDEFENSE::action] reason \\\"[BOTDEFENSE::reason]\\\"\"\n    }\n}\n\n# EXAMPLE 2: Instead of blocking the request with TCP RST, respond with a\n# blocking-page\nwhen BOTDEFENSE_ACTION {\n    if {[BOTDEFENSE::action] eq \"tcp_rst\"} {\n        # if the custom_response action fails, the tcp_rst action will remain,\n        # so we don't need to check the return string in this case\n        BOTDEFENSE::action custom_response \"sorry\\ni am blocking you\\n\"\n    }\n}\n\n# EXAMPLE 3: Instead of blocking the request with TCP RST, respond with a\n# multi-line blocking-page of 404 status and a response header\nwhen BOTDEFENSE_ACTION {\n    if {[BOTDEFENSE::action] eq \"tcp_rst\"} {\n        set res [BOTDEFENSE::action custom_response {\n            sorry\n            i am blocking you\n        } 404]\n        if {$res eq \"ok\"} {\n            set botdefense_responded 1\n        }\n    }\n}\nwhen HTTP_RESPONSE_RELEASE {\n    if {[info exists botdefense_responded]} {\n        HTTP::header insert \"myheader\" \"blocked request\"\n    }\n}\n\n# EXAMPLE 4: Instead of blocking the request with TCP RST, redirect the client\n# to a blocking page, and white-list the URL of the blocking-page\nwhen BOTDEFENSE_ACTION {\n    if {[HTTP::uri] eq \"/blocked.html\"} {\n        BOTDEFENSE::action allow\n    } elseif {[BOTDEFENSE::action] eq \"tcp_rst\"} {\n        BOTDEFENSE::action custom_redirect \"/blocked.html\"\n    }\n}\n\n# EXAMPLE 5: Force the browser_challenge to be sent to the client on the login\n# page, even if the cookie is valid (may be used to force the renewal of the\n# Bot Defense cookie)\nwhen BOTDEFENSE_ACTION {\n    if {    ([HTTP::uri] eq \"/t/login.php\") &&\n            ([BOTDEFENSE::action] eq \"allow\") &&\n            (not ([BOTDEFENSE::reason] starts_with \"passed browser challenge\"))} {\n        BOTDEFENSE::action browser_challenge\n    }\n}","returnValue":"* When called without any arguments: Returns a string signifying the action to be taken by Bot Defense. If the action was overridden, the returned action is the overridden one.\n    * When called with an argument for overriding the action, the return value is a status string. The returned string is \"ok\" if the command was successful. Otherwise, the reason for failure is returned."},
{"commandName":"BOTDEFENSE::reason","description":"Returns the reason that lead Bot Defense to decide on the action to be taken (the action that is specified in BOTDEFENSE::action).\n\nThe returned reason will include the Bot Signature and the Bot Signature Category, if a bot signature was detected on the request. This applies to Bot Signatures configured for blocking or reporting, and including Search Engines.\n\nSyntax\n\nBOTDEFENSE::reason","examples":"# EXAMPLE: Send the Bot Defense action and reason to High Speed Logging\nwhen BOTDEFENSE_ACTION {\n    HSL::send $hsl \"action [BOTDEFENSE::action] reason \\\"[BOTDEFENSE::reason]\\\"\"\n}","returnValue":"Returns a string signifying the reason for the Bot Defense action."},
{"commandName":"BWC::color","description":"After a flow has been assigned a policy, at some later time when the traffic is classified the user can assign an application to this flow. This uses the bwc config to create a bwc policy with the categories keyword.","examples":"when CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach gold_user $mycookie\n    BWC::color set gold_user p2p\n}","returnValue":""},
{"commandName":"BWC::mark","description":"This command allows you to set or unset marking for traffic flows in bwc when configured rate limit is exceeded. Marking can be on DSCP (ToS - L3) and/or QoS (L2). The ToS/QoS value needs to be in valid range and can be passthrough.","examples":"Example for bwc policy to mark traffic flows using iRule:\n\nBWC::mark <bwc policy name> <tos <value>> <qos <value>>\n\nSo to assign a policy, color, and mark here is an example rule\n\nwhen CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach gold_user $mycookie\n    BWC::color set gold_user p2p\n    BWC::mark gold_user tos 8 qos 4\n}\n\nExample for using bwc policy category to color a flow using iRule:\n\nAfter a flow has been assigned a policy, at some later time when the traffic is classified the user\ncan assign an application to this flow. This uses the bwc config to create a bwc policy with the\ncategories keyword: for example, p2p category below:\n\ntmsh create net bwc policy gold_user categories add { p2p { max-cat-rate 8mbps } } max-rate 10mbps\nmax-user-rate 10mbps dynamic enabled\n\nThe rule args\n\nBWC::color <set|unset> <bwc policy name> <app name>\n\nSo to assign a policy and color here is an example rule\n\nwhen CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach gold_user $mycookie\n    BWC::color set gold_user p2p\n}","returnValue":""},
{"commandName":"BWC::measure","description":"After a flow has been assigned a policy, user can start or stop measurement on a per policy basis or on a per flow basis. Once the measurement is started the measured bandwidth can be read by the user using 'BWC::measure get ..' iRules. Optionally users can direct the bandwidth measurement results to a 'log publisher' configured on the BIGIP system. Based on the log_publisher setting the measurement results will be logged to the log server indicated in the 'log_publisher'. It is usually an external high speed log server. Configuring a log publisher is recommended setting even though it is optional.","examples":"To create log publisher:\n        tmsh create net bwc-policy gold_user max-rate 10mbps max-user-rate 10mbps measure enabled log-publisher \"/Common/my_log_publisher\" log-period 2048 dynamic enabled\n\nTo use the created log publisher:\n    when CLIENT_ACCEPTED {\n        set mycookie [IP::remote_addr]:[TCP::remote_port]\n        set measureID \"MYSESSION\"\n        BWC::policy attach gold_user $mycookie\n        BWC::measure identifier $measureID session\n        BWC::measure start session\n    }\n\n    when SERVER_CONNECTED {\n        TCP::collect     set count 0\n    }\n\n    when SERVER_DATA {\n        if {$count >= 1000}\n        {\n            set rate [BWC::measure get rate session]\n            set bytes [BWC::measure get bytes session]\n            log local0. \"Rate $rate/sec : Bytes $bytes : for address $mycookie\" set count 0\n        }\n\n        TCP::release     TCP::collect     incr count\n    }","returnValue":""},
{"commandName":"BWC::policy","description":"A bwc policy must exist for the given policy name, the irule will return an error if the policy cannot be found. The policy name should be give without a path name: e.g. \"gold_user\" not \"/Common/gold_user\". The irule will internally try to determine the correct pathname through lookup_folder_path_obj().\n\nOnce the irule has found the correct bwc policy name, it will know if the policy is static or dynamic. If the policy is dynamic a third arg session is required. The session is used as the bwc_cookie_t argument to the bwc public api bwc_dynamic_policy_instantiate(). The provided session string will be internally converted to a bwc_cookie_t. Any given sessions which create a duplicate bwc_cookie_t are not handled internally by the bwc public api's, so duplicate cookie's map to the same dynamic policy.\n\nThe <session> argument is only valid for dynamic policy. As such the static policy must not supply any <session> arg when attaching.","examples":"Attach a static policy to a flow:\n    ltm rule test_bwc {\n        when CLIENT_ACCEPTED {\n            BWC::policy attach gold_class\n        }\n    }\n\nAttach a dynamic policy gold_user to a flow, session is combination of client address and port:\n\n    ltm rule test_bwc {\n        when CLIENT_ACCEPTED {\n            set mycookie [IP::remote_addr]:[TCP::remote_port]\n            BWC::policy attach gold_user $mycookie\n        }\n    }","returnValue":""},
{"commandName":"BWC::rate","description":"This command is used to modify max-user rate for dynamic policy after it is created. This irule can modify the rate for a session or category.","examples":"when CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach gold_user $mycookie\n    BWC::color set gold_user p2p\n    BWC::rate $mycookie p2p 1000000bps\n}","returnValue":""},
{"commandName":"BWC::pps","description":"After a policy is created, irule can modify the pps for the session. The value is specified in packets per second.","examples":"when CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach gold_user $mycookie\n    BWC::pps 77\n}","returnValue":""},
{"commandName":"BWC::priority","description":"A BWC policy instance or category can be mapped to a priority class of a priority group. This is part of the configuration and can be done via tmsh or GUI. Once a BWC instance has these mappings we can use the iRule defined below to change those. The syntax for this iRule is like below,\n\nBWC::priority <name1> <value1> [<name2> <value2>] [<name3> <value3>] [<name4> <value4>]\n\n    nameX - name of a priority class. valueX - weight of the priority class in percentage.\n\nIn the above iRule you can specify one or more traffic classes and specify the desired weight-percentage for that priority-class. Please note that the weight-percentages are updated only for the BWC instance over which the iRule is being run. The policy continues to have the weight-percentage as configured by tmsh/GUI. Any new BWC instance will get the weight-percentage from the tmsh/GUI based configuration unless the new instance executed a BWC:priority iRule to override it.","examples":"An example BWC::priority iRule. In this iRule we are setting the weight percentage of tg1->tc1 and tg1->tc2 to 60 and 40 respectively. Note that the BWC configuration has defined these weights to be 80 and 20. We are using iRules to override that and change it to 60 and 40.\n\nwhen SERVER_CONNECTED {\n\n    set my_policy bwc_policy set my_cat none set my_cookie [IP::remote_addr] switch -glob [TCP::remote_port] {\n        \"101\" {\n            set my_cat c1\n        }\n        \"102\" {\n            set my_cat c2\n        }\n    }\n    BWC::policy attach $my_policy $my_cookie if { $my_cat != \"none\" } {\n        log local0. \"BWC::color set $my_policy $my_cat\" BWC::color set $my_policy $my_cat BWC::priority \"tc1\" 60 \"tc2\" 40\n    }\n}\n\ntmsh configuration:\n\nnet bwc policy bwc_policy {\n\n    categories {\n        c1 {\n            max-cat-rate 10mbps\n            traffic-priority-map tg1->tc1\n        }\n        c2 {\n            max-cat-rate 10mbps\n            traffic-priority-map tg1->tc2\n        }\n    }\n    dynamic enabled log-publisher /Common/test_publisher max-rate 10mbps max-user-rate 10mbps\n}\n\nnet bwc priority-group tg1 {\n\n    priority-classes {\n        tc1 {\n            weight-percentage 80\n        }\n        tc2 {\n            weight-percentage 20\n        }\n    }\n}","returnValue":""},
{"commandName":"BWC::debug","description":"This command enables debug logs on per policy instance. However the bwc sys db variables for bwc trace need to be enabled and appropriate levels needs to be set as required.","examples":"when CLIENT_ACCEPTED {\n    set mycookie [IP::remote_addr]:[TCP::remote_port]\n    BWC::policy attach test_pol $mycookie\n    log  local0. \"BWC::policy attach  $mycookie\"\n    BWC::debug start session\n}","returnValue":""},
{"commandName":"CACHE::accept_encoding","description":"Overrides the accept_encoding value used by the cache to store the\ncached content. You can use this command to group various user encoding\nvalues into a single group, to minimize duplicated cached content.\n\n\nCACHE::accept_encoding <string>\n\n     * Overrides the accept_encoding value used by the cache to store the\n       cached content, according to the specified string.","examples":"","returnValue":""},
{"commandName":"CACHE::age","description":"Returns the age of the document in the cache, in seconds.\n\n\nCACHE::age\n\n     * Returns the age of the document in the cache, in seconds.","examples":"when CACHE_REQUEST {\n  if { [CACHE::age] > 60 } {\n    CACHE::expire\n    log local0. \"Expiring content: Age > 60 seconds\"\n   }\n}","returnValue":"Returns the age of the document in the cache, in seconds."},
{"commandName":"CACHE::disable","description":"Disables caching for this request.\n\n\nCACHE::disable\n\n     * Disables caching for this request.","examples":"when HTTP_REQUEST {\n  # Disable caching if the URI does not contain the string \"images\"\n  if { not ([HTTP::uri] contains \"images\") } {\n    CACHE::disable\n  }\n}\n\n\n# Disable caching if the query string contains specific parameter names\nwhen HTTP_REQUEST {\n\n   # Check the query string\n   # Prepend a & so that we can look for param names using &param_name=\nswitch -glob \"&[HTTP::query]\" {\n      \"*&param1=*\" -\n      \"*&param2=*\" -\n      \"*&param3=*\" -\n      \"*&param4=*\" {\n         # Found one of the parameters so disable caching for this request/response\n         CACHE::disable\n      }\n   }\n}","returnValue":""},
{"commandName":"CACHE::disabled","description":"Returns 1 for cache disabled, 0 otherwise.\n\nCACHE::disabled\n\n     * Returns true (1) or false (0) to indicate state of cache disable flag.","examples":"when HTTP_REQUEST {\n    if { [HTTP::header exists X-NoCache] } {\n        CACHE::disable\n        log local0. \"Disable cache.\"\n    }\n}\n\nwhen HTTP_RESPONSE {\n    set val [CACHE::disabled]\n    log local0. \"Cache disable state: $val\"\n}","returnValue":"Returns 0 or 1."},
{"commandName":"CACHE::enable","description":"Forces the document to be cached. You can also use this command to\ncache non-GET requests.\n\nNote: Should be used with extreme caution, as it allows caching of content marked private by server.\n\n\nCACHE::enable\n\n     * Forces the document to be cached.","examples":"when HTTP_REQUEST {\n  if { [HTTP::uri] contains \"images\" } {\n    CACHE::enable\n  }\n}","returnValue":""},
{"commandName":"CACHE::expire","description":"Forces the document to be revalidated from the server.\n\n\nCACHE::expire\n\n     * Forces the document to be revalidated from the server.","examples":"when CACHE_REQUEST {\n  if { $expire equals 1 } {\n    CACHE::expire\n    log \"cache expire\"\n  }\n}","returnValue":""},
{},
{"commandName":"CACHE::header","description":"The command is used to gather or modify the content of a header stored\nin the cache.\n\n\nCACHE::header <name>\n\n     * Get the content of the requested header\n\nCACHE::header insert <name> <value>\n\n     * Add the header with the specified value to the list of headers sent to the\n       client when delivering an object from the cache.\n\nCACHE::header remove <name>\n\n     * Remove the header with the specified name.\n\nCACHE::header replace <name> <value>\n\n     * Replace the header with the specified value.\n\nCACHE::header value <name>\n\n     * Return the header value for the specified header name.","examples":"when CACHE_RESPONSE {\n    # response being sent to the client - the object in the cache is not accessed/modified\n    # modifications will be seen only in the current response\n    CACHE::header insert X-Via F5-Local-Cache\n    CACHE::header replace Server Big-IP-Server\n}\n\n\nwhen CACHE_UPDATE {\n    # cached object's headers manipulation\n    # modifications will be seen whenever the object is served from cache\n    CACHE::header replace Server Big-IP-Server\n}","returnValue":""},
{"commandName":"CACHE::headers","description":"Returns the HTTP headers of the object in the cache.\nIf CACHE::header is used to manipulate the response headers prior to calling CACHE::headers, the modifications will not be reflected by CACHE::headers.\n\n\nCACHE::headers\n\n     * Returns the HTTP headers of the object in the cache as TCL Name / value pairs list.","examples":"when CACHE_RESPONSE {\n  # log all  HTTP headers sent in cache response.\n  log local0. [CACHE::headers]\n}","returnValue":"Returns the HTTP headers of the object in the cache as TCL Name / value pairs list."},
{"commandName":"CACHE::hits","description":"Returns the document cache hits.\n\n\nCACHE::hits\n\n     * Returns the document cache hits.","examples":"when CACHE_REQUEST {\n  log local0. \"[CACHE::hits] cache hits for document at [HTTP::uri]\"\n}","returnValue":"Returns the document cache hits."},
{"commandName":"CACHE::payload","description":"Returns the HTTP payload of the cache response.\n\n\nCACHE::payload\n\n     * Returns the HTTP payload of the cache response.","examples":"when CACHE_RESPONSE {\n  set payload [CACHE::payload]\n}","returnValue":""},
{"commandName":"CACHE::priority","description":"Assigns a priority to cached documents. The priority value can be\nbetween 1 and 10 inclusive. This command allows users to designate\ndocuments that are costly to produce as being more important than\nothers to cache. This is particularly useful when you have a document\nthat is not requested often, but is expensive to produce (such as a\nserver-compressed document.) By increasing the priority, you are\nincreasing its likelihood of being served from the cache\n\nThe default priority value for entries in the cache is zero (0 = cache\npriority disabled).\n\n\nCACHE::priority <1 .. 10>\n\n     * Assigns a priority to the currently requested cached document. The\n       priority value can be between 1 and 10 inclusive.","examples":"when HTTP_REQUEST {\n  switch -glob [HTTP::uri] {\n    \"*.zip\" -\n    \"*.tar\" -\n    \"*.gz\" {\n      # set the priority to 8 for this document if it's a compressed archive\n      CACHE::priority 8\n    }\n    \"*.gif\" -\n    \"*.jpg\" -\n    \"*.png\" {\n      # set the priority to 5 for this document if it's an image\n      CACHE::priority 5\n    }\n    \"/mustcache*\" {\n      # Any document matching /mustcache will be set to the highest priority.\n      CACHE::priority 10\n    }\n  }\n}","returnValue":""},
{},
{"commandName":"CACHE::trace","description":"Dump the list of cached objects for a HTTP profile where RAM Cache is\nenabled.\nThis event will execute only if a RAM Cache profile is enabled on the\nVirtual Server, and for objects that match the RAM Cache configuration.\nThe list will represent the size of the cache (Cache Size), number of\nobjects (Cache Count), and starting by the term Entity, it will list\nevery object:\n  * Pos (0001), list the position of the object in the cache\n  * Local Hits (00031/00007) indicate the number of Local Hits\n  * Remote Hits (00031/00007) indicate the number of Remote Hits\n  * Served (000) list the number of times the object was served from\n    the cache\n  * Age (1931), indicate the aging of the object in the cache\n  * Score (0124), indicate the scoring of the object\n  * Key - 'www.mystestsite.fr/f5-logo.gif' list the name of the object\n\n\n\nSyntax\nCACHE::trace","examples":"when RULE_INIT {\n    set static::cache \"\"\n}\nwhen HTTP_REQUEST {\n    if { [HTTP::uri] ends_with \"/cache\" } {\n        HTTP::respond 200 content \"CACHE DUMP\\r\\n\\r\\n$static::cache\\r\\n\\r\\n\"\n    }\n}\n\nwhen CACHE_RESPONSE {\n    CACHE::header insert X-Via F5-LB\n    set static::cache [CACHE::trace]\n}\n\nPage Returned (in TEXT format):\n\n CACHE DUMP\n\n Cache size             - 1414\n Cache count            - 1\nEntity - Pos (0001) Local Hits (00000/00000) Remote Hits (00000/00000) Served (005) Age (005) Score (0000) Key - '10.100.30.111/templates/divers/icone.gif'","returnValue":""},
{"commandName":"CACHE::uri","description":"By default, cached content is stored with a unique key that consists of the Host\nheader, URI, Accept-Encoding and User-Agent. If multiple variations of the\nsame content must be cached under specific conditions (different client), you\ncan use this command to modify URI and create a unique key, thus creating\ncached content specific to that condition. This can be used to prevent one user\nor group's cached data from being served to different users/groups.\n\nIf any of the key elements is rewritten at the HTTP level (HTTP_REQUEST),\nthe key uses those values, not the original values.\n\n\nCACHE::uri <string>\n\n     * Overrides the default URI key value used by the cache to store the\n       cached content, according to the specified string. (Does NOT change\n       the URI on the wire as HTTP::uri does.)","examples":"To cache documents using unique, per-session virtual URI keys without actually\nchanging the URI on the wire (prevents sharing of cached content between\nsessions).\n\nwhen HTTP_REQUEST {\n  set my_session_string <unique, sanitized session value>\n  CACHE::uri [HTTP::uri]$my_session_string\n}","returnValue":""},
{"commandName":"CACHE::useragent","description":"By default, cached content is stored with a unique key that\nconsists of the Host header, URI, Accept-Encoding and User-Agent.\nIf the content is generated the same for multiple User-Agents,\nthis command can be used to group various User-Agent values into a single\ngroup, thus minimizing duplicated cached content.\n\n\nCACHE::useragent <string>\n\n     * Overrides the useragent value used by the cache to store the cached\n       content.","examples":"This will put all MSIE based browsers into a single cache group.\n\nwhen HTTP_REQUEST {\n  if {[HTTP::header User-Agent] contains \"MSIE\"} {\n    CACHE::useragent \"MSIE\"\n  }\n}\n\nThis will ignore all client user agents and put all clients into the\nsame cache group.\n\nwhen HTTP_REQUEST {\n  CACHE::useragent \"GENERIC-UA\"\n}","returnValue":""},
{"commandName":"CACHE::userkey","description":"By default, cached content is stored with a unique key referring to both\nthe URI of the resource to be cached and the User-Agent for which it\nwas formatted. If multiple variations of the same content must be\ncached under specific conditions (different client), you can use this\ncommand to create a unique key, thus creating cached content specific\nto that condition. This can be used to prevent one user or group's\ncached data from being served to different users/groups.\nFor example, you can use this command to store different cached content\nfor dialup and broadband by using the MTU as a user-defined value\nor to cache different sets of content for internal and external\nclients.\n\n\nCACHE::userkey <key>\n\n     * Allows to add user-defined values to the key, according to\n       the specified key string.","examples":"Create a separate cache entry for internal and external clients,\nuseful when server generates different documents internal and external requests\n\nwhen HTTP_REQUEST {\n  if {[matchclass [IP::client_addr] equals $::InternalIPs]} {\n    CACHE::userkey \"Internal\"\n  } else {\n    CACHE::userkey \"External\"\n  }\n}","returnValue":""},
{"commandName":"CATEGORY::analytics","description":"Enables or disables the analytics server on a per request basis (requires SWG license)","examples":"when HTTP_REQUEST {\n    set this_uri http://[HTTP::host][HTTP::uri]\n    set reply [CATEGORY::lookup $this_uri]\n    log local0. \"uri $this_uri returns category=$reply\"\n    if { $reply equals \"Adult Material\" } {\n        CATEGORY::analytics enable\n    }\n}","returnValue":"No return value"},
{"commandName":"CATEGORY::filetype","description":"Checks for the mime type and mime subtype of an HTTP request payload and returns the values to specified variables; use one or both to specify them name of the variable that you want the value to be given to.","examples":"when HTTP_RESPONSE {\n    # Collect 256 bytes of payload and trigger HTTP_RESPONSE_DATA\n    HTTP::collect 256\n}\nwhen HTTP_RESPONSE_DATA {\n    # Get the mime type and subtype for the payload\n    CATEGORY::filetype [HTTP::payload 256] -mimetype type_var -mimesubtype subtype_var\n    log local0. \"Returned: type $type_var and subtype $subtype_var\"\n}","returnValue":"Sets the specified variables with the mime type or mime subtype"},
{"commandName":"CATEGORY::lookup","description":"This command returns the category of the supplied URL. (requires SWG license)\nThe URL needs to be of the form:\nscheme://domain:port/path?query_string#fragment_id\n\nThe query_string and fragment_id are optional. The entire list of categories supported is available in the UI under \"Secure Web Gateway\" in the APM section. Examples of categories include Sports, Shopping, etc. The response is a list of category names in a TCL array. Most input URLs result in a single category but some will return more than one. Additionally, a result of \"199\" indicating a recommendation to scan the response can also be returned.\n\nTo obtain a full list of the category names that can be returned, run the following TMSH command:\ntmsh list sys url-db url-category | grep url-category | cut -d \" \" -f4","examples":"when HTTP_REQUEST {\n        set this_uri http://[HTTP::host][HTTP::uri]\n        set reply [CATEGORY::lookup $this_uri]\n        log local0. \"Category lookup for $this_uri give $reply\"\n    }","returnValue":"Returns a list of categories returned by the categorization engine depending on the category type specified (custom, request_default, or request_default_and_custom). If no type is specified, it will return request_default. If the \"-display\" flag is used, it will return the string with category only, otherwise it will return the string as a category name with the partition to which it belongs."},
{"commandName":"CATEGORY::matchtype","description":"This iRules command is intended to be used with the CATEGORY_MATCHED event and will store the match result in the specified variable. It will return one of \"custom\", \"request_default\", or \"request_default_and_custom\". This tells the admin what kind of match was made when the CATEGORY_MATCHED event was raised – custom category match, match from the Websense categorization engine, or both. (requires SWG license)","examples":"when CATEGORY_MATCHED {\n    CATEGORY::matchtype type_var\n        if { $type_var eq \"custom\" } {\n            log local0. \"Custom category match was found.\"\n        }\n}","returnValue":"Returns one of \"custom\", \"request_default\", \"request_default_and_custom\""},
{"commandName":"CATEGORY::result","description":"This iRule command is useful for when it is necessary to know the category or safesearch parameters returned during the categorization in the Category Lookup Agent in the per-request policy. As opposed to CATEGORY::lookup and CATEGORY::safesearch, which each require an additional query to the categorization engine, CATEGORY::result will give back what was found and stored, eliminating the need for additional lookups.\n\nChoose which should be returned (either \"category\" or \"safesearch\"). If \"category\", additional specifications may apply: \"-display\" will return categories in display name format. \"custom\", \"request_default\", or \"request_default_and_custom\" maybe be used to return respectively ONLY custom categories, ONLY database default categories, or both custom and default categories.","examples":"when CATEGORY_MATCHED {\n    set cat [CATEGORY::result category -display request_default_and_custom]\n    log local0. \"Category result retrieved: [lindex $cat 0]\"\n    set ss [CATEGORY::result safesearch]\n    log local0. \"Safe Search result retrieved: [lindex $ss 0], [lindex $ss 1]\"\n}","returnValue":"Returns a list of categories or safe search parameters. Return format is the same as CATEGORY::lookup and CATEGORY::safesearch."},
{"commandName":"CATEGORY::safesearch","description":"Checks for safe search parameters for the given URL, returns them in list form with the first entry being the key, and the second being the value. Repeated in list for multiple results. (requires SWG license)","examples":"when HTTP_REQUEST {\n    set this_uri http://[HTTP::host][HTTP::uri]\n    set reply [CATEGORY::safesearch $this_uri]\n    set len [llength $reply]\n    if { $len equals 2 } {\n        log local0. \"uri $this_uri returns safesearch key=[lindex $reply 0] and value=[lindex $reply 1]\"\n        if { not([HTTP::uri] contains \"&[lindex $reply 0]=[lindex $reply 1]\") } {\n            HTTP::uri [HTTP::uri]&[lindex $reply 0]=[lindex $reply 1]\n        }\n    }\n}","returnValue":"Returns a list of alternating key and value pairs. E.g.: [key1, value1, key2, value2]"},
{"commandName":"CLASSIFICATION::app","description":"This command provides classification for the most explicit application\nname. (Example: cnn, amazon)\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\nCLASSIFICATION::app","examples":"when CLASSIFICATION_DETECTED {\n  if { [CLASSIFICATION::app] equals \"application1\"}  {\n    drop\n  }\n}","returnValue":""},
{"commandName":"CLASSIFICATION::category","description":"This command provides classification category name. (Example: mail,\ngaming)\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nSyntax\nCLASSIFICATION::category","examples":"when CLASSIFICATION_DETECTED {\n  if { [CLASSIFICATION::category] equals \"chat\"}  {\n    drop\n  }\n}","returnValue":""},
{"commandName":"CLASSIFICATION::disable","description":"This command disables classification for the current flow.\n\nCLASSIFICATION::disable","examples":"","returnValue":""},
{"commandName":"CLASSIFICATION::enable","description":"This command enables classification for the current flow.\n\nCLASSIFICATION::enable","examples":"","returnValue":""},
{"commandName":"CLASSIFICATION::protocol","description":"This command provides classification for the least explicit application\nname. (Example: http, ssl)\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\nCLASSIFICATION::protocol","examples":"when CLASSIFICATION_DETECTED {\n  if { [CLASSIFICATION::protocol] == \"http\"}  {\n    drop\n  }\n}","returnValue":""},
{"commandName":"CLASSIFICATION::result","description":"CLASSIFICATION::result","examples":"In the example, the CLASSIFICATION::result command returns an array of classification tokens.\n\n    when CLASSIFICATION_DETECTED {\n        set res [CLASSIFICATION::result]\n        log local0.debug \"DPI results: $res\"\n    }","returnValue":""},
{"commandName":"CLASSIFICATION::username","description":"CLASSIFICATION::username","examples":"In the example, the CLASSIFICATION::username command returns username.\n\n    when CLASSIFICATION_DETECTED {\n        set res [CLASSIFICATION::username]\n        log local0.debug \"DPI username: $res\"\n    }","returnValue":""},
{"commandName":"CLASSIFICATION::urlcat","description":"This command provides classification url category name.\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nCLASSIFICATION::urlcat","examples":"","returnValue":""},
{"commandName":"CLASSIFY::application","description":"This command allows you to set or add an app name to the\nclassification.\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nCLASSIFY::application set <app_name>\n\n     * will immediately classify flow as app_name. The classification by\n       the classification engine will be bypassed. The category classification token this app_name belongs to will also be attached.\n\nCLASSIFY::application add <app_name>\n\n     * adds an application classification token to the final\n       classification result issued by the classification engine. This can\n       be issued multiple times in order to add multiple tokens to the classification result.\n\n   Note: set/add commands will have no effect if fired after the flow has\n   been classified.","examples":"","returnValue":""},
{"commandName":"CLASSIFY::category","description":"This command allows you to set or add a category name to the\nclassification.\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nCLASSIFY::category set <category_name>\n\n     * will immediately classify flow as category_name. The classification\n       by the classification engine will be bypassed. Flow will have the unknown application classification token.\n\nCLASSIFY::category add <category_name>\n\n     * will add a category classification token to the final\n       classification result issued by the classification engine. This can\n       be issued multiple times in order to add multiple tokens to the classification result\n\n   Note: set/add commands will have no effect if fired after the flow has\n   been classified.","examples":"","returnValue":""},
{"commandName":"CLASSIFY::defer","description":"This command defers the classification of the flow to response (for\nHTTP - response message, for non-HTTP, opposite traffic direction from\ntraffic initiator)\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nCLASSIFY::defer","examples":"","returnValue":""},
{"commandName":"CLASSIFY::username","description":"This command assigns username to the flow. It could be used for\nreporting / statistics / etc.\n\nCLASSIFY::username","examples":"when CLIENT_ACCEPTED {\n    CLASSIFY::username superuser\n}\nwhen CLASSIFICATION_DETECTED {\n    set res [CLASSIFICATION::results]\n    set uname [CLASSIFICATION::username]\n    log local0.debug \"DPI results $res for $uname\"\n}","returnValue":""},
{"commandName":"CLASSIFY::disable","description":"Disables the classification of the flow","examples":"","returnValue":""},
{"commandName":"CLASSIFY::urlcat","description":"This command allows you to set or add an url category to the\nclassification.\n\n* Note: APM / AFM / PEM license is required for functionality to work.\n\n\nCLASSIFY::urlcat set <URL_Category>\n\n     * will immediately classify flow as URL_category.\n\nCLASSIFY::application add <app_name>\n\n     * adds an URL Category to the URL classification token to the final\n       classification result issued by the classification engine. This can\n       be issued multiple times in order to add multiple tokens to the classification result.\n\n   Note: set/add commands will have no effect if fired after the flow has\n   been classified.","examples":"root@(vbigip01)(cfg-sync Standalone)(Active)(/Common)(tmos)# create ltm classification url-category customCategory { urlcat-id 28673 }\nroot@(vbigip01)(cfg-sync Standalone)(Active)(/Common)(tmos)# list ltm classification url-category customCategory\nltm classification url-category customCategory {\n    urlcat-id 28673\n}\nroot@(vbigip01)(cfg-sync Standalone)(Active)(/Common)(tmos)# quit\n\niRULE for set:\n--------------\nwhen HTTP_REQUEST\n{\n    if { [HTTP::host] contains \"google\"} {\n        CLASSIFY::urlcat set customCategory\n    }\n}\n\niRule for add:\n-------------\nwhen HTTP_REQUEST\n{\n    if { [HTTP::host] contains \"google\"} {\n        CLASSIFY::urlcat add customCategory\n    }\n}","returnValue":""},
{"commandName":"COMPRESS::buffer_size","description":"COMPRESS::buffer_size <value>\n    Sets the compression buffer size according to the value you specify in bytes.","examples":"when HTTP_RESPONSE {\n  if { [HTTP::header Content-Type] contains \"text/html;charset=UTF-8\"} {\n    COMPRESS::buffer_size 10240\n    COMPRESS::enable\n  }\n}","returnValue":""},
{"commandName":"COMPRESS::disable","description":"Disables compression for the current HTTP response. Note that when using this command, you must set the HTTP profile setting Compression to Selective.\n\nCOMPRESS::disable\n    Disables compression for the current HTTP response. Note that when using this command, you must set the HTTP profile setting Compression to Selective.","examples":"when HTTP_REQUEST {\n  if { [TCP::mss] >= 1280 } {\n    COMPRESS::disable\n  }\n}","returnValue":""},
{"commandName":"COMPRESS::enable","description":"COMPRESS::enable\n    Enables compression for the current HTTP response. Note that when using this command, you must set the HTTP profile setting Compression to Selective.\n\nCOMPRESS::enable request\n    Enables compression for the current HTTP request. As with the normal COMPRESS::enable, you must enable the HTTP compression profile setting Selective Compression (version 11.x). You must also enable an HTTP profile with \"request-chunking selective\" selected.","examples":"when HTTP_RESPONSE {\n  if { [HTTP::header Content-Type] contains \"text/html;charset=UTF-8\"} {\n    COMPRESS::enable\n  }\n}","returnValue":""},
{"commandName":"COMPRESS::nodelay","description":"","examples":"","returnValue":""},
{"commandName":"COMPRESS::gzip","description":"Sets criteria for compressing HTTP responses.\n\nCOMPRESS::gzip memory_level <level>\n    Sets the gzip memory level.\n\nCOMPRESS::gzip window_size <size>\n    Sets the gzip window size.\n\nCOMPRESS::gzip level <level>\n    Specifies the amount and rate of compression.","examples":"when HTTP_RESPONSE {\n  COMPRESS::gzip level 9\n}","returnValue":""},
{"commandName":"COMPRESS::method","description":"Specifies the preferred compression algorithm.\n\nCOMPRESS::method prefer [ ’gzip’ | ’deflate’ ]\n    Specifies the preferred compression algorithm, either gzip or deflate.","examples":"when HTTP_REQUEST_SEND {\n COMPRESS::method prefer gzip\n}","returnValue":""},
{"commandName":"CRYPTO::decrypt","description":"This iRules command decrypts data.\n\nCRYPTO::decrypt [-alg <>] [-ctx <> [-final]] [-key[hex] <>] [-iv[hex] <>] [<data>]\n                [-padding <\"pkcs\" | \"oaep\">]\n\n     * decrypts data based on several parameters\n          + alg - algorithm. ASCII string from a given list (see below)\n            The spelling is lowercase and the iRule will fail for anything\n            not in the list. In ctx mode, alg must be given in the first\n            CRYPTO::command and cannot be modified.\n          + ctx - context is the name of a Tcl variable and can only be\n            generated from and used in CRYPTO commands. Notes:\n               o Trying to get or set value for a ctx variable will fail.\n               o When a CTX variable is first used in iRule, a tcl object\n                 will be generated from the given arguments (alg, key, iv,\n                 etc.).\n               o A given CTX variable can only be used for one\n                 CRYPTO::<encrypt|decrypt|sign|verify|hash> command. An\n                 iRule CRYPTO:: command would fail if CTX is reused for\n                 different purpose. \"–final\" must be used for the last\n                 CRYPTO:: command for the same CTX variable to finish the\n                 CRYPTO:: command. After \"-final\" is used, the CTX\n                 variable will be freed and the same ctx variable name can\n                 be reused.\n               o When a CTX variable already has a key and an IV value\n                 stored in it, the value can only be updated before CRYPTO\n                 command really starts, that is before any data is given.\n                 After the command starts and before it finishes, updating\n                 key or IV in CTX would fail.\n          + key - key (binary data). Key length is determined by alg used.\n            Can be generated by CRYPTO::keygen\n          + keyhex - key as hex data. Key length is determined by alg\n            used. Can be generated by CRYPTO::keygen\n          + padding - padding technique for asymmetric encryption operations.\n            The default value is \"pkcs\".\n          + iv - initialization vector (binary data). Length is determined\n            by alg used. Can be generated by CRYPTO::keygen\n          + ivhex - initialization vector as hex data. Length is\n            determined by alg used. Can be generated by CRYPTO::keygen\n\n\n\nAlgorithm List\n\n     Algorithm       Cipher Name     Block Size (bits)   Key Size (bits)\n   aes-128-mode  AES-128             128               128\n   aes-192-mode  AES-192             128               192\n   aes-256-mode  AES-256             128               256\n   bf-mode       Blowfish            64                variable, up to 448\n   des-mode      DES                 64                56\n   des-ede-mode  DES (2 key)         64                112\n   des-ede3-mode DES (3 key)         64                168\n   dea-mode      IDEA                64                128\n   rc2-mode      RC2                 64                variable, 40 to 128\n   rc4           RC4 (stream cipher) N/A               variable, up to 2048\n\n\nWarning\n\n   Cryptography is very difficult to get correct. It is easy to create a\n   system that looks secure but isn't. The CRYPTO::encrypt and\n   CRYPTO::decrypt commands were designed to provide interoperability\n   between BIG-IP and 3rd-party software using common cipher algorithms\n   (AES, Blowfish, DES, etc.).\n   The CRYPTO:: commands should not be used in an attempt to replace\n   transport security protocols such as SSL for providing secure\n   communication between devices. It is the responsibility of the iRule\n   designer(s) to manage any compositional weaknesses in systems created\n   using the CRYPTO:: commands.","examples":"","returnValue":""},
{"commandName":"CRYPTO::encrypt","description":"This iRules command encrypts data. A ciphertext encrypted with this\ncommand should be decryptable by third party software.\n\nCRYPTO::encrypt [-alg <>] [-ctx <> [-final]] [-key[hex] <>] [-iv[hex] <>] [<data>]\n                [-padding <\"pkcs\" | \"oaep\">]\n\n     * encrypts data based on several parameters\n          + alg - algorithm. ASCII string from a given list (see below)\n            The spelling is lowercase and the iRule will fail for anything\n            not in the list. In ctx mode, alg must be given in the first\n            CRYPTO:: command and cannot be modified.\n          + ctx - context is the name of a Tcl variable and can only be\n            generated from and used in CRYPTO commands. Notes:\n               o Trying to get or set value for a ctx variable will fail.\n               o When a CTX variable is first used in iRule, a tcl object\n                 will be generated from the given arguments (alg, key, iv,\n                 etc.).\n               o A given CTX variable can only be used for one\n                 CRYPTO::<encrypt|decrypt|sign|verify|hash> command. An\n                 iRule CRYPTO:: command would fail if CTX is reused for\n                 different purpose. \"–final\" must be used for the last\n                 CRYPTO:: command for the same CTX variable to finish the\n                 CRYPTO:: command. After \"-final\" is used, the CTX\n                 variable will be freed and the same ctx variable name can\n                 be reused.\n               o When a CTX variable already has a key and an IV value\n                 stored in it, the value can only be updated before CRYPTO\n                 command really starts, that is before any data is given.\n                 After the command starts and before it finishes, updating\n                 key or IV in CTX would fail.\n          + key - key (binary data). Key length is determined by alg used.\n            Can be generated by CRYPTO::keygen\n          + keyhex - key as hex data. Key length is determined by alg\n            used. Can be generated by CRYPTO::keygen\n          + padding - padding technique for asymmetric encryption operations.\n            The default value is \"pkcs\".\n          + iv - initialization vector (binary data). Length is determined\n            by alg used. Can be generated by CRYPTO::keygen\n          + ivhex - initialization vector as hex data. Length is\n            determined by alg used. Can be generated by CRYPTO::keygen\n\n\n\nAlgorithm List\n\n   Algorithm Cipher Name Block Size (bits) Key Size (bits) Modes\n   aes-128-mode AES-128 128 128 cbc,cfb,cwc,ecb,ofb\n   aes-192-mode AES-192 128 192 cbc,cfb,cwc,ecb,ofb\n   aes-256-mode AES-256 128 256 cbc,cfb,cwc,ecb,ofb\n   bf-mode Blowfish 64 variable, up to 448 cbc,cfb,ecb,ofb\n   des-mode DES 64 56 cbc,cfb,ecb,ofb\n   des-ede-mode DES (2 key) 64 112 cbc,cfb,ecb,ofb\n   des-ede3-mode DES (3 key) 64 168 cbc,cfb,ecb,ofb\n   dea-mode IDEA 64 128\n   rc2-mode RC2 64 variable, 40 to 128\n   rc4 RC4 (stream cipher) N/A variable, up to 2048\n\n\nWarning\n\n   Cryptography is very difficult to get correct. It is easy to create a\n   system that looks secure but isn't. The CRYPTO::encrypt and\n   CRYPTO::decrypt commands were designed to provide interoperability\n   between BIG-IP and 3rd-party software using common cipher algorithms\n   (AES, Blowfish, DES, etc.).\n   The CRYPTO:: commands should not be used in an attempt to replace\n   transport security protocols such as SSL for providing secure\n   communication between devices. It is the responsibility of the iRule\n   designer(s) to manage any compositional weaknesses in systems created\n   using the CRYPTO:: commands.","examples":"Encrypt an MSISDN header\n# Encrypt the MSISDN header for each request.\n# The encryption is deliberately designed to be insecure;\n# that is, the same MSISDN will always be encrypted to\n# the same ciphertext. And since the IV will always be\n# the same for each encryption, there's no need to send\n# it out with the ciphertext.\n#\nwhen SIP_REQUEST {\n    set key \"abed1ddc04fbb05856bca4a0ca60f21e\"\n    set iv \"d78d86d9084eb9239694c9a733904037\"\n    set enc_msisdn [CRYPTO::encrypt -alg aes-128-cbc -keyhex $key -ivhex $iv [SIP::header \"MSISDN\"]]\n    SIP::header remove \"MSISDN\"\n    SIP::header insert \"MSISDN\" [b64encode $enc_msisdn]\n}","returnValue":""},
{"commandName":"CRYPTO::hash","description":"This iRules command generates a hash on a piece of data\n\n\nCRYPTO::hash [-alg <>] [-ctx <> [-final]] [<data>]\n\n     * Generates a hash on a piece of data\n\n\nAlgorithm List\n\n     * md5\n     * ripemd160\n     * sha1\n     * sha224\n     * sha256\n     * sha384\n     * sha512","examples":"when HTTP_REQUEST {\nif {[class match [b64encode [CRYPTO::hash -alg sha384 [HTTP::host][HTTP::path]]] equals HASH ]} {\n    log local0. \" this FQDN + PATH is mathing - [HTTP::host][HTTP::path]\"\n}\n}\n\nThis example shows how CRYPTO::hash command can be used by hashing the\nFQDN and PATH of a URI, and checking if this matches a DATAGROUP\n   (called HASH) composed of externally hashed URLs. The hashed URLs in\nthe DATAGROUP, are given by an external company, and hashed to avoid\nreverse engineering of the URL DB. The goal of the iRule is to check if\nthere is a match in this HASHED URL DB.","returnValue":""},
{"commandName":"CRYPTO::keygen","description":"This iRules command is used to generate keys that can be used to\nencrypt and sign data.\n\n\nCRYPTO::keygen -alg <> -len <> [-passphrase <> -salt[hex] <> -rounds <>]\n\n     * Used to generate keys that can be used to encrypt and sign data.\n          + -alg (Two options: random or pbkdf2-md5)\n          + -len (Must be a multiple of 8, e.g. 256, 512)\n          + -passphrase (used as data to generate key)\n          + -salt (binary data used to generate key)\n          + -salthex (hex data used to generate key)\n          + -rounds (Integer indicating how many rounds to use when\n            generating key)","examples":"","returnValue":""},
{"commandName":"CRYPTO::sign","description":"This iRules command is used to provide a digital signature of a block\nof data.\n\n\nCRYPTO::sign [-alg <>] [-ctx <> [-final]] [-key[hex] [<data>]\n\n     * Used to provide a digital signature of a block of data. Notes on\n       the flags:\n          + alg - algorithm. ASCII string from a given list (see below)\n            The spelling is lowercase and the iRule will fail for anything\n            not in the list. In ctx mode, alg must be given in the first\n            CRYPTO::command and cannot be modified.\n          + ctx - context is the name of a Tcl variable and can only be\n            generated from and used in CRYPTO commands. Notes:\n               o Trying to get or set value for a ctx variable will fail.\n               o When a CTX variable is first used in irule, a tcl object\n                 will be generated from the given arguments (alg, key, iv,\n                 etc.).\n               o A given CTX variable can only be used for one CRYPTO::\n                 command . An irule CRYPTO::command would fail if\n                 CTX is reused for different purpose. \"–final\" must be\n                 used for the last CRYPTO::command for the same CTX\n                 variable to finish the\n                 CRYPTO::command. After \"-final\" is used, the CTX variable\n                 will be freed and the same ctx variable name can be\n                 reused.\n               o When a CTX variable already has a key and an IV value\n                 stored in it, the value can only be updated before CRYPTO\n                 command really starts, that is\n                 before any data is given. After the command starts and\n                 before it finishes, updating key or IV in CTX would fail.\n          + key - key (binary data). Key length is determined by alg used.\n            Can be generated by CRYPTO::keygen\n          + keyhex - key as hex data. Key length is determined by alg\n            used. Can be generated by CRYPTO::keygen\n\n\n\nAlgorithm List\n\n     * hmac-md5\n     * hmac-ripemd160\n     * hmac-sha1\n     * hmac-sha224\n     * hmac-sha256\n     * hmac-sha384\n     * hmac-sha512","examples":"set secret_key \"foobar1234\"\n\nset data \"This is my data\"\n\nset signed_data [CRYPTO::sign -alg hmac-sha1 -key $secret_key $data]\n\nif { [CRYPTO::verify -alg hmac-sha1 -key $secret_key -signature $signed_data $data] } {\n    log local0. \"Data verified\"\n}\n\nThe secret key will normally be some large string, size generally\ndictated by algorithm. The data is just whatever content you want to\nsign. The result of the CRYPTO::sign command will be a binary value, so\nif you're going store this somewhere, probably best to b64encode it\nfirst. The CRYPTO::verify command essentially takes the original data\nand the digital signature of that data (derived from CRYPTO::sign),\ndecrypts that digital signature with the key, creates a new hash of the\ndata, and then compares the two hashes. If they're the same, then the\ncontents have not been modified.","returnValue":""},
{"commandName":"CRYPTO::verify","description":"This iRules command is used to verify a signed block of data.\n\n\nCRYPTO::verify [-alg <>] [-ctx <> [-final]] [-key[hex] [-signature <>] [<data>]\n\n     * Used to provide a digital signature of a block of data. Notes on\n       the flags:\n          + alg - algorithm. ASCII string from a given list (see below)\n            The spelling is lowercase and the iRule will fail for anything\n            not in the list. In ctx mode, alg must be given in the first\n            CRYPTO::command and cannot be modified.\n          + ctx - context is the name of a Tcl variable and can only be\n            generated from and used in CRYPTO commands. Notes:\n               o Trying to get or set value for a ctx variable will fail.\n               o When a CTX variable is first used in irule, a tcl object\n                 will be generated from the given arguments (alg, key, iv,\n                 etc.).\n               o A given CTX variable can only be used for one CRYPTO::\n                 command . An irule CRYPTO::command would fail if\n                 CTX is reused for different purpose. \"–final\" must be\n                 used for the last CRYPTO::command for the same CTX\n                 variable to finish the\n                 CRYPTO::command. After \"-final\" is used, the CTX variable\n                 will be freed and the same ctx variable name can be\n                 reused.\n               o When a CTX variable already has a key and an IV value\n                 stored in it, the value can only be updated before CRYPTO\n                 command really starts, that is\n                 before any data is given. After the command starts and\n                 before it finishes, updating key or IV in CTX would fail.\n          + key - key (binary data). Key length is determined by alg used.\n            Can be generated by CRYPTO::keygen\n          + keyhex - key as hex data. Key length is determined by alg\n            used. Can be generated by CRYPTO::keygen\n\n\n\nAlgorithm List\n\n     * hmac-md5\n     * hmac-ripemd160\n     * hmac-sha1\n     * hmac-sha224\n     * hmac-sha256\n     * hmac-sha384\n     * hmac-sha512","examples":"set secret_key \"foobar1234\"\n\nset data \"This is my data\"\n\nset signed_data [CRYPTO::sign -alg hmac-sha1 -key $secret_key $data]\n\nif { [CRYPTO::verify -alg hmac-sha1 -key $secret_key -signature $signed_data $data] } {\n    log local0. \"Data verified\"\n}\n\nThe secret key will normally be some large string, size generally\ndictated by algorithm. The data is just whatever content you want to\nsign. The result of the CRYPTO::sign command will be a binary value, so\nif you're going store this somewhere, probably best to b64encode it\nfirst. The CRYPTO::verify command essentially takes the original data\nand the digital signature of that data (derived from CRYPTO::sign),\ndecrypts that digital signature with the key, creates a new hash of the\ndata, and then compares the two hashes. If they're the same, then the\ncontents have not been modified.","returnValue":""},
{"commandName":"DATAGRAM::dns","description":"This iRules command returns DNS header information.\n  Note: L4 protocol of the packet must be either TCP or UDP for this command\n        to work. Also, the L4 port must be equal to the dns port (typically port 53).\n\nDATAGRAM::dns id\n\n     * Returns DNS header 16-bit ‘identification’ field as an integer value.\n\nDATAGRAM::dns qr\n\n     * Returns DNS header ‘query/response’ as a boolean value.\n       0 indicates a ‘query’ and 1 indicates a ‘response’.\n\nDATAGRAM::dns opcode\n\n     * Returns DNS header ‘opcode’ as a string.\n       Values include ‘Query’, ‘IQuery’, ‘Status’, ‘Notify’, ‘Update’ and ‘Unassigned’.\n\nDATAGRAM::dns qdcount\n\n     * Returns DNS header field ‘question count’ as an integer value.\n\nDATAGRAM::dns ancount\n\n     * Returns DNS header field ‘answer count’ as an integer value.\n\nDATAGRAM::dns nscount\n\n     * Returns DNS header field ‘authority record count’ as an integer value.\n\nDATAGRAM::dns qdcount\n\n     * Returns DNS header field ‘additional record count’ as an integer value.","examples":"when FLOW_INIT {\n  if { [IP::protocol] == 6 } {\n    log local0. \"TCP Payload Length = [DATAGRAM::tcp payload_length] Payload: [DATAGRAM::tcp payload 100]\"\n    log local0. \"DNS Header fields ID: [DATAGRAM::dns id] QR: [DATAGRAM::dns qr] OPCODE: [DATAGRAM::dns opcode] QDCOUNT: [DATAGRAM::dns qdcount]\"\n  }\n  if { [IP::protocol] == 17 } {\n    log local0. \"UDP Payload Length = [DATAGRAM::udp payload_length] Payload: [DATAGRAM::udp payload 100]\"\n    log local0. \"DNS Header fields ID: [DATAGRAM::dns id] QR: [DATAGRAM::dns qr] OPCODE: [DATAGRAM::dns opcode] QDCOUNT: [DATAGRAM::dns qdcount]\"\n  }\n}","returnValue":""},
{"commandName":"DATAGRAM::ip","description":"This iRules command returns ip header information.\n\nDATAGRAM::ip tos\n\n     * Returns IP header ToS as an integer value.\n\nDATAGRAM::ip ttl\n\n     * Returns IP header TTL as an integer value.\n\nDATAGRAM::ip flags\n\n     * Returns IP header flags as an integer value. The flags are from the\n       IP datagram after IP fragment reassembly. Any MF flags that were\n       present in indivdual fragments will not be returned. DF flag is\n       preserved if it was set.\n\nDATAGRAM::ip option\n\n     * This command returns a Tcl list of IP options from reassembled IP\n       datagram. Each option is a Tcl list with one or two values - option\n       code (integer), and option value (byte array) if option has the\n       value. Multiple options with the same code will be returned as\n       separate sublists. There are one or two byte IP options that do not\n       have any data - in this case only option code is present. If\n       datagram has no IP options an empty value is returned.\n\nDATAGRAM::ip option [option-code]\n\n     * This command returns a Tcl list of values for IP option with\n       specified option code from reassembled IP datagram. If option\n       occurs multiple times and has no data (1 or 2 byte option) then a\n       list of empty values is returned. If there is a single occurrence\n       of such option then empty value is returned. In this case\n       option_count must be used to detect presence of this option.\n\nDATAGRAM::ip option_count\n\n     * This command returns a number of IP options in the IP datagram.\n\nDATAGRAM::ip option_count [option-code]\n\n     * This command returns a number of IP options with specified option\n       code in the IP datagram.","examples":"","returnValue":""},
{"commandName":"DATAGRAM::ip6","description":"This iRules command returns ipv6 header information.\nNote: throws an error when used with IPv4\n\n\nDATAGRAM::ip6 hop_limit\n\n     * This command returns IPv6 hop limit as an integer value.\n\nDATAGRAM::ip6 option\n\n     * This command returns a Tcl list of IPv6 options from reassembled\n       IPv6 datagram. Each option is a Tcl list with one or two values -\n       option code (integer), and option value (byte array) if option has\n       the value. Multiple options with the same code will be returned as\n       separate sublists. There are one or two byte IPv6 options that do\n       not have any data - in this case only option code is present. If\n       datagram has no IPv6 options an empty value is returned. Options\n       are retrieved from all IPv6 options extension headers - Hop-By-Hop\n       and Destination headers.\n\nDATAGRAM::ip6 option [option-code]\n\n     * This command returns a Tcl list of values for IPv6 option with\n       specified option code from reassembled IPv6 datagram. If option\n       occurs multiple times and has no data (1 or 2 byte option) then a\n       list of empty values is returned. If there is a single occurrence\n       of such option then empty value is returned. In this case\n       option_count must be used to detect presence of this option.\n\nDATAGRAM::ip6 option_count\n\n     * This command returns a number of IPv6 options in the IPv6 datagram\n       extension headers.\n\nDATAGRAM::ip6 option_count [option-code]\n\n     * This command returns a number of IPv6 options with specified option\n       code in the IPv6 datagram extension headers.","examples":"","returnValue":""},
{"commandName":"DATAGRAM::tcp","description":"This iRules command returns tcp header information.\nNote: throws an error if L4 protocol of the current connection is not\nTCP\n\n\nDATAGRAM::tcp flags\n\n     * This command returns TCP header flags as an integer value.\n\nDATAGRAM::tcp option\n\n     * This command returns a Tcl list of TCP options. See\n       DATAGRAM::ip option for details on behavior.\n\nDATAGRAM::tcp option [option-code]\n\n     * This command returns a Tcl list of TCP option values for TCP option\n       with a given option code. See DATAGRAM::ip option for details\n       on behavior.\n\nDATAGRAM::tcp option_count\n\n     * This command returns a number of TCP options in the TCP header of\n       IP datagram.\n\nDATAGRAM::tcp option_count [option-code]\n\n     * This command returns a number of TCP options with specified option\n       code in the TCP hesder of IP datagram.\n\nDATAGRAM::tcp payload [<size>]\n\n     * Returns the content of the current TCP payload. If <size> is specified and more than <size>\n       bytes are available, only the first <size> bytes of collected data are returned.\n\nDATAGRAM::tcp payload_length\n\n     * Returns the length, in bytes, of the current TCP payload.\n\nDATAGRAM::tcp window\n\n     * This command returns TCP header window field as an integer value.","examples":"when FLOW_INIT {\n  if { [IP::protocol] == 6 } {\n    log local0. \"TCP Flow: [IP::client_addr] [TCP::client_port] --> [IP::local_addr] [TCP::local_port]\"\n    log local0. \"TCP Payload Length = [DATAGRAM::tcp payload_length] Payload: [DATAGRAM::tcp payload 100]\"\n  }\n}","returnValue":""},
{"commandName":"DATAGRAM::udp","description":"This iRules command returns UDP payload information.\nNote: throws an error if L4 protocol of the current connection is not\nUDP\n\nDATAGRAM::udp payload [<size>]\n\n     * Returns the content of the current UDP payload. If <size> is specified and more than <size>\n       bytes are available, only the first <size> bytes of collected data are returned.\n\nDATAGRAM::udp payload_length\n\n     * Returns the length, in bytes, of the current UDP payload.","examples":"when FLOW_INIT {\n  if { [IP::protocol] == 17 } {\n     log local0. \"UDP Flow: [IP::client_addr] [UDP::client_port] --> [IP::local_addr] [UDP::local_port]\"\n     log local0. \"UDP Payload Length = [DATAGRAM::udp payload_length] Payload: [DATAGRAM::udp payload 100]\"\n   }\n}","returnValue":""},
{"commandName":"DATAGRAM::l2","description":"This iRules command returns the L2 destination of an ingress frame.\n\nDATAGRAM::l2 dest","examples":"when FLOW_INIT {\n     set l2_dest [ DATAGRAM::l2 dest ]\n     log local0. \"L2 destination MAC $l2_dest\"\n}","returnValue":"Returns the L2 destination of an ingress frame."},
{"commandName":"DECOMPRESS::disable","description":"Disable DECOMPRESS feature on current flow.","examples":"","returnValue":""},
{"commandName":"DECOMPRESS::enable","description":"Enable DECOMPRESS feature on current flow.","examples":"","returnValue":""},
{},
{},
{"commandName":"DHCP::version","description":"This command returns DHCP version number (4 or 6) of DHCP packet\n\nDetails (syntax):\nDHCP::version","examples":"when CLIENT_DATA {\n        log local0. \"Version [DHCP::version]\"\n    }","returnValue":"This command returns version number (4 or 6) of DHCP packet"},
{"commandName":"DHCPv4::chaddr","description":"This command returns chaddr (client hardware address) from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::chaddr","examples":"when CLIENT_DATA {\n        log local0. \"Chaddr [DHCPv4::chaddr]\"\n    }","returnValue":"This command returns chaddr (client hardware address) from DHCPv4 message"},
{"commandName":"DHCPv4::ciaddr","description":"This command returns ciaddr (client ip address) from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::ciaddr","examples":"when CLIENT_DATA {\n        log local0. \"Ciaddr [DHCPv4::ciaddr]\"\n    }","returnValue":"This command returns ciaddr (client ip address) from DHCPv4 message"},
{"commandName":"DHCPv4::drop","description":"This command drops DHCPv4 message silently\n\nDetails (syntax):\nDHCPv4::drop","examples":"when CLIENT_DATA {\n        DHCPv4::drop\n    }","returnValue":""},
{"commandName":"DHCPv4::giaddr","description":"This command returns giaddr (gateway or relay IP) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4:: giaddr","examples":"when CLIENT_DATA {\n        log local0. \"Giaddr [DHCPv4::giaddr]\"\n    }","returnValue":"This command returns giaddr (gateway or relay IP) field from DHCPv4 message"},
{"commandName":"DHCPv4::hlen","description":"This command returns hlen (hardware len) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::hlen","examples":"when CLIENT_DATA {\n        log local0. \"Hlen [DHCPv4::hlen]\"\n    }","returnValue":"This command returns hlen (hardware len) field from DHCPv4 message"},
{"commandName":"DHCPv4::hops","description":"This command returns hops (number of hops) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::hops","examples":"when CLIENT_DATA {\n        log local0. \"Hops [DHCPv4::hops]\"\n    }","returnValue":"This command returns hlen (hardware len) field from DHCPv4 message"},
{"commandName":"DHCPv4::htype","description":"This command returns htype (hardware type) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::htype","examples":"when CLIENT_DATA {\n        log local0. \"Htype [DHCPv4::htype]\"\n    }","returnValue":"This command returns htype (hardware type) field from DHCPv4 message"},
{"commandName":"DHCPv4::len","description":"This command returns the length of the DHCP packet length\n\nDetails (syntax):\nDHCPv4::len","examples":"when CLIENT_DATA {\n        log local0. \"Len [DHCPv4::len]\"\n    }","returnValue":"This command returns the length of the DHCP packet length"},
{"commandName":"DHCPv4::opcode","description":"This command returns opcode field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::opcode","examples":"when CLIENT_DATA {\n        log local0. \"Htype [DHCPv4::opcode]\"\n    }","returnValue":"This command returns opcode field from DHCPv4 message"},
{"commandName":"DHCPv4::option","description":"This command retrieves,sets or deletes the option by id number\n\nDetails (syntax);\nDHCPv4::option <id>\nDHCPv4::option <id> <value>\nDHCPv4::option delete <id>","examples":"when CLIENT_DATA {\n        log local0. \"Option [DHCPv4::option 18]\"\n    }","returnValue":"This command returns value by option id number when retrieving"},
{"commandName":"DHCPv4::reject","description":"This command drops the packet while sending ICMP packet about the drop reason\n\nDetails (syntax):\nDHCPv4::reject","examples":"when CLIENT_DATA {\n        DHCPv4::reject\n    }","returnValue":""},
{"commandName":"DHCPv4::secs","description":"This command returns xid(transaction ID) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::secs","examples":"when CLIENT_DATA {\n        log local0. \"Secs [DHCPv4::secs]\"\n    }","returnValue":"This command returns xid(transaction ID) field from DHCPv4 message"},
{"commandName":"DHCPv4::siaddr","description":"This command returns siaddr(server IP) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::siaddr","examples":"when CLIENT_DATA {\n        log local0. \"Siaddr [DHCPv4::siaddr]\"\n    }","returnValue":"This command returns siaddr(server IP) field from DHCPv4 message"},
{"commandName":"DHCPv4::type","description":"This command returns type of DHCPv4 message\n\nDetails (syntax):\nDHCPv4::type","examples":"when CLIENT_DATA {\n        log local0. \"Type [DHCPv4::type]\"\n    }","returnValue":"This command returns type of DHCPv4 message"},
{"commandName":"DHCPv4::xid","description":"This command returns xid(transaction ID) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::xid","examples":"when CLIENT_DATA {\n        log local0. \"Xid [DHCPv4::xid]\"\n    }","returnValue":"This command returns xid(transaction ID) field from DHCPv4 message"},
{"commandName":"DHCPv4::yiaddr","description":"This command returns yiaddr(your IP) field from DHCPv4 message\n\nDetails (syntax):\nDHCPv4::yiaddr","examples":"when CLIENT_DATA {\n        log local0. \"Yiaddr [DHCPv4::yiaddr]\"\n    }","returnValue":"This command returns yiaddr(your IP) field from DHCPv4 message"},
{"commandName":"DHCPv6::drop","description":"This command drops DHCPv6 message silently\n\nDetails (syntax):\nDHCPv6::drop","examples":"when CLIENT_DATA {\n        DHCPv6::drop\n    }","returnValue":""},
{"commandName":"DHCPv6::hop_count","description":"This command returns hop-count field from DHCPv6 relay message\n\nDetails (syntax):\nDHCPv6::hop_count","examples":"when CLIENT_DATA {\n        log local0. \"Hop-count [DHCPv6::hop_count]\"\n    }","returnValue":"This command returns hop-count field from DHCPv6 relay message"},
{"commandName":"DHCPv6::len","description":"This command returns the length of the DHCP packet length\n\nDetails (syntax):\nDHCPv6::len","examples":"when CLIENT_DATA {\n        log local0. \"Len [DHCPv6::len]\"\n    }","returnValue":"This command returns the length of the DHCP packet length"},
{"commandName":"DHCPv6::link_address","description":"This command returns link address field from DHCPv6 RELAY message\n\nDetails (syntax):\nDHCPv6::link_address","examples":"when CLIENT_DATA {\n        log local0. \"Link_address [DHCPv6::link_address]\"\n    }","returnValue":"This command returns link address field from DHCPv6 RELAY message"},
{"commandName":"DHCPv6::msg_type","description":"This command returns message type field from DHCPv6 message\n\nDetails (syntax):\nDHCPv6::msg_type","examples":"when CLIENT_DATA {\n        log local0. \"Msg_type [DHCPv6::msg_type]\"\n    }","returnValue":"This command returns message type field from DHCPv6 message"},
{"commandName":"DHCPv6::option","description":"This command retrieves, sets or deletes the option by id\n\nDetails (syntax);\nDHCPv6::option <id>\nDHCPv6::option <id> <value>\nDHCPv6::option delete <id>","examples":"when CLIENT_DATA {\n        log local0. \"Option [DHCPv6::option 18]\"\n    }","returnValue":"when retrieving, this command returns the value of the option via option id"},
{"commandName":"DHCPv6::peer_address","description":"This command returns peer address field from DHCPv6 RELAY message\n\nDetails (syntax):\nDHCPv6::peer_address","examples":"when CLIENT_DATA {\n        log local0. \"Peer_address [DHCPv6::peer_address]\"\n    }","returnValue":"This command returns peer address field from DHCPv6 RELAY message"},
{"commandName":"DHCPv6::reject","description":"This command drops the packet while sending ICMP packet about the drop reason\n\nDetails (syntax):\nDHCPv6::reject","examples":"when CLIENT_DATA {\n        DHCPv6::reject\n    }","returnValue":""},
{"commandName":"DHCPv6::transaction_id","description":"This command returns transaction id field from DHCPv6 message\n\nDetails (syntax):\nDHCPv6::transaction_id","examples":"when CLIENT_DATA {\n        log local0. \"Transaction_id [DHCPv6::transaction_id]\"\n    }","returnValue":"This command returns transaction id field from DHCPv6 message"},
{},
{"commandName":"DIAMETER::command","description":"The DIAMETER::command gets or sets the command code in the Diameter message header.\n\n\nSyntax\nDIAMETER::command [new_command-code]","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER command, with code [DIAMETER::command]\"\n}","returnValue":"If new command-code value is not provided, returns command code of current Diameter message"},
{"commandName":"DIAMETER::is_request","description":"This iRule command returns true if the current message is a DIAMETER request.\nOtherwise, it returns false.\n\n\nSyntax\nDIAMETER::is_request","examples":"when DIAMETER_INGRESS {\n    if { [DIAMETER::is_request] } {\n        log local0. \"Request received\"\n    }\n}","returnValue":"TRUE or FALSE"},
{"commandName":"DIAMETER::is_response","description":"This iRule command returns true if the current message is a DIAMETER response.\nOtherwise, it returns false.\n\nThis command is the exact inverse of DIAMETER::is_request.\n\n\nSyntax\nDIAMETER::is_response","examples":"when DIAMETER_INGRESS {\n    if { [DIAMETER::is_response] } {\n        log local0. \"Response received\"\n    }\n}","returnValue":"TRUE or FALSE"},
{"commandName":"DIAMETER::length","description":"This iRule command returns the length of the current message,\nincluding the message header.\n\nThe value returned reflects the current length of the message at the\ninstant the iRule command is executed: if you store the length of a\nmessage in a variable and then modify the message, your stored length\nmay be incorrect.\n\n\nSyntax\nDIAMETER::length","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a Diameter message of [DIAMETER::length] bytes\"\n}","returnValue":""},
{"commandName":"DIAMETER::header","description":"This iRule command is used to get and set header fields in the current DIAMETER message.\n\n\nSyntax\n\nDIAMETER::header version [new-version]\n\n     * Get or set the version of this message.  This is an 8-octet\n       integer, from 0 to 255.\n\nDIAMETER::header rflag|request-flag [new-flag]\n\n     * Get or set the request indication flag of this\n       message.  Possible values are 1 (message is a request) and 0\n       (message is a response).\n\nDIAMETER::header pflag|proxiable-flag [newflag]\n\n     * Get or set the PROXIABLE flag of this message.  Possible values\n       are 1 (message may be relayed) and 0 (message must be locally\n       processed).  BIG-IP normally relays all messages regardless of\n       this flag's value.\n\nDIAMETER::header eflag|error-flag [newflag]\n\n     * get or set the ERROR flag of this message.  Possible values are\n       1 (message contains an error) and 0 (message is believed to be\n       well-formed).\n\nDIAMETER::header tflag|retransmitted-flag [newflag]\n\n     * get or set the POTENTIALLY RETRANSMITTED MESSAGE flag.\n       Possible values are 0 (first request) and 1 (message may have\n       been transmitted at least once already).\n\nDIAMETER::header flags [newflag]\n\n     * Get or set all flags.  This command updates or returns the\n       entire flags field, as an 8-octet integer.\n\nDIAMETER::header appid [newappid]\n\n     * Get or set the message's Application-ID.  This is a 4-octet\n       integer.\n\nDIAMETER::header hopid [newhopid]\n\n     * Get or set the message's hop-by-hop identifier.  This value is\n       a 4-octet integer.  This value can only be set in egress events\n       (DIAMETER_EGRESS, MR_EGRESS).\n\nDIAMETER::header endid [newendid]\n\n     * get or set end-to-end identifier","examples":"when DIAMETER_INGRESS {\n    if { [DIAMETER::header tflag] } {\n        log local0. \"Received a potentially retransmitted Diameter message\"\n    }\n}","returnValue":""},
{"commandName":"DIAMETER::payload","description":"This iRule command gets or sets the current DIAMETER message's\npayload, as a byte string.\n\n\nSyntax\n\nDIAMETER::payload\n\n     * returns message payload (all AVPs)\n\nDIAMETER::payload replace \"newpayload\"\n\n     * Replace existing payload with \"newpayload\". This is best used\n       for low-level manipulation of a message's structure.","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message, with payload [DIAMETER::payload]\"\n}","returnValue":""},
{"commandName":"DIAMETER::respond","description":"This iRule command creates and sends a new message to the client or\nserver.\n\nWhen called from clientside events, the new message is sent to the client.\nWhen called from serverside events, the new message is sent to the server.\n\n\nSyntax\nDIAMETER::respond \"version\" \"rflag\" \"pflag\" \"eflag\" \"tflag\" \"command-code\" \"application-id\" \"hopid\" \"endid\" \"payload\"\n\n   Note: 'payload' is the full payload of the message, as created by\n   concatenating multiple strings from 'DIAMETER::avp create'.","examples":"when DIAMETER_INGRESS {\n    # DIAMETER::avp create  \"avpname|code\" \"v\" \"m\" \"p\" \"vendorid\" \"data\" \"type\"\n    # 2 = DO_NOT_WANT_TO_TALK_TO_YOU\n    set goaway [DIAMETER::avp create \"disconnect-cause\" 0 1 0 0 2 integer32]\n    set version 1\n    # 282 = Disconnect-Peer-Request\n    set code 282\n    set origin_host [DIAMETER::avp create \"origin-host\" 0 1 0 0 \"bigip6.core.example.com\" string]\n    set origin_realm [DIAMETER::avp create \"origin-realm\" 0 1 0 0 \"example.com\" string]\n    set appid 16777215\n    set hopid 999999\n    set endid 888888\n\n    DIAMETER::respond $version 1 0 0 0 $code $appid $hopid $endid $origin_host$origin_realm$goaway\n    DIAMETER::drop\n}","returnValue":""},
{"commandName":"DIAMETER::retry","description":"This iRule command tries to send the Diameter message contained in the\nbinary array \"binary_message\".  This command, in conjunction with the\nDIAMETER::message command, can be used to write an iRule that will\nhold and retry messages.\n\nIf the optional argument \"across\" is specified as 1, the message will\nbe sent through the proxy and trigger the various iRule events.  If it\nis specified as 0, or not specified, the message will be sent directly\nand not experience any iRules, persistence, or other processing.\n\n\nSyntax\n\nDIAMETER::retry \"binary_message\" [across]","examples":"when DIAMETER_EGRESS {\n   if { [DIAMETER::is_request] } {\n      set saved_message([DIAMETER::header hopid]) [DIAMETER::message]\n   }\n}\n\nwhen DIAMETER_INGRESS {\n   if { [DIAMETER::is_response] } {\n         DIAMETER::retry $saved_message([DIAMETER::header hopid])\n         DIAMETER::drop\n   }\n}","returnValue":""},
{"commandName":"DIAMETER::message","description":"This iRule command returns the current Diameter message as a TCL\nstring object.  This includes both the header and the payload.\n\n\nSyntax\nDIAMETER::message","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message: [DIAMETER::message]\"\n}","returnValue":""},
{"commandName":"DIAMETER::state","description":"This iRule command returns the current state of the Diameter peer's\nconnection, as a string. There are five possible states:\n  * CLOSED - The connection is down\n  * WAIT_ICEA - still waiting for the initial CEA\n  * ROPEN - The connection has been reopened\n  * IOPEN - The connection is open for the first time\n  * CLOSING - The connection will soon be down\n\n\n\nSyntax\nDIAMETER::state","examples":"when DIAMETER_INGRESS {\n    if { [DIAMETER::state] == \"ROPEN\" } {\n        log local0. \"Received a DIAMETER message via a reopened connection\"\n    }\n}","returnValue":""},
{"commandName":"DIAMETER::drop","description":"This iRule command drops the current Diameter message quietly.\n\n\nSyntax\nDIAMETER::drop","examples":"when DIAMETER_INGRESS {\n    if { [DIAMETER::command 275] && [DIAMETER::is_request] } {\n        DIAMETER::drop\n    }\n}","returnValue":""},
{"commandName":"DIAMETER::disconnect","description":"This iRule command sends Disconnect-Peer-Request to the client (if run\non clientside) or to the server (if run on serverside).\n\n\nSyntax\nDIAMETER::disconnect \"origin-host\" \"origin-realm\" \"disconnect-cause\"","examples":"when DIAMETER_INGRESS {\n    # 2 = DO_NOT_WANT_TO_TALK_TO_YOU (RFC 6733 sec 5.4.3)\n    DIAMETER::disconnect \"bigip.core.example.com\" \"example.com\" 2\n}","returnValue":""},
{"commandName":"DIAMETER::session","description":"This iRule command gets or sets the value of session-id AVP (code 263)\nin the message.\n\n\nSyntax\nDIAMETER::session [new_session-id]","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message for session [DIAMETER::session]\"\n}","returnValue":""},
{"commandName":"DIAMETER::host","description":"This iRule command gets or sets the value of the origin-host (code\n264) or destination-host (code 293) AVP in the current message.\n\n\nSyntax\nDIAMETER::host origin|dest [new_host]","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message with origin host [DIAMETER::host origin]\"\n}","returnValue":""},
{"commandName":"DIAMETER::realm","description":"This iRule command gets or sets the value of the origin-realm (code 296) or\ndestination-realm (code 283) AVP in the current Diameter message.\n\n\nSyntax\nDIAMETER::realm origin|dest [new_realm]","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message with origin realm [DIAMETER::realm origin]\"\n}","returnValue":""},
{"commandName":"DIAMETER::result","description":"This iRule command gets or sets the value of the result-code (code\n268) attribute-value pair.\n\n\nSyntax\nDIAMETER::result [new_result-code]","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message with result code [DIAMETER::result]\"\n}","returnValue":""},
{"commandName":"DIAMETER::avp","description":"This iRule command gives access to set and get attribute-value pairs.\nSpecifics for each command are below in the syntax section.\n\nThe AVP upon which this command operates is specified in a flexible\nmanner.  An AVP name or code (usually) must be specified, and an\noptional index may be also specified.  Some commands also accept a\nvendor-id.  When a name is specified, it is converted to a code.\nNames are written as listed in RFC 3588, formatted as e.g.,\n\"HOST-IP-ADDRESS\".  AVP codes are 32-bit integer quantities.\n\nWhen an index is not specified, the first AVP having that code is\nselected.  This works exactly the same as specifying \"index 0\".\n\nWhen an index is specified, the Nth AVP having that code is selected.\n\nWhen an index and a nonzero vendor-id are specified, all of the\nmatching vendor-specific AVP groups are searched in order.  For\nexample, suppose the message is structured as follows:\n\n- Vendor-specific group AVP, vendor-ID 3375\n  - AVP, code 8, contents \"abc\"\n  - AVP, code 9, contents \"def\"\n- Vendor-specific group AVP, vendor-ID 32473\n  - AVP, code 10, contents \"ghi\"\n  - AVP, code 8, contents \"jkl\"\n- Vendor-specific group AVP, vendor-id 3375\n  - AVP, code 8, contents \"mno\"\n\nIf the iRule command reads:\n  DIAMETER::avp data get 8 octetstring index 1 vendor-id 3375\nthen the value returned will be the bytes \"mno\".\n\n\nCommon Parameters for several commands:\n\navpname|code\n\n     * AVP code number or name as defined in RFC 3588.\n\ntype\n\n   get, set and create takes TCL's string data and uses \"type\" to\n   interpret and store the TCL string. The \"type\" is one of the following:\n     * octetstring - data is the same TCL string of characters\n     * integer32 - data is a 32-bit integer\n     * unsigned32 - data is an unsigned 32-bit integer\n     * integer64 - data is a 64-bit integer\n     * unsigned64 - data is an unsigned 64-bit integer\n\n     * ip4 - data is 4 bytes of an ipv4 address, i.e., 1.2.3.4 is\n       stored as \"\\0x01\\0x02\\0x03\\0x04\".  The address in the AVP may\n       be preceded by a two-byte type tag as defined in RFC 6733\n       section 4.3.1; if so, the tag must be 1.\n     * ip6 - data is 16 bytes of an ipv6 address.  The address in the\n       AVP may be preceded by a two-byte type tag as defined in RFC\n       6733 section 4.3.1; if so, the tag must be 2.\n     * grouped - data is non-singular, derived, or grouped/nested\n       AVPs, and interpreted as a raw binary string. This works with\n       TCL's binary format ... command.  In many cases this is\n       equivalent to 'octetstring'.\n\n     * octet - deprecated, not an RFC3588 type\n     * string - deprecated, not an RFC3588 type\n\nsource\n\n   Normally, this command implicitly operates on the Diameter message\n   which is currently being processed.\n\n   If the 'source' argument is specified, the command will read from\n   the source argument instead.  This value must be a Diameter message\n   payload, with no header.  Instead of modifying the value given, a\n   modified copy of it will be returned as the value of the command.\n\n\n\nSyntax\n\nDIAMETER::avp codes [index \"avp-index\"] [source \"source-data\"]\n\n     * Return list of all AVP codes. If index is specified, return\n       only AVP at index.\n\nDIAMETER::avp count [avpname|code] [source \"source-data\"]\n\n     * Return how many AVPs would be selected. If code is not\n       specified, returns count of all AVPs in the message.\n\nDIAMETER::avp length \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Return the selected AVP's length.  The returned value includes\n       the header fields, body length, and padding.\n\nDIAMETER::avp vflag get \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Get vendor-specific bit\n\nDIAMETER::avp vflag set \"avpname|code\" \"new-vflag\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Set vendor-specific bit\n\nDIAMETER::avp mflag get \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Get \"M\" bit, indicating that processing of this AVP is mandatory.\n\nDIAMETER::avp mflag set \"avpname|code\" \"new-mflag\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Set \"M\" bit, indicating that processing of this AVP is mandatory.\n\nDIAMETER::avp pflag get \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Get \"P\" bit which indicates the need for encryption for end-to-end\n       security.\n\nDIAMETER::avp pflag set \"avpname|code\" \"new-pflag\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Set \"P\" bit which indicates the need for encryption for end-to-end\n       security.\n\nDIAMETER::avp flags get \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Get flags in unsigned char which is equivalent to VMP in binary\n       number.  For example, if all flag bits are set, this command\n       will return 7. This command makes iRule slightly faster when\n       all flags are to be retrieved.\n\nDIAMETER::avp flags set \"avpname|code\" \"new-flags\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Set flags in unsigned char which is equivalent to VMP in binary\n       number.\n\nDIAMETER::avp vendorid get \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Get the selected AVP's vendor-id.\n\nDIAMETER::avp vendorid set \"avpname|code\" \"new-vendorid\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Set the selected AVP's vendor-id.\n\nDIAMETER::avp data get \"avpname|code\" \"type\" [index \"avp-index\"] [source \"source-data\"]\nLTM version 11.3.0 and above:\nDIAMETER::avp data get \"avpname|code\" \"type\" [index \"index\"] [source \"source-data\"] [vendor-id \"vendor-id\"]\n\n     * Get the selected AVP's content and interprete it as \"type\".\n       \"type\" is one of the following: octetstring, integer32,\n       unsigned32, ip4, ip6, grouped.\n\n\nDIAMETER::avp data set \"avpname|code\" \"new-data\" \"type\" [index \"avp-index\"] [source \"source-data\"]\nLTM version 13.1.0 and above:\nDIAMETER::avp data set \"avpname|code\" \"new-data\" \"type\" [index \"avp-index\"] [source \"source-data\"] [vendor-id \"vendor-id\"]\n\n     * Set the selected AVP's content to \"new-data\". \"type\" is either\n       one of the following: octetstring, integer32, unsigned32, ip4,\n       ip6, grouped.\n\nDIAMETER::avp create \"avpname|code\" \"v\" \"m\" \"p\" \"vendorid\" \"data\" \"type\"\n\n     * Create new AVP and return the whole AVP as a binary, including\n       the AVP header.\n\nDIAMETER::avp read \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Return the whole selected AVP as a binary, including the AVP\n       header.\n\nDIAMETER::avp delete \"avpname|code\" [index \"avp-index\"] [source \"source-data\"]\n\n     * delete the selected AVP\n\nDIAMETER::avp replace \"avpname|code\" \"new-avp\" [index \"avp-index\"] [source \"source-data\"]\n\n     * replace the selected AVP with \"new-avp\"\n\nDIAMETER::avp insert \"avpname|code\" \"new-avp\" [index \"avp-index\"] [source \"source-data\"]\n\n     * insert new \"newavp\" just before the selected AVP.  If the\n       selected AVP does not exist, currently it will be appended at\n       end of all AVPs.  This specific behavior should not be\n       considered stable.\n\nDIAMETER::avp append \"avpname|code\" \"new-avp\" [index \"avp-index\"] [source \"source-data\"]\n\n     * Insert new \"new-avp\" just after the selected AVP.  If the\n       selected AVP does not exist, currently it will be appended at\n       the end of all AVPs.","examples":"when DIAMETER_EGRESS {\n     # Sets the flags of the AVP Product Name to 0 (for Vendor Specific, Mandatory, Protected and Reserved)\n     DIAMETER::avp flags set 269 0\n     # Checks that the flags are properly set (was a bug in 11.3, solved in 11.4)\n     log local0. \"AVP : [DIAMETER::avp flags get 269] \"\n     # Removes the Supported-Vendor-Id from the request\n     DIAMETER::avp delete 265\n}\n\nThe AVP 257 (\"Host-IP-Address\") is defined by RFC 3588 as type\n\"Address\", which starts the first two octets as the address type, and\nthe remaining as the actual ip4 4-octet or ip6 16-octet address. So to\ncreate and insert AVP 257 with the ipv4 address of 192.168.1.254, we\ncan use the following TCL command:\n\n  set my_avp_data [DIAMETER::avp create 257 0 1 0 0 [binary format Sc4 1 {192 168 1 254} ] grouped]\n  DIAMETER::avp insert 257 $my_avp_data","returnValue":""},
{"commandName":"DIAMETER::route_status","description":"The DIAMETER::route_status command returns the routing status of the current\n               message. Valid status are:\n                 * \"unprocessed\"\n                 * \"route found\"\n                 * \"no route found\"\n                 * \"dropped\"\n                 * \"queue full\"\n                 * \"no connection\"\n                 * \"connection closing\"\n                 * \"internal error\"\n\n               \"route found\" is based on the DIAMETER RouteTable finding a route. It is not\n               effected by the proxy’s ability to create a connection, so even if the\n               server is not listening on the specified address or marked down, it\n               still returns status as \"route found\" if the RouteTable is able to\n               find the route.\n               Only valid for DIAMETER Message Routing Framework (diametersession profile) in 13.0+\n\n            Syntax\n\n            DIAMETER::route_status","examples":"","returnValue":"Returns routing status of the current message"},
{"commandName":"DIAMETER::persist","description":"This iRule command returns the persistence key being used for the\ncurrent message. If new persist key is provided, the existing\npersistence key will be replaced. The value of the new key MUST be the\nvalue of a valid AVP in the message. An AVP attribute name should not\nbe given as the new key value.\n\nIf bidirection is specified as false, disable(d), no, 0, or is\nunspecified, then persistence is not bidirectional. If bidirection is\nspecified as true, enable(d), yes, or 1 this persistence entry is\nbidirectional.\n\nIf the \"reset\" sub-command is used, the persistence record associated\nwith the current message will be removed.\n\nWhen using this iRule command to set a persistence record, the\nassociated diameter session profile must be configured with the\nattribute persist-type set to custom or else the iRule will fail.\n\n\nSyntax\nDIAMETER::persist [new-persist-key] [bidirection]\nDIAMETER::persist reset","examples":"when DIAMETER_INGRESS {\n    log local0. \"Received a DIAMETER message, persistence key is [DIAMETER::persist]\"\n}","returnValue":""},
{"commandName":"DNS::additional","description":"This iRules command returns, inserts, removes, or clears RRs from the\nadditional section.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::additional [[insert|remove rr_obj] | clear]\n\n     * Returns, inserts, removes, or clears RRs from the additional\n       section. With no arguments, get tcl list of RR objs; with arg,\n       insert/remove RR tcl obj in the additional section or clear all RRs\n       from the additional section.","examples":"Change the TTL of all answer records and add a glue record\n\n    when DNS_RESPONSE {\n        set rrs [DNS::answer]\n        foreach rr $rrs {\n            DNS::ttl $rr 1234\n        }\n        set new_rr [DNS::rr \"bigip3900-30.f5net.com. 88 IN A 1.2.3.4\"]\n        DNS::additional insert $new_rr\n    }","returnValue":""},
{"commandName":"DNS::answer","description":"This iRules command returns, inserts, removes, or clears RRs from the\nanswer section.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::answer [[insert|remove rr_obj] | clear]\n\n     * Returns, inserts, removes, or clears RRs from the answer section.\n       With no arguments, get tcl list of RR objs; with arg, insert/remove\n       RR tcl obj in the answer section or clear all RRs from the answer\n       section.","examples":"# Change the ttl of all answer records and add a glue record\n            when DNS_RESPONSE {\n                set rrs [DNS::answer]\n                foreach rr $rrs {\n                    DNS::ttl $rr 1234\n                }\n                set new_rr [DNS::rr \"bigip3900-30.f5net.com. 88 IN A 1.2.3.4\"]\n                DNS::additional insert $new_rr\n            }\n\n            # Send one or more IP addresses for a response to an A query\n            # Use on an LTM virtual server with a DNS profile enabled\n            when DNS_REQUEST {\n                # Log query details\n                log local0. \"DNS question name: [DNS::question name],\n                    DNS question class: [DNS::question class],\n                    DNS question type: [DNS::question type]\"\n\n                # Generate an answer with two A records\n                DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.1\"\n                DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.2\"\n                # Stop further processing of the query after this iRule and send the answer to the client\n                DNS::return\n                return\n            }","returnValue":""},
{"commandName":"DNS::authority","description":"This iRules command returns, inserts, removes, or clears RRs from the\nauthority section.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::authority [[insert|remove rr_obj] | clear]\n\n     * Returns, inserts, removes, or clears RRs from the authority\n       section. With no arguments, get tcl list of RR objs; with arg,\n       insert/remove RR tcl obj in the authority section or clear all RRs\n       from the authority section.","examples":"# Insert an authority record in all responses\n            when DNS_RESPONSE {\n                DNS::authority insert [DNS::rr \"devcentral.f5.com. 88 IN SOA 1.2.3.4\"]\n            }","returnValue":""},
{"commandName":"DNS::class","description":"This iRules command gets or sets the resource record class field\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::class <rr_obj> [value]\n\n     * Gets or sets the resource record class field (e.g. IN, CH, HS)","examples":"# Set the class of all response records to IN (internet)\n            when DNS_RESPONSE {\n                set rrs [DNS::answer]\n                foreach rr $rrs {\n                    DNS::class $rr IN\n                }\n            }","returnValue":""},
{"commandName":"DNS::disable","description":"This iRules command sets the service state to disabled for the current\nDNS packet.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on license.\n\n\nSyntax\n\nDNS::disable <all|dns-express|dnsx|dnssec|gtm|gslb|bind|cache|rpz>\n\n     * Sets the service state to disabled for the current DNS packet\n       (reset to default for future packets)\n          + all - all services listed below\n          + dns-express/dnsx - DNS Express\n          + dnssec - DNS security extensions\n          + gtm/gslb - Global Traffic Manager\n          + bind - BIG-IP BIND\n          + cache - DNS caching\n          + rpz - DNS Cache Response Policy Zone enforcement","examples":"# Only use dns express to resolve requests from a specific ip,\n            # disable dns express for all other requests\n            when DNS_REQUEST {\n                DNS::disable dnsx\n                if { [IP::client_addr] equals \"192.168.1.245\" } {\n                    DNS::enable dnsx\n                }\n            }","returnValue":""},
{"commandName":"DNS::drop","description":"This iRules command drops the current DNS packet after the execution of\nthe event.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::drop\n\n     * Drops the current DNS packet after the execution of the event.","examples":"#Drop dns requests from a specific IP\n            when DNS_REQUEST {\n                if { [IP::client_addr] equals \"192.168.1.245\" } {\n                    DNS::drop\n                }\n            }","returnValue":""},
{"commandName":"DNS::edns0","description":"This iRules command gets (v11.0+) and sets (v11.1+) the values of the\nedns0 pseudo-RR.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::edns0 remove [<nsid|subnet>]\n\n     * Removes the entire EDNS0 psuedo-RR or just the nsid or subnet section, if specified.\n\nDNS::edns0 exists [<nsid|subnet>]\n\n     * Returns boolean for the presense of the EDNS0 psuedo-RR in the\n       current DNS packet. Specifying nsid or subnet returns a\n       boolean for the presense of the NSID or subnet option\n       respectively in the EDNS0 rdata.\n\n DNS::edns0 <do|sz|nsid> [value]\n\n     * Returns or sets the values of the edns0 pseudo-RR.\n          + do (DNSSEC)\n               o returns boolean of false if no edns0 RR, boolean for\n                 presence of DO flag, or integer for the UDP size\n          + sz (UDP Max Payload Size)\n               o returns boolean of false if no edns0 RR, boolean for\n                 presence of DO flag, or integer for the UDP size\n          + nsid (Nameserver ID, RFC 5001)\n               o returns a byte array: empty if an NSID query, non-empty\n                 containing NSID bytes\n\n       TCL_ERROR is returned if the command is called when there is\n       no edns0 or NSID field.\n\nDNS::edns0 subnet [<address|source|scope>] [value]\n     * v11.5+\n     * Returns or sets IP address, source or scope as specified by the argument\n       from the client-subnet option. Without an argument, returns an IP\n       address, Integer, and Integer, respectively for IP address, source,\n       and scope.","examples":"when DNS_REQUEST {\n  if { [DNS::edns0 exists] } {\n    log local0. [DNS::edns0 subnet address]\"\n  }\n}","returnValue":""},
{"commandName":"DNS::enable","description":"This iRules command sets the service state to enabled for the current\nDNS packet.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::enable <all|dns-express|dnsx|dnssec|gtm|gslb|bind|cache|rpz>\n\n     * Sets the service state to enabled for the current DNS packet (reset\n       to default for future packets)\n          + all - all services listed below\n          + dns-express/dnsx - DNS Express\n          + dnssec - DNS security extensions\n          + gtm/gslb - Global Traffic Manager\n          + bind - BIG-IP BIND\n          + cache - DNS caching\n          + rpz - DNS Cache Response Policy Zone enforcement","examples":"# Only use dns express to resolve requests from a specific ip,\n            # disable dns express for all other requests\n            when DNS_REQUEST {\n                DNS::disable dnsx\n                if { [IP::client_addr] equals \"192.168.1.245\" } {\n                    DNS::enable dnsx\n                }\n            }","returnValue":""},
{"commandName":"DNS::header","description":"This iRules command gets or sets simple bits or byte fields. Read-only\nform introduced in v11.0, Read-write capability added in v11.1.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::header <id|qr|opcode|aa|tc|rd|ra|ad|cd|rcode|qdcount|ancount|nscount|arcount> [value]\n\n     * Gets or sets simple bits or byte fields. Return value is always an\n       integer except for successful recognition of the rcode or opcode\n       fields, where a string is returned\n          + rcode\n               o NOERROR\n               o FORMERR\n               o SERVFAIL\n               o NXDOMAIN\n               o NOTIMPL\n               o REFUSED\n               o YXDOMAIN\n               o YXRRSET\n               o NXRRSET\n               o NOTAUTH\n               o NOTZONE\n          + opcode\n               o QUERY\n               o IQUERY\n               o STATUS\n               o NOTIFY\n               o UPDATE","examples":"# Refuse all queries from a specific ip\n            when DNS_REQUEST {\n                if { [IP::client_addr] equals \"192.168.1.245\" } {\n                    DNS::answer clear\n                    DNS::header rcode REFUSED\n                    DNS::return\n                    return\n                }\n            }","returnValue":""},
{"commandName":"DNS::is_wideip","description":"This iRules command returns status (true/false) if a string is a\nconfigured wide IP.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\n    DNS::is_wideip <dns string>","examples":"when DNS_REQUEST {\n  if { [DNS::is_wideip [DNS::question name]] } {\n    log local0. \"[DNS::question name] is a wideIP\"\n  } else {\n      log local0. \"[DNS::question name] is not a wideIP\"\n  }\n}","returnValue":""},
{"commandName":"DNS::last_act","description":"This iRules command sets the action to perform if no DNS service\nhandles this packet\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::last_act <allow|drop|reject|hint|noerror>\n\n     * Sets the action to perform if no DNS service handles this packet\n       (aka Unhandled Query Action)","examples":"# Drop dns requests that are not handled by a local dns service\n            when DNS_REQUEST {\n                DNS::last_act drop\n            }","returnValue":""},
{"commandName":"DNS::len","description":"This iRules command returns the DNS packet message length.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::len\n\n     * Returns the DNS packet message length","examples":"# log the length of each packet\n            when DNS_RESPONSE {\n                DNS::log \"PacketLength: \" [DNS::len]\n            }","returnValue":""},
{"commandName":"DNS::log","description":"There are two version of this command.  DNS::log by itself returns a boolean indicating whether a DNS Logging Profile is configured in the DNS profile.  DNS::log with an argument logs a message to that log publisher.\n\nSyntax\n\n    DNS::log\n        * Returns a boolean indicating whether a DNS Logging Profile is configured in the DNS profile.\n\n    DNS::log [<message>]\n        * Logs a message to the DNS log publisher","examples":"# Send one or more IP addresses for a response to an A query\n            # Use on an LTM virtual server with a DNS profile enabled\n            when DNS_REQUEST {\n                # Log query details\n                DNS::log \"DNS question name: [DNS::question name],\n                    DNS question class: [DNS::question class],\n                    DNS question type: [DNS::question type]\"\n\n                # Generate an answer with two A records\n                DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.1\"\n                DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.2\"\n                # Stop further processing of the query after this iRule and send the answer to the client\n                DNS::return\n                return\n            }","returnValue":""},
{"commandName":"DNS::name","description":"This iRules command gets or sets the resource record name field.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::name <rr_obj> [value]\n\n     * Gets or sets the resource record name field (FQDN, e.g.\n       devcentral.f5.com)","examples":"# log all dns responses returned to a specific client ip\n            when DNS_RESPONSE {\n                if { [IP::client_addr] equals \"192.168.1.245\" } {\n                    DNS::log [DNS::name [DNS::answer]]\n                }\n            }","returnValue":""},
{"commandName":"DNS::origin","description":"Returns the last module to modify the DNS message. Return values:\n\nCLIENT\n\n   This message has just been received by the BigIP from a client's query,\n   and nothing has been processed.\n\nSERVER\n\n   This message has just been received by the BigIP from a server's\n   response to a DNS query, such as On-Box or Off-Box BIND, or another\n   BigIP entirely.\n\nCACHE\n\n   This message is a response from the DNS Cache.\n\nRPZ\n\n   This message is a response from the Response Policy Zone in your BigIP.\n   It was blocked and either NXDOMAIN or a Walled Garden was returned as a\n   response.\n\nGTM_BUILD\n\n   GTM built this response in it's entirety\n\nGTM_REWRITE\n\n   GTM did not build the response completely, but modified the response on\n   its way out\n\nDNSX\n\n   This means that the DNS Response received was answered by the BigIP's\n   DNS Express module.\n\nDNSSEC\n\n   This means that you queried for a DNSSEC type and got a DNSSEC-typed\n   answer. An example command is \"dig @1.2.3.4 example.com +dnssec DNSKEY\"\n\nLAST_ACTION\n\n   This means that \"Unhandled Query Action\" was the last thing to handle\n   this packet. So, for example, if you have this set to \"Reject\", then by\n   the time it gets to the \"Unhandled Query Action\", it will respond with\n   \"Status Refused\" and this originates from \"LAST_ACTION\"\n\nTCL\n\n   An iRule modified the DNS response.\n\nRATE_LIMITER\n\n\nSyntax\n\n    DNS::origin\n\n         * Returns the last module to modify the DNS message. Return values:\n              + CLIENT\n              + SERVER\n              + CACHE\n              + GTM_BUILD\n              + GTM_REWRITE\n              + DNSX\n              + DNSSEC\n              + LAST_ACTION\n              + TCL\n              + RPZ\n              + RATE_LIMITER","examples":"# Drop all requests that were not resolved by DNS Express\n            when DNS_RESPONSE {\n                if { [DNS::origin] ne \"DNSX\" } {\n                    DNS::drop\n                }\n            }","returnValue":"CLIENT\nSERVER\nCACHE\nGTM_BUILD\nGTM_REWRITE\nDNSX\nDNSSEC\nLAST_ACTION\nTCL\nRPZ\nRATE_LIMITER"},
{"commandName":"DNS::ptype","description":"This iRules command returns the type of the DNS packet.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::ptype\n\n     * returns the type of the DNS packet. Return values:\n          + QUESTION\n          + REFERRAL\n          + ANSWER\n          + NXDOMAIN\n          + NODATA","examples":"# When a NXDOMAIN response is going to be sent,\n            # instead attach a record to resolve to.\n            when DNS_RESPONSE {\n                if { [DNS::ptype] == \"NXDOMAIN\" } {\n                    DNS::header rcode NOERROR\n                    DNS::answer insert \"[DNS::question name]. 60 [DNS::question class] [DNS::question type] 192.168.1.245\"\n                }\n            }","returnValue":""},
{"commandName":"DNS::query","description":"This iRules command returns or constructs and sends a query to the\nDNS-Express database for a name and type (IN class only).\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::query <target> <name> <type> [dnssec]\n\n     * Returns a tcl list of RR tcl objects lists, one for each section:\n       Answer, Authority, & Additional.\n     * Constructs and sends a query to the DNS-Express database for a name\n       and type (IN class only. dnnsec is an option to get DNSSEC data.)\n          + target - dnsx only\n          + name (FQDN, e.g. devcentral.f5.com)\n          + type (e.g. A, AAA, MX, NS, PTR, etc.)\n          + dnssec (boolean)","examples":"Insert DNS Express response\n\n    when DNS_RESPONSE {\n        set rrsl [DNS::query dnsx nameserver.org SOA]\n        foreach rrs $rrsl {\n            foreach rr $rrs {\n                if { [DNS::type $rr] == \"SOA\" } {\n                    DNS::additional insert $rr\n                }\n            }\n        }\n    }","returnValue":""},
{"commandName":"DNS::question","description":"This iRules command gets (v11.0+) or sets (v11.1+) the question field\nvalue.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::question <name|type|class> [value]\n\n     * gets (v11.0+) or sets (v11.1+) the question field value.\n\n       Note: A question RR has no rdata and only requests with\n       qdcount == 1 are accepted. The return types for name, type,\n       and class are all strings. Type returns/accepts any of the\n       valid DNS types defined in the RFCs. The class\n       returns/accepts IN, CH, & HS.","examples":"when DNS_REQUEST {\n    log local0. \"my question name: [DNS::question name]\"\n}\n\nThe follow rule violates the DNS protocol in isolation since a client\nwon't understand the response (i.e., we changed the question name) but\nlet's assume there's intercept code in DNS_RESPONSE to handle it and\nrestore it to the original question name\n\nwhen DNS_REQUEST {\n        set my_rr [DNS::rr \"example.net A IN 10 1.2.3.4\"]\n        DNS::question name $my_rr\n}","returnValue":""},
{"commandName":"DNS::rdata","description":"This iRules command gets or sets the resource record rdata field\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::rdata <rr_obj> [value]\n\n     * Gets or sets the resource record rdata field","examples":"List for all different type of REsponse, the drat types returned:\n\n    when DNS_RESPONSE {\n         set rrs [DNS::answer]\n         foreach rr $rrs {\n             log local0. \"[DNS::rdata $rr]\"\n         }\n    }\n\nIf the VS is sending back an MX answer, for example, you will receive\nthe following:\n   <DNS_RESPONSE>: 10 mx1.free.fr\nThis is specially showing that the rdata is not a simple IP or text.\nFor some records like the MX, NAPTR, and few others, it can be more\ncomplex.","returnValue":""},
{"commandName":"DNS::return","description":"This iRules command skips all further processing after TCL execution\nand sends the DNS packet in the opposite direction.\nIn the DNS_REQUEST context, DNS::return signals that no further DNS\nresolution should occur for this request upon completion of the event.\nTo provide a useful response, resource record and header changes must\nbe made in the iRule. The next event triggered is the DNS_RESPONSE\nevent.\nIn the DNS_RESPONSE context, DNS::return sends a request back for\nadditional processing. This is typically done after the answer,\nauthority and additional sections have been cleared and the query\nchanged to obtain a different response. Great care must be taken to\navoid an infinite loop, which can easily occur if the query is not\nchanged before being returned to the resolver.\nIn both contexts, the use of DNS::return signals what to do after the\nevent has completed, but does not stop processing the current event.\n\nNote: This command should not be confused with the global command\nreturn which immediately exits the current event.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::return\n\n     * Skips all further processing after TCL execution and sends the dns\n       packet in the opposite direction.","examples":"# Send one or more IP addresses for a response to an A query\n# Use on an LTM virtual server with a DNS profile enabled\nwhen DNS_REQUEST {\n        # Log query details\n        log local0. \"\\[DNS::question name\\]: [DNS::question name],\\\n                \\[DNS::question class\\]: [DNS::question class],\n                \\[DNS::question type\\]: [DNS::question type]\"\n\n        # Generate an answer with two A records\n        DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.1\"\n        DNS::answer insert \"[DNS::question name]. 111 [DNS::question class] [DNS::question type] 1.1.1.2\"\n\n        # Stop further processing of the query after this iRule and send the answer to the client\n        DNS::return\n        return\n}","returnValue":""},
{"commandName":"DNS::rpz_policy","description":"Returns the RPZ (Response Policy Zones) policy associated with the DNS cache.\n\nThe possible return values are:\n    * \"\" (empty string) if RPZ is not configured.\n    * \"NXDOMAIN\" if RPZ is configured to return an NXDOMAIN response on a match.\n    * \"WG <walled garden name>\" if RPZ is configured to return a Walled Garden redirect on a match.\n\nSyntax\n\n    DNS::rpz_policy","examples":"when DNS_RESPONSE {\n     if { [DNS::origin] eq \"RPZ\"} {\n        log local0. \"[DNS::question name] resulted in an RPZ [DNS::rpz_policy]\"\n     }\n}","returnValue":"* \"\" (empty string) if RPZ is not configured.\n* \"NXDOMAIN\" if RPZ is configured to return an NXDOMAIN response on a match.\n* \"WG <walled garden name>\" if RPZ is configured to return a Walled Garden redirect on a match."},
{"commandName":"DNS::rr","description":"This iRules command creates a new resource record object with specified\nattributes or as a complete string.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::rr <<name> <type> <class> <ttl> <rdata...> | <string>>\n\n     * Creates a new resource record object with specified attributes or\n       as a complete string\n          + name FQDN, e.g. devcentral.f5.com\n          + type (A, NS, MD, MF, CNAME, SOA, MB, MG, MR, NULL, WKS, PTR,\n            HINFO, MINFO, MX, TXT, RP, AFSDB, X25, ISDN, RT, NSAP,\n            NSAP-PTR, SIG, KEY, PX, GPOS, AAAA, LOC, NXT, EID, NIMLOC,\n            SRV, ATMA, NAPTR, KX, CERT, A6, DNAME, SINK, OPT, APL, DS,\n            SSHFP, IPSECKEY, RRSIG, NSEC, DNSKEY, DHCID, NSEC3,\n            NSEC3PARAM, HIP, SPF, TKEY, TSIG, IXFR, AXFR, MAILB, MAILA,\n            ANY, ZXFR, or DLV)\n          + class (IN, CH, HS)\n          + ttl resource record ttl field\n          + rdata (dependent on type of RR, e.g. type \"A\", rdata will be\n            \"X.X.X.X\").","examples":"Change the TTL of all answer records and add a glue record\n\n    when DNS_RESPONSE {\n        set rrs [DNS::answer]\n        foreach rr $rrs {\n            DNS::ttl $rr 1234\n        }\n        set new_rr [DNS::rr \"bigip3900-30.f5net.com. 88 IN A 1.2.3.4\"]\n        DNS::additional insert $new_rr\n    }\n\nWhen an MX request is sent on test.intra domain, send a specific list\nof MX records, with additional resource records.\n\nwhen DNS_REQUEST {\n    if { ([string tolower [DNS::question type]] eq \"mx\")  &&  ([string tolower [DNS::question name]] eq \"test.intra\")} {\n    DNS::answer clear\n    set new_rr_1 [DNS::rr \"mx.test.intra 100 IN MX 100 mx1.test.intra\"]\n    set new_rr_2 [DNS::rr \"mx.test.intra\" MX IN 600 \"150 10.1.1.1\"]\n    set new_rr_1a [DNS::rr \"mx1.test.intra\" A IN 300 \"10.10.10.10\"]\n    set new_rr_2a [DNS::rr \"mx2.test.intra\" A IN 50 \"10.10.10.11\"]\n    DNS::answer insert $new_rr_1\n    DNS::additional insert $new_rr_1a\n    DNS::answer insert $new_rr_2\n    DNS::additional insert $new_rr_2a\n    DNS::header aa 1\n    DNS::return\n}\n}\n\nwhere you will see:\n\n{{dig @10.100.30.133 -t MX test.intra\n\n; <<>> DiG 9.6-ESV-R4-P3 <<>> @10.100.30.133 -t MX test.intra\n; (1 server found)\n;; global options: +cmd\n;; Got answer:\n;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 39264\n;; flags: qr aa rd; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 2\n;; WARNING: recursion requested but not available\n\n;; QUESTION SECTION:\n;test.intra.                    IN      MX\n\n;; ANSWER SECTION:\nmx.test.intra.          100     IN      MX      100 mx1.test.intra.\nmx.test.intra.          600     IN      MX      150 10.1.1.1.\n\n;; ADDITIONAL SECTION:\nmx1.test.intra.         300     IN      A       10.10.10.10\nmx2.test.intra.         50      IN      A       10.10.10.11\n\n;; Query time: 7 msec\n;; SERVER: 10.100.30.133#53(10.100.30.133)\n;; WHEN: Wed Nov 27 17:26:33 2013\n;; MSG SIZE  rcvd: 111\n}}","returnValue":""},
{"commandName":"DNS::scrape","description":"This iRules command allows users to walk over a DNS message and parse\nout information from the packet based on user supplied arguments.\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\n   Note: Returned RDATA and QNAME data will be in binary format. QNAME\n   data may be compressed. If you need ASCII/Uncompressed equivalent data,\n   please use \"DNS::rdata\" or \"DNS::question name\" respectively.\n\nDNS::scrape ANSWER <type|ttl|qname|qnamelen|rdata|rdatalen|class>+\n\n     * returns one or more of the specified keywords in the ANSWER section\n       as a list (or in the case of multiple fields, lists of lists.) the\n       field lists will be returned in the order specified.\n\nDNS::scrape AUTHORITY <type|ttl|qname|qnamelen|rdata|rdatalen|class>+\n\n     * returns one or more of the specified keywords in the AUTHORITY\n       section as a list (or in the case of multiple fields, lists of\n       lists.) the field lists will be returned in the order specified.\n\nDNS::scrape ADDITIONAL <type|ttl|qname|qnamelen|rdata|rdatalen|class>+\n\n     * returns one or more of the specified keywords in the ADDITIONAL\n       section as a list (or in the case of multiple fields, lists of\n       lists.) the field lists will be returned in the order specified.\n\nDNS::scrape ALL <type|ttl|qname|qnamelen|rdata|rdatalen|class>+\n\n     * returns one or more of the specified keywords in ALL sections (but\n       never the question section) as a list (or in the case of multiple\n       fields, lists of lists.) the field lists will be returned in the\n       order specified.","examples":"when DNS_RESPONSE {\n   foreach rr [DNS::scrape ANSWER type ttl qnamelen rdatalen] {\n     log local2. \"ANSWER: $rr\"\n   }\n   foreach rr [DNS::scrape AUTHORITY type ttl class qnamelen rdatalen] {\n     log local2. \"AUTHORITY: $rr\"\n   }\n   foreach rr [DNS::scrape ADDITIONAL type ttl class qnamelen rdatalen] {\n     log local2. \"ADDITIONAL: $rr\"\n   }\n }","returnValue":""},
{"commandName":"DNS::tsig","description":"This command manipulates the current DNS message and its TSIG resource\nrecord.\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::tsig exists\n\n     * Returns a boolean for the TSIG's existence in the message.\n\nDNS::tsig remove\n\n     * Removes the TSIG from the message.","examples":"when DNS_REQUEST {\n  if { [DNS::tsig exists] } {\n    DNS::tsig remove\n  }\n}","returnValue":""},
{"commandName":"DNS::ttl","description":"This iRules command gets or sets the resource record TTL field\n\nNote: This command requires the DNS Profile, which is only enabled as\npart of GTM or the DNS Services add-on.\n\n\nSyntax\n\nDNS::ttl <rr_obj> [value]\n\n     * Gets or sets the resource record TTL field","examples":"Change the TTL of all answer records and add a glue record\n\n    when DNS_RESPONSE {\n        set rrs [DNS::answer]\n        foreach rr $rrs {\n            DNS::ttl $rr 1234\n        }\n        set new_rr [DNS::rr \"bigip3900-30.f5net.com. 88 IN A 1.2.3.4\"]\n        DNS::additional insert $new_rr\n    }","returnValue":""},
{"commandName":"DNS::type","description":"This iRules command gets or sets the resource record type field\n\nNote: This command functions only in the context of LTM iRules and\nrequires the DNS Profile, which is only enabled as part of GTM or the\nDNS Services add-on.\n\n\nSyntax\n\nDNS::type <rr_obj> [value]\n\n     * Gets or sets the resource record type field (e.g. A, AAAA, MX,\n       NAPTR, etc)","examples":"Remove SOA records from section\n\n    when DNS_RESPONSE {\n        set rrs [DNS::answer]\n        foreach rr $rrs {\n            if { [DNS::type $rr] == \"SOA\" } {\n                DNS::answer remove $rr\n            }\n        }\n    }","returnValue":""},
{"commandName":"DOSL7::disable","description":"Disables blocking and detection of DoS attacks according to the ASM\nsecurity policy configuration. When enabled using DOSL7::enable,\ntransactions will be enforced according to the DoS L7 ASM policy\nconfiguration for both detection and prevention.\n\nSyntax\n\nDOSL7::disable","examples":"when IN_DOSL7_ATTACK {\n    DOSL7::disable\n}","returnValue":""},
{"commandName":"DOSL7::enable","description":"Enables blocking and detection of DoS attacks according to the ASM\nsecurity policy configuration. When disabled using DOSL7::disable,\ntransactions will bypass DoS L7 for both detection and prevention.\n\nSyntax\n\nDOSL7::enable [<dos-profile-name>]","examples":"when HTTP_REQUEST {\n    DOSL7::enable\n}","returnValue":""},
{"commandName":"DOSL7::slowdown","description":"Adds source IP extracted from current connection to greylist. TCP slowdown will be applied according to supplied RATE (in percents) and TIMEOUT (in seconds).\nA RATE represents amount of incoming data packets to be dropped to perform slowdown.\n\nSyntax\n\nDOSL7:slowdown RATE TIMEOUT","examples":"when HTTP_REQUEST {\n                 if { [HTTP::uri] contains \"heavy.php\" } {\n                     DOSL7::slowdown 30 60\n                 }\n             }","returnValue":""},
{"commandName":"DOSL7::is_mitigated","description":"Returns TRUE if certain HTTP request was mitigated by DOSL7.            \n\nSyntax\n\nDOSL7::is_mitigated","examples":"","returnValue":"Returns TRUE if request was mitigated"},
{"commandName":"DOSL7::is_ip_slowdown","description":"Returns TRUE if source IP exists in greylist table\n\nSyntax\n\nDOSL7::is_ip_slowdown","examples":"","returnValue":""},
{"commandName":"DOSL7::health","description":"Syntax\n\nDOSL7::health","examples":"","returnValue":"Return health value as integer. Lower values are good health. Bad health is value > 1^23."},
{"commandName":"DOSL7::profile","description":"This command returns the DOS profile from which the L7-DoS policy is\nextracted.\nNote:\n  * in 11.4, default policy returns empty string and if L7-DoS is\n    disabled, the <no-profile> string is returned.\n  * in 11.5+, default policy returns the one configured with the vip\n    and if L7-DoS is disabled, a null string is returned.\n\n\nSyntax\n\nDOSL7::profile","examples":"","returnValue":""},
{"commandName":"DSLITE::remote_addr","description":"Returns the remote DS-Lite tunnel endpoint IP address.\n\n\nSyntax\n\nDSLITE::remote_addr\n\n     * Returns the IP address of the host on the far end of the tunnel\n       endpoint","examples":"","returnValue":""},
{},
{},
{},
{},
{},
{},
{},
{"commandName":"FIX::tag","description":"This command can either retrieve tag value or update the mapping\nbetween senderCompID and a tag map data group. In latter case If a\nmapping is already defined in the profile attributes for\nsender-tag-map, it is overwritten by the iRule mapping.\n\n\nSyntax\n\nFIX::tag get <tag>\n\n     * Retrieves the value of the given tag. If the tag doesn't exist, an\n       empty string is returned.\n     * It is valid under FIX_MESSAGE event.\n\nFIX::tag map set <SenderCompID> <data_group>\n\n     * The set subcommand defines a tag mapping data group for a client\n       identified by SenderCompID, tag 49. It returns 0 if successful, non\n       zero otherwise.\n     * It is valid in any event.\n\nFIX::tag map delete\n\n     * The delete subcommand deletes the mappings for all clients. It\n       returns 0 if successful, non zero otherwise.\n     * It is valid in any event.","examples":"when RULE_INIT {\n  # with the follow command, tag 10001 is replaced to 20001 for the messages sent by client_1\n  # before sending to pool member and reverse-replaced(20001 to 10001) to client_1\n  FIX::tag map set client_1 data_group_1\n  FIX::tag map set client_2 data_group_1\n  FIX::tag map set client_3 data_group_2\n}\n### Supporting DataGroup ###\nFIX_tag_map_1 {\n{\n10001 {\"20001\"}\n10002 {\"20002\"}\n10003 {\"20003\"}\n}\n}\nFIX_tag_map_2 {\n{\n30001 {\"20001\"}\n30002 {\"20002\"}\n30003 {\"20003\"}\n}\n}","returnValue":""},
{"commandName":"FLOW::priority","description":"This command is used to overwrite the flow's internal packet priority.\nValid priority is any integer value from 0 to 7.","examples":"when CLIENT_ACCEPTED {\n  FLOW::priority clientside 2\n}\nwhen SERVER_CONNECTED {\n  FLOW::priority serverside 4\n}","returnValue":""},
{"commandName":"FLOWTABLE::count","description":"This iRules command returns flow counts\nNote: When virtual server or route domain name is omitted the commands\nuse virtual or route domain of the current connection. Specifying the\nname incurs significant performance hit.\n\n\nSyntax\n\nFLOWTABLE::count\n\n     * This command returns the current number of flows in the global flow\n       table on the tmm where it runs.\n\nFLOWTABLE::count virtual <virtual-name>\n\n     * This command returns the current number of flows associated with a\n       given LTM virtual server.\n\nFLOWTABLE::count route_domain <route-domain>\n\n     * This command returns the current number of flows associated with a\n       gived route domain.","examples":"","returnValue":""},
{"commandName":"FLOWTABLE::limit","description":"This iRules command returns configured connection limits\nNote: When virtual server or route domain name is omitted the commands\nuse virtual or route domain of the current connection. Specifying the\nname incurs significant performance hit.\n\n\n\nSyntax\n\nFLOWTABLE::limit virtual <virtual-name>\n\n     * This command returns the configured connection limit for a given\n       virtual server.\n\nFLOWTABLE::limit route_domain <route-domain>\n\n     * This command returns the configured connection limit for a given\n       route domain.","examples":"","returnValue":""},
{"commandName":"FTP::port","description":"This command allows control over the range of passive mode FTP\nephemeral ports.\n\nSyntax\nFTP::port <x> <y>\n\n   x - The first port available for passive mode port change selection.\n   y - The last port available for passive mode port change selection.","examples":"when SERVER_CONNECTED {\n  FTP::port 5000 5999\n}","returnValue":""},
{"commandName":"GENERICMESSAGE::message","description":"The GENERICMESSAGE::message command returns or sets values from\nthe current message being processed by the generic message profile.\n\nSyntax\n\nGENERICMESSAGE::message src [<src_addr>]\n\n   * Returns (or sets) the message's source address.\n\n   Note: read/write in GENERICMESSAGE_INGRESS,MR_INGRESS. Read-Only in\n   GENERICMESSAGE_EGRESS,MR_EGRESS,MR_FAILED\n\nGENERICMESSAGE::message dst [<dst_addr>]\n\n   * Returns (or sets) the message's destination address.\n\n   Note: read/write in GENERICMESSAGE_INGRESS,MR_INGRESS. Read-Only in\n   GENERICMESSAGE_EGRESS,MR_EGRESS,MR_FAILED\n\nGENERICMESSAGE::message is_request [true OR false]\n\n   * Returns true if the message is a request message, or can manually\n     identify the message with the true/false flag\n\n   Note: read/write only in GENERICMESSAGE_INGRESS\n\nGENERICMESSAGE::message length\n\n   * Returns the message size in bytes.\n\nGENERICMESSAGE::message text [<new_text>]\n\n   * Returns (or sets) the message's text.\n\nGENERICMESSAGE::message data [<new_data>]\n\n   * Returns (or sets) the message data (as an array of bytes)\n\nGENERICMESSAGE::message no_response [true OR false]\n\n     * Returns true if the message is asynchronous. An asynchronous message\n       does not expect a response message to correspond with the message.\n     * Setting this attribute to \"true\" disables storing response routing information\n       in the pending request store (see request_sequence_number).\n\nGENERICMESSAGE::message create [<text> [<destination_address>]]\n\n   * Creates a new empty message that can be sent. Once created a\n     TEXTMSG_INGRESS event shall be raised where the script writer will\n     be able to populate the message. Upon completion of the script, the\n     message will be forwarded for routing.\n\nGENERICMESSAGE::message drop <reason>\n\n   * Terminates processing of the current message.\n\nGENERICMESSAGE::message status\n\n   * Returns the route status. Please see MR::message status\n\nGENERICMESSAGE::message request_sequence_number [<number>]\n\n   * Returns the request_sequence_number used to save the last hop of a\n     request message. This will be valid during GENERICMESSAGE_EGRESS of\n     request messages. During GENERICMESSAGE_INGRESS of response\n     messages, it will contain the sequence number of the oldest\n     un-responded request.\n   * Sets the request_sequence_number used to save the last hop of a\n     request message. During GENERICMESSAGE_INGRESS, setting this field\n     will allow associting a response message with an un-responded\n     request message and the request message's lasthop will be used as\n     the next hop for the message.","examples":"when CLIENT_DATA {\n    GENERICMESSAGE::message create \"[TCP::payload]\"\n    TCP::payload 0 [TCP::payload length] \"\"\n    TCP::release\n    TCP::collect\n}\nwhen GENERICMESSAGE_INGRESS {\n    GENERICMESSAGE::message src us\n    GENERICMESSAGE::message dst them\n}\n\nwhen GENERICMESSAGE_EGRESS {\n    GENERICMESSAGE::message data \"[GENERICMESSAGE::message data] status: [GENERICMESSAGE::message status]\"\n}","returnValue":""},
{"commandName":"GENERICMESSAGE::peer","description":"The GENERICMESSAGE::peer command returns or sets the peer's route name\nin the message routing framework. The peer name will be automatically\nset as the source address of each message.\n\nSyntax\n\nGENERICMESSAGE::peer name\n\n   * Returns the peer's route name.\n\nGENERICMESSAGE::peer name <name>\n\n   * Sets the peer's route name.","examples":"when CLIENT_ACCEPTED {\n    GENERICMESSAGE::peer name \"[IP::remote_addr]:[TCP::remote_port]\"\n}","returnValue":"Returns the peer's route name."},
{"commandName":"GENERICMESSAGE::route","description":"The GENERICMESSAGE::route command allows you to add, delete, or lookup\nmessage routes.\n\nSyntax\n\nGENERICMESSAGE::route add [src <src_addr>] [dst <dst_addr>] peer <peer> [peer <peer>]*\n\n    * Adds a route to the current routing instance that the iRule context is\n      running in. (Note both ‘src’ and ‘source’ are acceptable. Likewise\n      ‘dst’, ‘dest’ and ‘destination’ are acceptable).\n\nGENERICMESSAGE::route delete [src <src_addr>] [dst <dst_addr>]\n\n    * Deletes a route from the current routing instance that the iRule context is\n      running in. (Note both ‘src’ and ‘source’ are acceptable. Likewise\n      ‘dst’, ‘dest’ and ‘destination’ are acceptable).\n\nGENERICMESSAGE::route lookup [src <src_addr>] [dst <dst_addr>]\n\n    * Returns a route matching the specified source address and\n      destination address in the instance that the iRule context is\n      running in. (Note both ‘src’ and ‘source’ are acceptable. Likewise\n      ‘dst’, ‘dest’ and ‘destination’ are acceptable).","examples":"when CLIENT_ACCEPTED {\n    GENERICMESSAGE::route add dst \"client-[IP::remote_addr]\" host \"[IP::remote_addr]:[TCP::remote_port]\"\n}","returnValue":""},
{"commandName":"GTP::clone","description":"Returns a cloned copy of the GTP message.","examples":"when CLIENT_ACCEPTED {\n    set payload [UDP::payload]\n    set t2 [GTP::parse $payload]\n    set t3 [GTP::clone $t2]\n    log local0. \"GTP type [GTP::header type -message $t3]\"\n    log local0. \"GTP teid [GTP::header teid -message $t3]\"\n}","returnValue":"Returns a cloned copy of the GTP message."},
{"commandName":"GTP::discard","description":"Discards the current message\n\nSyntax\n\nGTP::discard","examples":"when GTP_SIGNALLING_INGRESS {\n    GTP::discard\n}","returnValue":""},
{"commandName":"GTP::forward","description":"Forwards GTP message to peer flow.","examples":"when GTP_SIGNALLING_INGRESS {\n    set t2 [GTP::new 2 10]\n    GTP::forward $t2\n}","returnValue":""},
{"commandName":"GTP::header","description":"Allows for the parsing of GTP header information. UINT -- Unsigned\ninteger value of n bits. For n > 8, appropriate network to host byte\norder conversion happens transparently.\n\nSyntax\n\nGTP::header version\n\n     * GTPv1: 1 , GTPv2-C: 2\n\nGTP::header type\n\n     * GTPv1: UINT8 , GTPv2-C: UINT8\n\nGTP::header teid\n\n     * If absent, empty value is returned, not null\n\nGTP::header sequence\n\n     * If absent, empty value is returned, not null\n\nGTP::header npdu\n\n     * If absent, empty value is returned, not null","examples":"when GTP_SIGNALLING_INGRESS {\n    log local0. \"GTP version [GTP::header version]\"\n    log local0. \"GTP type [GTP::header type]\"\n}","returnValue":""},
{"commandName":"GTP::ie","description":"This set of commands allows for the parsing and interpretation of GTP\nIE elements.\n\nSyntax\n\nGTP::ie exists [<ie-path>]\n\n     * Helps verify if this IE exists. In the absence of ie-path, it\n       returns true, if at the least one IE element is present in the\n       message.\n\nGTP::ie count [-type <value>] [-instance <value>] [<ie-path>]\n\n   The count of IEs held by referred path is returned that matches the\n   given type & instance, if the options are provided. The path provides\n   the scope for counting. Path has to be the last argument to the\n   command. The absence of path argument sets the message as the scope,\n   hence count of all IEs in the message is returned. If \"-type \" is\n   provided, only those IEs that matches this type within the scope are\n   counted. If \"-instance \" is provided, only those IEs that matches this\n   instance within the scope are counted.\n   NOTE: The count happens at the given scope, implying it does not\n   include any embedded IEs in the count. Say message has 3 IEs and one of\n   which is grouped-IE. Here \"GTP::ie count\" returns 3. GTP::ie count\n   bearer_context Returns count of embedded IEs in the first\n   bearer-context in the message. GTP::ie count Returns count of all IEs\n   in the message. GTP::ie-count -type ip-address pdn-conn Return the\n   count of IP address IEs inside the first PDN connection IE in the\n   message. Only first PDN Connection is used as absence of index in path\n   defaults to 0.\n\nGTP::ie get instance <ie-path>\n\n   * Returns the instance value of this IE. For messages of version 1,\n   instance value is returned as 0.\n\nGTP::ie get length <ie-path>\n\n     * Returns the length in octets of value of this IE\n\nGTP::ie get encode_type <ie-path>\n\n     * Returns the type of encoding of the value.\n\nGTP::ie get value <ie-path>\n\n   Returns the value of this IE as the TclList object of following\n   elements in the same order as listed below:\n   type: UINT8 index: UINT8 length: UINT16 instance: UINT8 encode_type:\n   Constant string as one of the defined encode types. value:\n\nGTP::ie get list [-type <value>] [-instance <value>] [<ie-path>]\n\n   Returns list of IE objects in the contained scope. The scope is\n   provided by the path. path has to be the last argument. Absence of any\n   path set the message level as scope. * -type helps collect IEs that\n   matches this type value only. * -instance helps collect IEs of given\n   instance value only.\n   In case of messages of version 1, all elements are considered to have\n   instance value of 0. Each IE_object is same as the output for \"GTP::ie –value \"\n\nGTP::ie list\n\n    * Returns the list of all the IE elements contained in the message.\n\nGTP::ie info\n\n   List the following info for each IE supported in this version: * , , ,\n\nGTP::ie info\n\n   * Return the info as in GTP::ie info for the specified IE only.\n\nGTP::ie info\n\n   * Return the info as in GTP::ie info for the specified IE only.\n\nGTP::ie info -encode-type\n\n   * Returns only the encode type of the specified IE.\n\nGTP::ie info -encode-type\n\n   * Returns only the encode type of the specified IE.\n\nGTP::ie info -name\n\n   * Returns the name of specified IE.\n\nGTP::ie info -type\n\n   * Returns the type of specified IE.","examples":"when GTP_SIGNALLING_INGRESS {\n    if { [GTP::ie exists imsi:0] } {\n        log local0. \"GTP imsi [GTP::ie get value imsi:0]\"\n    }\n    log local0. \"Total number of top level IEs [GTP::ie count]\"\n    set ie_list [ GTP::ie get list]\n    foreach ie $ie_list {\n        log local0. \"IE $ie\"\n    }\n}","returnValue":""},
{"commandName":"GTP::length","description":"This value is returned as read from the message header.\n\nSyntax\n\nGTP::length","examples":"when GTP_SIGNALLING_INGRESS {\n    log local0. \"GTP length [GTP::length]\"\n}","returnValue":""},
{"commandName":"GTP::message","description":"Returns the entire GTP message.\n\nSyntax\n\nGTP::message","examples":"when GTP_SIGNALLING_INGRESS {\n    set t1 [GTP::message]\n    log local0. \"GTP type [GTP::header type -message $t1]\"\n}","returnValue":""},
{"commandName":"GTP::new","description":"Creates a new GTP message for given version & request-type.\nValid values for version are 1 or 2 only.\nRequest-type: A value less than 256.\nReturns a TCL object of type \"GTP-Message\"","examples":"when CLIENT_ACCEPTED {\n    set t2 [GTP::new 2 10]\n    log local0. \"GTP version [GTP::header version -message $t2]\"\n    log local0. \"GTP type [GTP::header type -message $t2]\"\n}","returnValue":"Returns a TCL object of type \"GTP-Message\""},
{"commandName":"GTP::parse","description":"Creates a new GTP message from a byte stream.\nReturns a TCL object of type \"GTP-Message\"","examples":"when CLIENT_ACCEPTED {\n    set payload [UDP::payload]\n    set t2 [GTP::parse $payload]\n    log local0. \"GTP type [GTP::header type -message $t2]\"\n    log local0. \"GTP teid [GTP::header teid -message $t2]\"\n}","returnValue":"Returns a TCL object of type \"GTP-Message\""},
{"commandName":"GTP::payload","description":"Returns the payload, either complete or partial, for G-PDU message.\nThis command returns an empty value, in case of non-G-PDU messages.\n\nSyntax\n\nGTP::payload\n\n   * Returns the entire payload for G-PDU message. This command returns an\n   empty value, in case of non-G-PDU messages.\n\nGTP::payload\n\n    * Returns COUNT bytes of the payload for G-PDU message, starting from the beginning.\n\nGTP::payload OFFSET COUNT\n\n    * Returns COUNT bytes of the payload for G-PDU message starting from OFFSET.  If OFFSET + COUNT exceeds the size of the payload, an error is raised.\n\nGTP::payload replace OFFSET COUNT NEW_VALUE\n\n    * Replaces COUNT bytes of the payload with NEW_VALUE, starting at OFFSET.","examples":"when CLIENT_ACCEPTED {\n    set payload [UDP::payload]\n    set t2 [GTP::parse $payload]\n    log local0. \"GTP version [GTP::header version -message $t2]\"\n    log local0. \"GTP type [GTP::header type -message $t2]\"\n    log local0. \"GTP teid [GTP::header teid -message $t2]\"\n}","returnValue":""},
{"commandName":"GTP::respond","description":"Sends this GTP message back to the remote node of this connection.\nIf this is clientside flow, send it back to client that initiated the connection.\nIf this is serverside flow, send it to the remote node that is connected to.","examples":"when CLIENT_ACCEPTED {\n    set t2 [GTP::new 2 10]\n    GTP::respond $t2\n}","returnValue":""},
{"commandName":"GTP::tunnel","description":"These commands parse the payload of G-PDU as IP datagram and return the\nvalues from IP header and TCP/UDP header.\nWhen parsed payload contains a value other than 4 or 6 for IP version,\nthe commands return an empty value. \"is_ip\" can be used to confirm if\nparser is considering the payload as ip-datagram or not. The commands\nreturn empty for non G-PDU messages.\ntcp_ and udp_ commands return empty value if the ip-proto in the\nip-datagram does not match. \"GTP::tunnel ip_proto\" may be used to\nverify before calling transport level commands.\n\nSyntax\n\nGTP::tunnel is_ip\n\n   * Returns true if the payload is an IP datagram\n\nGTP::tunnel ip_src\n\n   * Returns the tunnel's source IP\n\nGTP::tunnel ip_dst\n\n   * Returns the tunnel's destination IP\n\nGTP::tunnel ip_proto\n\n   * Returns the tunnel's IP protocol\n\nGTP::tunnel ip_version\n\n   * Returns the tunnel's IP version\n\nGTP::tunnel ip_length\n\n   * Returns the length (in bytes) of the tunnel's IP\n\nGTP::tunnel tcp_src_port\n\n   * Returns the tunnel's TCP source port\n\nGTP::tunnel tcp_dst_port\n\n   * Returns the tunnel's TCP destination port\n\nGTP::tunnel udp_src_port\n\n   * Returns the tunnel's UDP source port\n\nGTP::tunnel udp_dst_port\n\n   * Returns the tunnel's UDP destination port","examples":"when GTP_SIGNALLING_INGRESS {\n    log local0. \"GTP tunnel TCP src port [GTP::tunnel tcp_src_port]\"\n}","returnValue":""},
{"commandName":"HA::status","description":"This iRule command returns true or false based on whether the unit the\ncommand is executed on is active or standby in the context of the\ncommand used. The primary use-case is for iRules that utilize sideband\nor HSL commands. This can be used to prevent the standby from opening\nextra connections.\nA Virtual IP (VIP) is bound to a Traffic Group, which handles failover\nfor the VIP. A unit can, at the same time, be \"active\" for one\ntraffic-group and \"standby\" for a different traffic-group. This command\nwill return the correct value for the unit's active/standby state based\non the traffic-group state that handles the VS to which the iRule is\nbound.\n\n\nSyntax\n\nHA::status active\n\n     * Returns 1 (true) if the unit is currently active and 0 (false) if\n       the unit is currently standby\n\nHA::status standby\n\n     * Returns 1 (true) if the unit is currently standby and 0 (false) if\n       the unit is currently active. This will only be relevant in the\n       case where mirroring is active for the VS; otherwise an iRule won't\n       execute on a standby unit.","examples":"when CLIENT_ACCEPTED {\n    log local0. \"active: [HA::status active]\"\n    log local0. \"standby: [HA::status standby]\"\n}\n# /var/log/ltm log output:\n# <CLIENT_ACCEPTED>: active: 1\n# <CLIENT_ACCEPTED>: standby: 0\n\n\nwhen HTTP_REQUEST {\n    if { [HA::status active] } {\n        set hsl [HSL::open -publisher \"publisher-customer-abc\"]\n        HSL::send $hsl \"[IP::client_addr] -> [HTTP::host]/[HTTP::path]\"\n    }\n}","returnValue":"HA::status active\n\n     * Returns 1 (true) if the unit is currently active and 0 (false) if\n       the unit is currently standby\n\nHA::status standby\n\n     * Returns 1 (true) if the unit is currently standby and 0 (false) if\n       the unit is currently active. This will only be relevant in the\n       case where mirroring is active for the VS; otherwise an iRule won't\n       execute on a standby unit."},
{"commandName":"HSL::open","description":"Open a handle for High Speed Logging communication. After creating the\nconnection, send data on the connection using HSL::send.\n\nSyntax\n\nHSL::open -proto <UDP|TCP> -pool <poolname>\n\n     * Opens and returns a handle for High Speed Logging communication.\n       The handle can be used with HSL::send to send data over a\n       particular protocol (TCP or UDP) to a pool comprised of one or more\n       logging servers.\n\nHSL::open -publisher <publisher>\n\n     * Opens and returns a handle for High Speed Logging communication for\n       a log publisher configured in System->Logs->Configuration->Log\n       Publishers. The handle should be used with the HSL::send\n       command to send data to the publisher. introduced in v11.3\n\n   Note: The protocol is case sensitive and must be specified in all\n   uppercase letters. Prior to 11.1 the protocol value is not validated\n   when an iRule is saved, but will cause a run-time error when executed\n   for a connection if the protocol is not valid (UDP or TCP).\n   The pool name is not validated when an iRule is saved but will cause a\n   run-time error when executed if the pool does not exist.","examples":"#1\nwhen CLIENT_ACCEPTED {\n    set hsl [HSL::open -proto UDP -pool syslog_server_pool]\n}\nwhen HTTP_REQUEST {\n   # Log HTTP request via syslog protocol as local7.info; see RFC 3164 for moreinfo\n    HSL::send $hsl \"<190> [IP::local_addr] [HTTP::uri]\\n\"\n}\n\n#2\nwhen CLIENT_ACCEPTED {\n    set hsl [HSL::open -publisher /Common/lpAll]\n}\nwhen HTTP_REQUEST {\n    HSL::send $hsl \"<190> [IP::client_addr]:[TCP::client_port]->[IP::local_addr]:[TCP::local_port]; [HTTP::host][HTTP::uri]\"\n}","returnValue":""},
{"commandName":"HSL::send","description":"Send data via High Speed Logging\n\nSyntax\n\nHSL::send <handle> <data>\n\n     * Sends the specified data via High Speed Logging. The handle must\n       have been previously created with HSL::open.\n       Note that the BIG-IP does not specifically format the data in any way,\n       it just passes it on to the server.\n     * Returns 1 if the specified data has been sent and 0 otherwise.","examples":"when CLIENT_ACCEPTED {\n    set hsl [HSL::open -proto UDP -pool syslog_server_pool]\n}\nwhen HTTP_REQUEST {\n    # Log HTTP request as local7.info; see RFC 3164 Section 4.1.1 - \"PRI Part\" for more info\n    HSL::send $hsl \"<190> [IP::local_addr] [HTTP::uri]\\n\"\n}","returnValue":""},
{"commandName":"HTML::enable","description":"Enable the processing of HTML for this transaction.","examples":"when HTTP_RESPONSE {\n    if {$host == \"www.f5.com\"} {\n        HTML::enable\n    }\n    log local0. \"host: $host\"\n}","returnValue":"empty return code."},
{"commandName":"HTML::disable","description":"Disable the processing of HTML for this transaction.","examples":"when HTTP_RESPONSE {\n    if {$host == \"www.f5.com\"} {\n        HTML::disable\n    }\n    log local0. \"host: $host\"\n}","returnValue":"empty return code."},
{"commandName":"HTML::comment","description":"Queries, removes HTML comment or appends/prepends it by a string.\n\nHTML::comment\nReturn the entire HTML comment, including the opening and the closing delimiter.\n\nHTML::comment append <string>\nInsert a string after the closing delimiter of the HTML comment; when multiple appends are issued, the inserted strings are ordered according to the sequence of the append commands as they are issued for the given comment.\n\nHTML::comment prepend <string>\nInsert a string before the opening delimiter of the HTML comment; when multiple prepends are issued, the inserted strings are ordered according to the sequence of the prepend commands as they are issued for the given comment.\n\nHTML::comment remove\nRemove the HTML comment.","examples":"when HTML_COMMENT_MATCHED {\n    if { ! ( [HTML::comment] contains \"\\[\" ) } {\n        HTML::comment remove\n    }\n}\n\nwhen HTML_COMMENT_MATCHED {\n    HTML::comment append \"some_string\"\n}\n\nwhen HTML_COMMENT_MATCHED {\n    HTML::comment prepend \"some_string\"\n}","returnValue":"HTML::comment returns the entire HTML comment; others do not return anything."},
{"commandName":"HTML::tag","description":"Queries, removes and changes attribute/value pairs of this HTML tag.\n        \nHTML::tag append <data>\nInsert a string after the closing delimiter of the HTML tag; when multiple appends are issued, the inserted strings are ordered according to the sequence of the append commands as they are issued for the given tag.\n\nHTML::tag name\nReturn HTML tag name, where name is the HTML element if the tag is a start tag, and if the tag is an end tag, tag name returns \"/\" + the HTML element.\n\nHTML::tag prepend <data>\nInsert a string before the opening delimiter of the HTML tag; when multiple prepends are issued, the inserted strings are ordered according to the sequence of the prepend commands as they are issued for the given tag.\n\nHTML::tag remove\nRemove the HTML tag.\n                  \nHTML::tag attribute <name>\nHTML::tag attribute value <name>\nReturn the value of the attribute under this HTML tag.\n\nHTML::tag attribute count\nReturn the number of attributes in this HTML tag.\n\nHTML::tag attribute exists <name>\nReturn true if the HTML tag has the attribute identified by <name>\n\nHTML::tag attribute insert <name> <value>\nInsert a string of \"<name>=<value>\" pair at the end of the attributes, before the closing delimiter of the tag.\n\nHTML::tag attribute names\nReturn the names of all attributes in this HTML tag.\n\nHTML::tag attribute remove <name>\nRemove the attribute identified by <name> in this HTML tag.\n\nHTML::tag attribute replace <name> <value>\nReplace the existing value of the attribute, identified by <name>, with <value>.","examples":"Auto-submit Stock Symbol Lookup on Yahoo-Finance.\n\nThe iRule enables HTML on the root path and disables HTML everywhere else. The HTML iRule scans the HTML document as it streams from the backend server and raises HTML_TAG_MATCHED event when seeing it encounters the FORM start tag and the FORM end tag. Specifically, the iRule looks for the form that has an attribute ID with a value \"quote\". Once this form is found, the iRules remembers it and injects a piece of Javascript after the first FORM end tag.\n\nwhen HTTP_REQUEST {\n    set uri [HTTP::uri]\n    HTTP::header replace \"Host\" \"finance.yahoo.com\"\n}\n\nwhen HTTP_RESPONSE {\n    if { $uri equals \"/\" } {\n        HTML::enable\n    } else {\n        HTML::disable\n    }\n}\n\nwhen HTML_TAG_MATCHED {\n    log local0. \"element = [HTML::tag name]\"\n    log local0. \"attribute id = [HTML::tag attribute id]\"\n    switch [HTML::tag name] {\n        \"form\" {\n            if { [HTML::tag attribute \"id\"] equals \"quote\" } {\n                set inject_js 1\n            }\n        }\n\n        \"/form\" {\n            if { [info exists inject_js] && $inject_js == 1 } {\n                unset inject_js\n                HTML::tag append \"<scr\"\n                HTML::tag append \"ipt>\"\n                HTML::tag append \"function submitForm() {\"\n                HTML::tag append \"  document.quote.s.value='FFIV';\"\n                HTML::tag append \"  document.quote.submit();\"\n                HTML::tag append \"}\"\n                HTML::tag append \"setTimeout('submitForm()', 5000);\"\n                HTML::tag append \"</script>\"\n            }\n        }\n    }\n}","returnValue":"\"HTML::tag name\" returns tag name.\n\"HTML::tag attribute value <name>\" returns the value of the attribute under this HTML tag.\n\"HTML::tag attribute count\" returns the number of attributes in this HTML tag.\n\"HTML::tag attribute exists <name>\" returns true if the HTML tag has the attribute identified by <name>."},
{"commandName":"HTTP::reject_reason","description":"This returns the reason HTTP aborted the connection, either as a string, or as a numeric id suitable for an error code.","examples":"when HTTP_REJECT {\n    log local0. \"HTTP Aborted:\" [HTTP::reject_reason]\n    log local0. \"Error code:\" [HTTP::reject_reason as_num]\n}","returnValue":""},
{"commandName":"HTTP::cookie","description":"Queries for or manipulates cookies in HTTP requests and responses. This command replaces the BIG-IP 4.X variable http_cookie.\n\nSyntax\n\nHTTP::cookie names\n\n    * Returns a TCL list containing the names of all the cookies present in the HTTP headers.\n\nHTTP::cookie count\n\n    * Returns the number of cookies present in the HTTP headers.\n\nHTTP::cookie [value] [string]\n\n    * Sets or gets the value of an existing cookie with the given name. You can omit the keyword \"value\" from this command if the cookie name does not collide with any of the other commands. If the cookie does not exist when retrieving a cookie value, a null string will be returned.\n\nHTTP::cookie version [version]\n\n    * Gets or sets the version of the cookie. If a version 0 cookie is created using HTTP::cookie insert with attributes, attempting to set the version with this command will generate a TCL error.\n\nHTTP::cookie path [path]\n\n    * Sets or gets the cookie path.\n\nHTTP::cookie domain [domain]\n\n    * Sets or gets the cookie domain.\n\nHTTP::cookie ports [portlist]\n\n    * Sets or gets the cookie port lists for Version 2 cookies.\n\nHTTP::cookie insert name value [path ] [domain ] [version <0 | 1 | 2>]\n\n    * In an HTTP response, adds an additional Set-Cookie header. In an HTTP request, adds an additional Cookie header (tested in 10.2.4). To make the request compliant with RFC 6265, use HTTP::header for cookie insertion. The default value for the version is 0. If the cookie already exists, a second cookie will be inserted (tested in 9.2.4).\n\nHTTP::cookie remove\n\n    * Removes a cookie.\n\nHTTP::cookie sanitize [attribute]+\nHTTP::cookie sanitize <-attributes|-names>\n\n    * Removes all but the specified attributes from the specified cookie. If no attributes are specified, then the cookie attributes are not modified. The second format above is strictly for versions 11.0 and greater.\n\nHTTP::cookie exists\n\n   * Returns a true value if the cookie exists.\n\nHTTP::cookie maxage [seconds]\n\n    * Sets or gets the max-age. Applies to Version 1 and 2 cookies only, and applies to responses only.\n\nHTTP::cookie expires [seconds] [absolute | relative]\n\n    * Sets or gets the expires attribute. Applies to Version 0 cookies only. If you specify the absolute argument, the seconds value represents number of seconds since the UNIX epoch (January 1, 1970). The default number of seconds is relative, which is the number of seconds from the current time. Applies to responses only.\n\nHTTP::cookie comment [comment]\n\n    * Sets or gets the cookie comment. Applies to Version 1 and 2 cookies only, and applies to responses only.\n\nHTTP::cookie secure [enable | disable]\n\n    * Sets or gets the value of the \"secure\" attribute. Applies to responses only. 'HTTP::cookie secure ' returns \"enable\" or \"disable\" depending on whether the secure flag is set. If 'HTTP::cookie secure enable' is used on a cookie which already has the secure flag set, no change is made to the cookie.\n\nHTTP::cookie commenturl [commenturl]\n\n    * Sets or gets the comment URL. Applies only to Version 2 cookies, and applies to responses only.\n\nHTTP::cookie encrypt [\"128\" | \"192\" | \"256\"]\n\n    * Encrypts the value for the given cookie using a key generated from the pass phrase. The default key length is 128. The encryption method is AES. For an example, check the Codeshare rule, EncryptingCookies.\n    Note that the performance of HTTP::cookie encrypt|decrypt is significantly lower than encrypting|decrypting cookies via a custom HTTP profile's cookie encryption option or using AES::encrypt|AES::decrypt to manually encrypt|decrypt the cookie values. This is due to differences in the encryption key generation.\n\nHTTP::cookie decrypt [\"128\" | \"192\" | \"256\"]\n\n    * Decrypts the value for the given cookie using a key generated from the pass phrase. The default key length is 128. The encryption method is AES. For an example, check the Codeshare rule, EncryptingCookies.\n    Note that the performance of HTTP::cookie encrypt|decrypt is significantly lower than encrypting|decrypting cookies via a custom HTTP profile's cookie encryption option or using AES::encrypt|AES::decrypt to manually encrypt|decrypt the cookie values. This is due to differences in the encryption key generation.\n    Function returns the decrypted value.\n\nHTTP::cookie httponly [enable | disable]\n\n    * Sets or gets the value of the \"httponly\" attribute. Applies to responses only, applies to version 1 and 2 cookies only, available only in v11+. 'HTTP::cookie httponly ' returns \"enable\" or \"disable\" depending on whether the httponly flag is set. If 'HTTP::cookie httponly enable' is used on a cookie which already has the httponly flag set, no change is made to the cookie.","examples":"# Rename a cookie by inserting a new cookie name with the same value as the original.  Then remove the old cookie.\nwhen HTTP_REQUEST {\n\n   # Check if old cookie exists in request\n   if { [HTTP::cookie exists \"old-cookie-name\"] } {\n\n      # Insert a new cookie with the new name and old cookie's value\n      HTTP::cookie insert name \"new-cookie-name\" value [HTTP::cookie value \"old-cookie-name\"]\n\n      # Remove the old cookie\n      HTTP::cookie remove \"old-cookie-name\"\n   }\n}\n\n\n# Set the version to 1 first because HttpOnly can only be set for cookies with version 1 or 2 and the default version is 0:\n\n# Set HttpOnly on all LTM and app generated cookies\nwhen HTTP_RESPONSE {\n   set cookieNames [HTTP::cookie names]\n   foreach aCookie $cookieNames {\n      HTTP::cookie version $aCookie 1\n      HTTP::cookie httponly $aCookie enable\n   }\n}\n\n# Or just for one statically defined cookie:\nwhen HTTP_RESPONSE {\n   HTTP::cookie version myCookie 1\n   HTTP::cookie httponly myCookie enable\n}","returnValue":""},
{"commandName":"HTTP::close","description":"Closes the HTTP connection.\n\nSyntax\n\nHTTP::close\n\n     * Closes the HTTP connection. In a RESPONSE event, also inserts a\n       Connection: Close header. Note that OneConnect\n       transformations, if enabled, may modify the inserted header, but\n       the connection will still close.","examples":"when HTTP_REQUEST {\n  set method [HTTP::method]\n}\nwhen HTTP_RESPONSE {\n  # The current connection will close after a POST reply\n  if { $method eq \"POST\" } {\n    HTTP::close\n  }\n}","returnValue":""},
{"commandName":"HTTP::collect","description":"Collects an amount of HTTP body data, optionally specified with\nthe <length> argument. When the system collects the specified\namount of data, it calls the Tcl event HTTP_REQUEST_DATA or\nHTTP_RESPONSE_DATA. The collected data can be accessed via the\nHTTP::payload command.\n\nNote that this command cannot be called after any Tcl command that\nsends an HTTP response (e.g. redirect, HTTP::redirect, and\nHTTP::respond). A run-time error will result.\n\nCare must be taken when using HTTP::collect to not stall the\nconnection. For example, some clients expect a response (such as a \"100\nContinue\" header) from the server before they will send data. To avoid\na delay, you would need to send such a response (possibly via\nTCP::respond) in your iRule. Also, if you use HTTP::collect\nwithout specifying a length, you must have some non-HTTP event (e.g.\nAUTH_RESULT or NAME_RESOLVED) run HTTP::release, or HTTP\nprocessing will not continue, and the collected data will be discarded\nwhen the connection times out.\n\nIt is important to note that these semantics are different than\nthose of the TCP::collect and TCP::release commands. With\nTCP::collect, the event for processing the data (CLIENT_DATA)\nwill fire without TCP::release being called, whereas with\nHTTP::collect, the event (HTTP_REQUEST_DATA or\nHTTP_RESPONSE_DATA) will not fire without HTTP::release being\ncalled. Again, this is referring to using HTTP::collect without\nspecifying a length. If you do specify a length, then the\nHTTP_REQUEST_DATA or HTTP_RESPONSE_DATA event will fire without\ncalling HTTP::release.\n\nNote that although any size payload can theoretically be collected, the\nmaximum size of a Tcl variable in v9 and v10 is 4MB with a smaller\nfunctional maximum after charset expansion of approximately 1Mb. In\nv11, the maximum variable size was increased to 32Mb. Any payload\nmanipulation outside of calls to HTTP::payload should obey that\nlimit.\n\nThe second example below includes the best practice logic to\nenforce that limit, including the suppression of response chunking to\nallow more accurate determination of collect length.\nEven though it is possible to collect up to store up to 32Mb of data in\na variable, it is not recommended to do this without careful\nconsideration. If each connection can use 32Mb of memory, TMM can\nquickly run out of memory.\n\nNote that if multiple iRules invoke HTTP::collect simultaneously,\n(perhaps by being called by the same event in multiple iRule scripts)\nthen the result is undefined.  This is because the amount of payload\ncollected for the HTTP_REQUEST_DATA or HTTP_RESPONSE_DATA event cannot\nsatisfy the perhaps differing amounts wanted by the callers. iRules\nshould arbitrate amoungst themselves to prevent this situation from\noccuring, and have only one HTTP::collect call outstanding at a time.\n\n\nSyntax\n\nHTTP::collect\n\n     * Collects the entire HTTP body. Use caution when omitting the value\n       of the content length.\n\nHTTP::collect <length>\n\n     * Collects the amount of data that you specify with the <length>\n       argument. Use caution when specifying a value larger than the size\n       of the actual length. Doing so can stall the connection. If the\n       specified amount of data exceeds the amount in the Content-Length\n       response header, only the smaller amount will be collected.","examples":"when HTTP_RESPONSE {\nif {[HTTP::status] == 205}{\n      HTTP::collect [HTTP::header Content-Length]\n   }\n}\n\n\n# Collect a request payload\nwhen HTTP_REQUEST {\n\n  if {[HTTP::method] eq \"POST\"}{\n    # Trigger collection for up to 1MB of data\n    if {[HTTP::header \"Content-Length\"] ne \"\" && [HTTP::header \"Content-Length\"] <= 1048576}{\n      set content_length [HTTP::header \"Content-Length\"]\n    } else {\n        set content_length 1048576\n    }\n    # Check if $content_length is not set to 0\n    if { $content_length > 0} {\n      HTTP::collect $content_length\n    }\n  }\n}\nwhen HTTP_REQUEST_DATA {\n  # do stuff with the payload\n  set payload [HTTP::payload]\n}\n\n\n# Collect a response payload\nwhen HTTP_REQUEST {\n   # Prevent the server from sending a compressed response\n   # remove the compression offerings from the client\nHTTP::header remove \"Accept-Encoding\"\n\n   # Don't allow data to be chunked\nif { [HTTP::version] eq \"1.1\" } {\n\n      # Force downgrade to HTTP 1.0, but still allow keep-alive connections.\n      # Since 1.1 is keep-alive by default, and 1.0 isn't,\n      # we need make sure the headers reflect the keep-alive status.\n\n      # Check if this is a keep alive connection\n      if { [HTTP::header is_keepalive] } {\n\n         # Replace the connection header value with \"Keep-Alive\"\n         HTTP::header replace \"Connection\" \"Keep-Alive\"\n      }\n\n      # Set server side request version to 1.0\n      # This forces the server to respond without chunking\n      HTTP::version \"1.0\"\n   }\n}\nwhen HTTP_RESPONSE {\n\n  # Trigger collection for up to 1MB of data\n  if {[HTTP::header exists \"Content-Length\"] && [HTTP::header \"Content-Length\"]<= 1048576}{\n    set content_length [HTTP::header \"Content-Length\"]\n  } else {\n      set content_length 1048576\n  }\n  # Check if $content_length is not set to 0\n  if { content_length > 0} {\n    HTTP::collect $content_length\n  }\n}\nwhen HTTP_RESPONSE_DATA {\n  # do stuff with the payload\n  set payload [HTTP::payload]\n}","returnValue":""},
{"commandName":"HTTP::hsts","description":"This controls the HTTP Strict Transport Security feature options on a per-flow basis, overriding the configured values in the HTTP profile.","examples":"when HTTP_REQUEST {\n    if { [HTTP::uri] contains \"secure\"} {\n        HTTP::hsts mode enable\n        HTTP::hsts maximum-age 8600\n        HTTP::hsts include-subdomains disable\n        HTTP::hsts preload enable\n    }\n}\n\nwhen HTTP_RESPONSE_RELEASE {\n    log local0.debug \"HTTP Strict-Transport-Security header: [HTTP::hsts]\"\n}","returnValue":"If a value isn't given, the HTTP::hsts command will return the corresponding sub-commands currently configured value for this connection."},
{"commandName":"HTTP::disable","description":"Changes the HTTP filter from full parsing to passthrough mode. This\ncommand is useful when using an HTTP profile with an application that\nproxies data over HTTP. One use of this command is when you need to\ntunnel PPP over HTTP and disable HTTP processing once the connection\nhas been established.\n\nSyntax\n\nHTTP::disable\n\n     * Puts HTTP traffic filtering into passthrough mode (disabling the\n       HTTP proxy) for the lifetime of the TCP connection or until\n       HTTP::enable is called.\n     * Once in passthrough mode, further use of HTTP commands will throw\n       an error until the HTTP filter is re-enabled.\n     * When called from an HTTP event, the current event will continue.\n       Once the current HTTP event completes, all further HTTP events will\n       be disabled until the HTTP filter is re-enabled. For this reason,\n       it could be useful to ask the server to close the TCP connection\n       after answering the current HTTP request. This can be done by\n       replacing/inserting the current Connection header with Connection:\n       close.\n     * Using \"event disable\" will disable the current event which will\n       prevent execution of higher priority HTTP events. The event will\n       need to be re-enabled if the HTTP filter is re-enabled.\n\nHTTP::disable discard\n\n     * Same as 'HTTP::disable' but also discards the headers before\n       setting the HTTP filter into the passthrough mode (added in ~9.4?).","examples":"when HTTP_REQUEST {\npersist hash $key\nif { [string toupper [HTTP::method]] eq \"CONNECT\" } {\n\n      # Proxy connect method should continue as a passthrough\n      HTTP::disable\n\n      # Ask the server to close the connection after this request\n      HTTP::header replace Connection close\n   }\n}","returnValue":""},
{"commandName":"HTTP::enable","description":"Changes the HTTP filter from passthrough to full parsing mode. This\ncould be useful, for instance, if you need to determine whether or not\nHTTP is passing over the connection and enable the HTTP filter\nappropriately, or if you have a protocol that is almost but not quite\nlike HTTP, and you need to re-enable HTTP parsing after temporarily\ndisabling it.\nUse of this command can be extremely tricky to get exactly right; its\nuse is not recommended in the majority of cases.\nNote: This command does not function in certain versions of BIG-IP\n(v9.4.0 - v9.4.4). This issue is tracked as CR95437 and is fixed in\nBIG-IP v9.4.5.\n\nSyntax\n\nHTTP::enable\n\n     * Change the http filter from passthrough to full parsing mode. Puts\n       HTTP traffic filtering into full parsing mode (enabling the HTTP\n       proxy) for the lifetime of the TCP connection or until\n       HTTP::disable is called.","examples":"#\n# This iRule should be used with a forwarding virtual server.\n#\nwhen CLIENT_ACCEPTED {\n    HTTP::disable\n    TCP::collect 4 0\n    set server_hold 0\n    log local0. \"Buildup -- collecting data\"\n}\nwhen CLIENT_DATA {\n    # Since we're here, the clientside sent data first\n    log local0. \"Got client data\"\n\n    # Now see if this is a recognized HTTP command\n    set command [TCP::payload 4]\n    if { $command equals \"GET \" } {\n        log local0. \"HTTP traffic -- re-enabling HTTP processing\"\n        HTTP::enable\n        if { $server_hold eq 1 } {\n            serverside { TCP::release }\n        }\n        event SERVER_CONNECTED disable\n        event SERVER_DATA disable\n        return\n    }\n    log local0. \"Not HTTP -- staying in passthru\"\n    event disable all\n}\nwhen SERVER_CONNECTED {\n    log local0. \"Server connection established\"\n    TCP::collect\n    set server_hold 1\n}\nwhen SERVER_DATA {\n    log local0. \"Banner protocol -- staying in passthru\"\n    clientside { TCP::release }\n    TCP::release\n    event disable all\n}\nwhen HTTP_REQUEST {\nlog local0. \"Got request: [HTTP::uri]\"\n}","returnValue":""},
{"commandName":"HTTP::fallback","description":"Specifies or overrides the fallback host specified in the HTTP profile.\n\nSyntax\n\nHTTP::fallback <host>\n\n     * Specifies or overrides the fallback host specified in the HTTP\n       profile.","examples":"when LB_FAILED {\n  HTTP::fallback \"http://siteunavailable.mysite.com/\"\n}","returnValue":""},
{"commandName":"HTTP::header","description":"Queries or modifies HTTP headers. This command replaces the BIG-IP 4.X\nvariable http_header.\nThe header name is not case sensitive, so for example, 'HTTP::header\nvalue HTTP_HEADER_NAME' will match a header with the name HeAdEr_NaMe.\n\n\nSyntax\n\nHTTP::header [value] <name>\n\n     * Returns the value of the HTTP header named <name>.\n     * Returns a null string if the HTTP header named <name> does not\n       exist.\n     * Note that the command will operate on the value of the last header\n       if there are multiple headers with the same name.\n     * You may omit the value argument if the header name does not\n       collide with any of the HTTP::header subcommands.\n\nHTTP::header values <name>\n\n     * Returns a list of value(s) of the HTTP header named <name>. Note\n       that the command will return the values all of the headers as a Tcl\n       list if there are multiple headers with the same name. If there is\n       a single value for the HTTP header, that value will be returned.\n     * (This subcommand was added in v9.4.0)\n\n   Note: There is an issue where HTTP::header values can remove colons in\n   the header values it returns. The actual header values are unchanged.\n   This issue is tracked as CR98328 and has been fixed in 10.0.\n\nHTTP::header names\n\n     * Returns a list of all the headers present in the request or\n       response.\n     * In v9.4.0 and higher, multiple headers with the same name will be\n       listed multiple times.\n\nHTTP::header count [<name>]\n\n     * Returns the number of HTTP headers present in the request or\n       response. If is supplied, returns the number of HTTP headers\n       present in the request or response with that name.\n     * In v9.4.0 and higher, multiple headers with the same name will be\n       counted multiple times.\n\n   Note: Due to a bug described in CR114612, HTTP::header count doesn't\n   count the last header, so it is unintentionally zero-index based. This\n   was an issue at least in 9.4.x and possibly earlier (and later?). This\n   has been fixed in 9.4.8 and 10.0.0.\n\nHTTP::header at <index>\n\n     * Returns the HTTP header name that the system finds at the\n       zero-based index value.\n\nHTTP::header exists <name>\n\n     * Returns true if the named header is present and not empty on the\n       request or response.\n\nHTTP::header insert [\"lws\"] [<name> <value>]+\n\n     * Inserts the named HTTP header(s) and value(s) onto the end of the\n       HTTP request or response. The input can be a single header name and\n       value, or a list containing name value pairs [list name1 value1\n       name2 value2].\n     * If you specify '\"lws\"', the system adds linear white space to long\n       header values.\n\nHTTP::header lws\n\n     * Returns 1 if a header was encountered that had linear white space,\n       and 0 otherwise. See RFC2616 for more information on lws and HTTP\n       headers.\n\nHTTP::header is_keepalive\n\n     * A synonym for HTTP::is_keepalive.\n\nHTTP::header is_redirect\n\n     * A synonym for HTTP::is_redirect.\n\nHTTP::header replace <name> [<string>]\n\n     * Replaces the value of the last occurrence of the header named\n       <name> with the string <string>. This command performs a header\n       insertion if the header was not present. If there are multiple\n       instances of the header, only the last instance is replaced.\n\nHTTP::header remove <name>\n\n     * Removes all headers names with the name <name>.\n\nHTTP::header insert_modssl_fields <addr port | addr addr addr | port port port>\n\n     * If \"addr port\" is specified, inserts the HTTP header\n       ClientIPAddress with the client IP and port as the value.\n     * If \"addr addr addr\" is specified, inserts the HTTP header\n       ClientIPAddress with the client IP only as the value.\n     * if \"port port port\" is specified, insertd the HTTP header\n       ClientTCPService with the client port as the value.\n     * This documents the implementation in v9.4.0 (and possibly earlier\n       versions), which is slightly buggy. The corrected syntax should be:\n       HTTP::header insert_modssl_fields [addr] [service | port] and\n       should behave intuitively.\n     * Note that this command is only for HTTP requests, not responses.\n\nHTTP::header sanitize [header name]+\n\n     * Removes all headers except the ones you specify and the following:\n       Connection, Content-Encoding, Content-Length, Content-Type,\n       Proxy-Connection, Set-Cookie, Set-Cookie2, and Transfer-Encoding.\n     * Note that the Host header (required by HTTP/1.1) is removed unless\n       explicitly specified.\n     * This command can be used in the client-side or server-side context,\n       depending on whether you want to sanitize request and/or response\n       headers.\n     * If you are using the command in the server-side context, you may\n       want to consider adding Location to the list of retained headers if\n       your application requires they be sent to clients.\n     * If you are using the command in the client-side context, you may\n       want to consider adding Cookie, Accept, and Accept-Encoding to the\n       list of retained headers.","examples":"when HTTP_REQUEST {\n  if { [HTTP::header \"Host\"] starts_with \"uat\" }  {\n    pool uat_pool\n  } else {\n    pool main_pool\n  }\n}\n\n\nwhen HTTP_RESPONSE {\n   # loop through and remove all instances of the unwanted\n   # headers from the server response\n   # (Server, X-Powered-By in this example)\nforeach header {Server X-Powered-By} {\n      log local0. \"Removing $header: [HTTP::header value $header]\"\n      HTTP::header remove $header\n   }\n}\n\n\nwhen HTTP_RESPONSE {\n   # test the new (as of 9.4.0) command, HTTP::header values <name>\n   #    for retrieving the values of multiple, identically named headers\nHTTP::header insert header_1 value_1\nHTTP::header insert header_1 value_2\nHTTP::header insert header_1 value_3\n\nlog local0. \"\\[HTTP::header header_1\\]: [HTTP::header header_1]\"\nlog local0. \"\\[HTTP::header value header_1\\]: [HTTP::header value header_1]\"\nlog local0. \"\\[HTTP::header values header_1\\]: [HTTP::header values header_1]\"\n}\n\nLogs:\n\n   [HTTP::header header_1]: value_3\n   [HTTP::header value header_1]: value_3\n   [HTTP::header values header_1]: value_1 value_2 value_3","returnValue":""},
{"commandName":"HTTP::host","description":"Returns the value contained in the Host header of an HTTP request. This\ncommand replaces the BIG-IP 4.X variable http_host.\nThe Host header always contains the requested host name (which may be a\nHost Domain Name string or an IP address), and will also contain the\nrequested service port whenever a non-standard port is specified (other\nthan 80 for HTTP, other than 443 for HTTPS). When present, the\nnon-standard port is appended to the requsted name as a numeric string\nwith a colon separating the 2 values (just as it would appear in the\nbrowser's address bar):\n  * Host: host.domain.com:8080\n\nRFC2616 (section 3.2.3) states that host header evaluation MUST be case\ninsensitive. So it is a good practice to set the Host header value to\nlower case before performing comparisons. This can be done using\n[string tolower [HTTP::host]].\n\nSyntax\n\nHTTP::host [name]\n\n     * Returns (or sets in v11.5+) the value of the Host header of an HTTP\n       request.","examples":"Both of the following examples redirect all requests containing the\nword \"secure\" to HTTPS. In this example, if a non-standard port is\nspecified, the non-standard port from the Host header value will be\nretained and the resulting redirect will be to the same non-standard\nHTTPS port specifying HTTPS as the scheme:\n\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] contains \"secure\"} {\n    HTTP::redirect \"https://[HTTP::host][HTTP::uri]\"\n }\n}\n\nIn this example, if a non-standard port is specified, the non-standard\nport from the Host header value will be removed and the resulting\nredirect will be to the standard HTTPS port specifying HTTPS as the\nscheme:\n\nwhen HTTP_REQUEST {\n  if { [HTTP::uri] contains \"secure\"} {\n    HTTP::redirect \"https://[getfield [HTTP::host] : 1][HTTP::uri]\"\n  }\n}\n\nTo update the Host header value without redirecting the client to the\nnew Host value, you can use HTTP::header replace Host\n   \"newhost.example.com\". This update will only affect the request to the\npool member. The client will not see the update unless the web\napplication uses the requested host header value to generate response\nheaders and/or content.\n\nwhen HTTP_REQUEST {\n\n   # Check if requested host doesn't start with www.example.com\nif {not ([string tolower [HTTP::host]] starts_with \"www.example.com\")}{\n\n      # Replace the host header value with newhost.example.com\n      HTTP::header replace Host \"newhost.example.com\"\n   }\n}\n\nHere is an another example of the a HTTP::host\n\nwhen HTTP_REQUEST {\n  if { [HTTP::host] equals\"www.xyz.com\"} {\n    HTTP::redirect \"http://www.abc.com/index.html\"\n  }\n}","returnValue":""},
{"commandName":"HTTP::is_keepalive","description":"Returns a true value if this is a Keep-Alive connection.\n\nSyntax\n\nHTTP::is_keepalive\n\n     * Returns a true value if this is a Keep-Alive connection. This\n       command is the synonymous with HTTP::header is_keepalive.","examples":"when HTTP_RESPONSE {\n  if {[HTTP::is_keepalive]}{\n    HTTP::close\n  }\n}\n\n\nwhen HTTP_REQUEST {\n  # Force downgrade to HTTP 1.0, but still allow keep-alive connections.\n  # Since 1.1 is keep-alive by default, and 1.0 isn't,\n  # we need make sure the headers reflect the keep-alive status.\n  if {[HTTP::version] == \"1.1\"} {\n    if {[HTTP::is_keepalive]} {\n      HTTP::header replace \"Connection\" \"Keep-Alive\"\n    }\n    HTTP::version \"1.0\"\n  }\n}","returnValue":""},
{"commandName":"HTTP::is_redirect","description":"Returns a true value if the response is a redirect. Since only\nresponses can be redirects, it does not make sense to use this command\nin a clientside event.\n\nSyntax\n\nHTTP::is_redirect\n\n     * Returns a true value if the response is a redirect. Note that\n       status codes 300 and 304 are not considered redirects by this\n       command. This command is synonymous with HTTP::header\n       is_redirect.\n\n     * The following response codes cause HTTP::is_redirect to return a\n       match (and all include a Location header directing the browser to\n       an alternate resource):\n\n     * 301 (Moved Permanently)\n     * 302 (Found)\n     * 303 (See Other)\n     * 305 (Use Proxy)\n     * 307 (Temporary Redirect)\n\n   Note: For pre-9.2.0 versions you can use HTTP::header is_redirect for\n   the same purpose.","examples":"when HTTP_RESPONSE {\n  if { [HTTP::is_redirect] } {\n    log local0. \"Request redirected.\"\n  }\n}","returnValue":""},
{"commandName":"HTTP::method","description":"Returns the type of HTTP request method. This command replaces the\nBIG-IP 4.X variable http_method.\n\nSyntax\n\nHTTP::method\n\n     * Returns the type of HTTP request method. Common HTTP methods are\n       described in RFC2616 Section 5.1.1.","examples":"Log the HTTP request method:\n\nwhen HTTP_REQUEST {\nlog local0. \"HTTP Method: [HTTP::method]\"\n}\n\nSample log output:\n\nRule: <HTTP_REQUEST>: HTTP Method: GET","returnValue":""},
{"commandName":"HTTP::passthrough_reason","description":"This command returns the reason for the most recent switch to\npass-through mode by the HTTP filter.\n\nSyntax\n\nHTTP::passthrough_reason\n\n     * Returns a string with one of the following values:\n          + Unknown\n          + iRule\n          + Connect\n          + Web Sockets\n          + Oversize Client Headers\n          + Excess Client Headers\n          + Oversize Server Headers\n          + Excess Server Headers\n          + Unknown Method\n          + Pipelined Data\n\nHTTP::passthrough_reason [<as_num>]\n\n     * Returns an integer code corresponding to which case in the above\n       list occurred, suitable for an error code.","examples":"when HTTP_DISABLED { log local2. [HTTP::passthrough_reason] }\nwhen HTTP_DISABLED { log local2. [HTTP::passthrough_reason as_num] }","returnValue":""},
{"commandName":"HTTP::password","description":"Returns the password part of HTTP basic authentication.\nAs described in RFC2617 the username and password in basic\nauthentication is sent by the client in the Authorization header. The\nclient base64 encodes the username and password in the format of:\nAuthorization: Basic base64encoding(username:password)\nThe HTTP::username command parses and base64 decodes the username.\nThe HTTP::password command parses and base64 decodes the password.\n\nSyntax\n\nHTTP::password\n\n     * Returns the password part of HTTP basic authentication.","examples":"# Small chunk of an iRule for radius authentication\nwhen HTTP_REQUEST {\n  AUTH::username_credential $auth_sid [HTTP::username]\n  AUTH::password_credential $auth_sid [HTTP::password]\n}\nwhen CLIENT_ACCEPTED {\n  set auth_sid [AUTH::start pam default_radius]\n}","returnValue":""},
{"commandName":"HTTP::path","description":"Returns or sets the path part of the HTTP request. The path is defined\nas the path and filename in a request. It does not include the query string.\nFor the following URL: http://www.example.com:8080/main/index.jsp?user=test&login=check\n\nThe path is: /main/index.jsp\n\nNote that only ? is used as the separator for the query string.\nSo, for the following URL: http://www.example.com:8080/main/index.jsp;session_id=abcdefgh?user=test&login=check\n\nThe path is: /main/index.jsp;session_id=abcdefgh\n\nSyntax\n\nHTTP::path\n\n     * Returns the path part of the HTTP request.\n\nHTTP::path <string>\n\n    *  Changes the path part of the HTTP request. Rewriting the path will only\n       affect the request to the pool member. The client will not see the update\n       unless the web application uses the requested path to generate response\n       headers and/or content. If you want the client to see the update to the\n       path in the browser's address bar, you can send an HTTP redirect using\n       HTTP::redirect or HTTP::respond.\n\n   Note: AskF5 SOL9952 describes a defect in path parsing when the request\n   includes an absolute URI in the Resource-URI field.\n\nHTTP::path -normalized\n    *  Returns the path normalized in a form for consistent comparisons.","examples":"Webmail redirect example: https://webmail.company.com is redirected to\nhttps://webmail.company.com/exchange. Redirected traffic then passes to\nthe webmail pool.\n\nwhen HTTP_REQUEST {\n  if { [HTTP::path] equals \"/\" } {\n    HTTP::redirect \"/exchange/\"\n    #log local0. \"redirect\"\n  } else {\n    pool pool_webmail\n    #log local0. \"using pool \"\n  }\n}\n\nTo set the path to lowercase, you can use the following example.\n\nwhen HTTP_REQUEST {\n  log local0. \"\\[HTTP::path\\] original: [HTTP::path]\"\n  HTTP::path [string tolower [HTTP::path]]\n}\n\nNote: Due to a bug in v10.0 - 10.2.0, HTTP::path truncates the HTTP\nquery string if present. The following rule can be used as a\nworkaround. This is described in CR142756.\n\nwhen HTTP_REQUEST {\n\n   # Check if there is a query string\nif {[HTTP::query] eq \"\"}{\n\n      # No query string, so set the entire URI to lower case\n      HTTP::uri [string tolower [HTTP::uri]]\n\n   } else {\n\n      # Set the path to lower case and append the string to it\n      HTTP::uri \"[string tolower [HTTP::path]]?[HTTP::query]\"\n   }\n}\n\nYou can use the BIG-IP as a primitive webserver. This uses a variable\ncalled $error_condition to decide to send an error page to the client,\nand a global class called $::logo_png_class. More information can be\nfound on creating that class at:\n   http://devcentral.f5.com/Default.aspx?tabid=53&view=topic&forumid=\n5&postid=9523\n\nwhen HTTP_REQUEST {\n  if { $error_condition==1 } {\n    # error condition was true, so respond back to client with html or image(s)\n    switch [string tolower [HTTP::path]] {\n      /image.png {\n        HTTP::respond 200 content [b64decode [lindex $::logo_png_class]] \"Content-Type\" \"image/png\"}\n      default {\n        HTTP::respond 200 content \"<html><title>Error</title><body>Error!<img src=/image.png></body></html>\"}\n    }\n  }\n}","returnValue":"Returns the path part of the HTTP request."},
{"commandName":"HTTP::payload","description":"Queries for or manipulates HTTP payload (content) information. With\nthis command, you can retrieve content, query for content size, or\nreplace a certain amount of content. The content does not include the\nHTTP headers.\n\nSyntax\n\nHTTP::payload <length>\n\n     * Returns the content that the HTTP::collect command has\n       collected thus far, up to the number of bytes specified. If you do\n       not specify a size, the system returns the entire collected\n       content.\n\nHTTP::payload <offset> <length>\n\n     * Returns the content that the HTTP::collect command has\n       collected thus far from the specified offset, up to the number of\n       bytes specified.\n\nHTTP::payload length\n\n     * Returns the size of the content that has been collected thus far,\n       in bytes.\n\nHTTP::payload rechunk\n\n     * Will cause the payload to be chunked on output.\n     * This subcommand was added in v9.4.0, and is only valid if selective\n       response chunking is being used.\n\nHTTP::payload unchunk\n\n     * Will cause the payload to be chunked on output if and only if it is\n       chunked on input.\n     * This subcommand was added in v9.4.0, and is only valid if selective\n       response chunking is being used.\n\nHTTP::payload replace <offset> <length> <string>\n\n     * Replaces the amount of content that you specified with the <length>\n       argument, starting at <offset> with <string>, adjusting the\n       Content-Length header appropriately.\n     * To clarify, the length argument should be the length of original\n       content to replace. In order to replace the entire payload, the\n       offset should be 0 and the length should be the original size in\n       bytes of the payload. The original content length can typically be\n       retrieved using [HTTP::header value Content-Length].","examples":"when HTTP_RESPONSE {\nif {[HTTP::status] == 205}{\n      HTTP::collect [HTTP::header Content-Length]\n      set clen [HTTP::header Content-Length]\n   }\n}\n\nwhen HTTP_RESPONSE_DATA {\nHTTP::respond 200 content [HTTP::payload]\n}\n\n\nwhen HTTP_RESPONSE_DATA {\n    regsub -all \"oursite\" [HTTP::payload] \"oursitedev\" newdata\n    log \"Replacing payload with new data.\"\n    HTTP::payload replace 0 $clen $newdata\n    HTTP::release\n}","returnValue":""},
{"commandName":"HTTP::query","description":"Returns or sets the query part of the HTTP request. The query is defined as the\npart of the request past a ? character, if any.\nFor the following URL:\nhttp://www.example.com:8080/main/index.jsp?user=test&login=check\nThe query is:\nuser=test&login=check\n\nSyntax\n\nHTTP::query\n\n     * Returns the query part of the HTTP request.\n\nHTTP::query <string>\n\n     * Changes the query part of the HTTP request. Rewriting the URI will only\n       affect the request to the pool member. The client will not see the\n       update unless the web application uses the requested URI to\n       generate response headers and/or content. If you want the client to\n       see the update to the URI in the browser's address bar, you can\n       send an HTTP redirect using HTTP::redirect or HTTP::respond.\n\nHTTP::query -normalized\n\n     * Returns the query part of the HTTP request normalized in a form\n       for consistent comparisons.","examples":"when HTTP_REQUEST {\n  log local0. \"http_path [HTTP::path]\"\n  log local0. \"http_query [HTTP::query]\"\n  HTTP::query user=test_user&login=test_login\n}\n\n\nwhen HTTP_REQUEST {\n if {[string tolower [HTTP::query]] contains \"utm\" || [string tolower [HTTP::query]] contains \"gclid\"} {\n    set query [string tolower [HTTP::query]]\n }\n}","returnValue":"Returns the query part of the HTTP request."},
{"commandName":"HTTP::redirect","description":"Redirects an HTTP request or response to the specified URL. Note that\nthis command sends the response to the client immediately. Therefore,\nyou cannot specify this command multiple times in an iRule, nor can you\nspecify any other commands that modify header or content after you\nspecify this command.\nThis command will always use a 302 response code. If you wish to use a\ndifferent one (e.g. 301), you will need to craft a response using\n[HTTP::respond].\nIf the client is a typical web browser, it will reflect the new URL\nthat you specify. If you wish to transparently translate the URI for\nyour servers (so that the client browser displays the \"old\" URI), you\ncan use the [HTTP::path] or [HTTP::uri] commands; the [HTTP::header]\ncommand can also be used to set a new Host header if needed.\nThis command is equivalent to the BIG-IP 4.X redirect statement.\n\nSyntax\n\nHTTP::redirect <url>\n\n     * Redirects an HTTP request or response to the specified URL.","examples":"when HTTP_RESPONSE {\n  if { [HTTP::status] == 404} {\n    HTTP::redirect \"http://www.example.com/newlocation.html\"\n  }\n}","returnValue":""},
{"commandName":"HTTP::release","description":"Releases the data collected via HTTP::collect. Unless a subsequent\nHTTP::collect command was issued, there is no need to use the\nHTTP::release command inside of the HTTP_REQUEST_DATA and\nHTTP_RESPONSE_DATA events, since (in these cases) the data is\nimplicitly released.\nIt is important to note that these semantics are different than those\nof the TCP::collect and TCP::release commands. With\nTCP::collect, the event for processing the data (CLIENT_DATA)\nwill fire without TCP::release being called, whereas with\nHTTP::collect, the event (HTTP_REQUEST_DATA or\nHTTP_RESPONSE_DATA) will not fire without HTTP::release being\ncalled (at least implicitly).\n\nSyntax\n\nHTTP::release\n\n     * Releases the collected data.","examples":"when CLIENT_ACCEPTED {\n    set tmm_auth_ldap_sid [AUTH::start pam default_ldap]\n}\nwhen HTTP_REQUEST {\n    AUTH::username_credential $tmm_auth_ldap_sid [HTTP::username]\n    AUTH::password_credential $tmm_auth_ldap_sid [HTTP::password]\n    AUTH::authenticate $tmm_auth_ldap_sid\n    HTTP::collect\n}\nwhen AUTH_SUCCESS {\n\tif {$tmm_auth_ldap_sid eq [AUTH::last_event_session_id]} {\n\t\tHTTP::release\n\t}\n}\nwhen AUTH_FAILURE {\n\tif {$tmm_auth_ldap_sid eq [AUTH::last_event_session_id]} {\n\t\tHTTP::respond 401\n\t}\n}\nwhen AUTH_WANTCREDENTIAL {\n\tif {$tmm_auth_ldap_sid eq [AUTH::last_event_session_id]} {\n\t\tHTTP::respond 401\n\t}\n}\nwhen AUTH_ERROR {\n\tif {$tmm_auth_ldap_sid eq [AUTH::last_event_session_id]} {\n\t\tHTTP::respond 401\n\t}\n}","returnValue":""},
{"commandName":"HTTP::response","description":"Returns the raw HTTP response header block as a single string.","examples":"when HTTP_RESPONSE {\n    # Send response header block to high speed logging\n    HSL::send $hsl [HTTP::response]\n}","returnValue":"Returns the raw HTTP response header block as a single string."},
{"commandName":"HTTP::request","description":"Returns the raw HTTP request headers as a string.","examples":"# Note: this example would not work if the client sends a POST request with a payload, as HTTP::request does not return the payload.\nwhen HTTP_REQUEST {\n\n    # Exit this event if the request isn't a GET\n    if {[HTTP::method] ne \"GET\"}{return}\n\n    # save original request headers\n    set req [HTTP::request]\n\n    # flag as new request needing lookup\n    set lookup 1\n\n    # inject lookup URI in place of original request\n    HTTP::uri \"/page.aspx?ip=[IP::client_addr]\"\n\n    # set pool to lookup server pool\n    pool lookup_server\n    }\n\n    when HTTP_RESPONSE {\n    if {$lookup == 1 }{\n        # collect first response (from lookup server) only\n        HTTP::collect 1\n    }\n}\n\nwhen HTTP_RESPONSE_DATA {\n    # Get poolname from server response\n    # Response would ideally be in the form of a pool name only.\n    # Otherwise parse or derive the poolname here\n    set myPool [HTTP::payload]\n\n    # re-set flag so that subsequent response to re-tried\n    # request from real server is not processed as a lookup\n    set lookup 0\n\n    # verify pool exists and has members\n    if { ![catch [pool $myPool]] }{\n\n        # Retry the request with the request headers set\n        HTTP::retry $req\n\n    } else {\n\n        #\n        # insert dead/non-existent pool logic here\n        #\n    }\n}\n\nAnd another one:\n    when HTTP_REQUEST {\n        # llength uses the spaces as well as carriage returns and line feeds\n        log local0. \"list length: [llength [HTTP::request]], all headers: [HTTP::request]\"\n\n        # Log the request headers in hex\n        binary scan [HTTP::request] H* request_hex\n        log local0. \"hex: $request_hex\"\n\n        # Replace the main whitespace characters with their hex equivalent (ie, \" \" -> \\x20)\n        log local0. \"escaped: [string map {\\x20 \\\\x20 \\x0d \\\\x0d \\x0a \\\\x0a} [HTTP::request]]\"\n\n        # Use string map to remove the \\x0d carriage return\n        #    then split the string on the \\x0a linefeeds into a list\n        set headers [split [string map {\\x0d \"\"} [HTTP::request]] \\x0a]\n        set len [llength $headers]\n\n        # Loop through each request header line and log it\n        for { set i 0 } { $i <  $len } { incr i } {\n            log local0. \"$i = [lindex $headers $i]\"\n        }\n    }\n\n    # /var/log/ltm output:\n\n    <HTTP_REQUEST>: list length: 9, all headers: GET /test.html HTTP/1.1  User-Agent: curl/7.41.0  Host: 11.3.0.10\n\n    <HTTP_REQUEST>: hex: 474554202f746573742e68746d6c20485454502f312e310d0a557365722d4167656e743a206375726c2f372e34312e300d0a486f73743a2031312e332e302e31300d0a4163636570743a202a2f2a0d0a0d0a\n\n    <HTTP_REQUEST>: escaped: GET\\x20/test.html\\x20HTTP/1.1\\x0d\\x0aUser-Agent:\\x20curl/7.41.0\\x0d\\x0aHost:\\x2011.3.0.10\\x0d\\x0a\\x0d\\x0a\\x0d\\x0a\n\n    <HTTP_REQUEST>: 0 = GET /test.html HTTP/1.1\n    <HTTP_REQUEST>: 1 = User-Agent: curl/7.41.0\n    <HTTP_REQUEST>: 2 = Host: 11.3.0.10\n    <HTTP_REQUEST>: 3 =\n    <HTTP_REQUEST>: 4 =\n    <HTTP_REQUEST>: 5 =","returnValue":"Returns the raw HTTP request headers as a string. You can access\nthe request payload (e.g. POST data) by triggering payload\ncollection with the [HTTP::collect] command and then using\n[HTTP::payload] in the [HTTP_REQUEST_DATA] event."},
{"commandName":"HTTP::respond","description":"Generates a response to the client as if it came from the server. If\nthe command runs on the client side, it sends the response to the\nclient without any load balancing taking place. If the command runs on\nthe server side, the content from the actual server is discarded and\nreplaced with the information provided.\n\nNote that because the system sends the response data immediately after\nthis iRule runs, we recommend that you not run any more iRules after\nit. Also, this command cannot be called if another response has already\nbeen sent to the client (e.g. via HTTP::redirect).\n\nBy default, the response generated is an HTTP/1.0 response; use the\n\"-version\" flag (introduced in 11.2.0) to explicitly set the response\nto HTTP/1.0 or HTTP/1.1. The HTTP status code is determined by the\nsupplied parameter. The response has a \"Server: BIG-IP\" header, to\ndifferentiate replies generated from the BIG-IP versus those from\nactual servers. The \"Content-Length\" header is computed and supplied\nautomatically; a user-specified one is overridden.\n\n\nSyntax\n\nHTTP::respond <status code> [-version [1.0|1.1|auto] ] [content <content Value>] [noserver] [<Header name> <Header Value>]+\n\n     * Generates a response to the client as if it came from the server,\n       with the supplied content and header values.\n\nv11.5+\nHTTP::respond [-reset] <status code> [-version [1.0|1.1|auto] ] [content <content Value>] [noserver] [<Header name> <Header Value>]+\n\n     * Generates a response to the client as if it came from the server,\n       with the supplied content and header values and resets serverside\n       connection instead of sinking the data.\n\n   Note: The noserver flag was added in 9.4.2. It suppresses the insertion\n   of the 'Server: BigIP' header. The noserver flag must be included after\n   the content (if any).\n\n   Note: The -version flag was added in 11.2.0. It must immediately follow\n   the status code and precede the content (if any) and any other flags.\n\n   Note: An 'auto' option was added for the '-version' flag in 11.4.0.","examples":"Send a redirect with a cookie set.\n\nwhen HTTP_REQUEST {\n    set ckname \"app\"\n    set ckvalue \"893\"\n    set cookie [format \"%s=%s; path=/; domain=%s\" $ckname $ckvalue \".domain.org\"]\n    HTTP::respond 302 Location \"http://www.domain.org\" \"Set-Cookie\" $cookie\n}\n\nOr you can generate an apology page from within the iRule. The\ncurly braces prevent variable expansion and should eliminate the\nneed to escape meta-characters within the response content.\n\nwhen HTTP_REQUEST {\n   HTTP::respond 200 content {\n      <html>\n         <head>\n            <title>Apology Page</title>\n         </head>\n         <body>\n            We are sorry, but the site you are looking for is temporarily out of service<br>\n            If you feel you have reached this page in error, please try again.\n         </body>\n      </html>\n   }\n}\n\nRewrite a redirect with the original cookies\nfrom the HTTP response of the server:\n\nwhen HTTP_RESPONSE {\n   if { [HTTP::is_redirect] } {\n      foreach aCookieName [HTTP::cookie names] {\n         set currentCookie \"$aCookieName=[HTTP::cookie value  $aCookieName]\"\n         set cookies \"$cookies\\r\\nSet-Cookie: $currentCookie\"\n      }\n      HTTP::respond 200 content \"<HTML><HEAD><TITLE>Forbidden Redirect From Remote Server</TITLE></HEAD>\\\n<BODY>The server is trying to redirect the client to an external site, but it is forbidden</BODY></HTML>\" Set-Cookie $cookies\n   }\n}\n\nAnother example with multiple cookies, but without excessive empty\ncookie - returns original cookies to the client:\n\nwhen HTTP_REQUEST {\n   set cookies \"\"\n   foreach next_cookie [HTTP::cookie names] {\n      set cookies \"$cookies\\\"Set-Cookie\\\" \\\"$next_cookie=[HTTP::cookie value $next_cookie]\\\" \"\n   }\n   log local0. \"Sending back $cookies\"\n   eval HTTP::respond 200 \"$cookies\"\n}\n\n   An example of a plain redirect - equivalent to using HTTP::redirect,\n   but with the Server BigIP header suppressed. In this example we're\n   redirecting our http:// request to the https:// version.\n\nwhen HTTP_REQUEST {\n   HTTP::respond 302 noserver Location \"https://[HTTP::host][HTTP::uri]\"\n}","returnValue":""},
{"commandName":"HTTP::retry","description":"Re-sends a request to a server. Can be either the same or a different\nrequest, to the same or a different server.\n  * To replay the same request, save the request to a variable in the\n    HTTP_REQUEST event, then use it with this command.\n  * A different request may alternatively be specified. The request\n    string must be well-formed and complete, including all required\n    headers.\n\nThe request generated by this command triggers HTTP_REQUEST and\nall subsequent client-side events.\n\nNote: If you want to retry a request with a payload, you should use\nHTTP::collect to collect the payload and then append the payload\nto the request headers retrieved using HTTP::request in\nHTTP_REQUEST_DATA.\n\nSyntax\n\nHTTP::retry <request>\n\n     * Resends a request to a server. The request header must be\n       well-formed and complete.\n\nv11.5+\nHTTP::retry [-reset] <request>\n\n     * Resends a request to a server and resets serverside connection\n       instead of sinking the data.","examples":"# Retry requests to the virtual server's default pool if the server responds with an error code (5xx status)\n\nwhen CLIENT_ACCEPTED {\n   # On each new TCP connection track that we have not retried a request yet\n   set retries 0\n\n   # Save the name of the virtual server default pool\n   set default_pool [LB::server pool]\n}\n\nwhen HTTP_REQUEST {\n   # We only want to retry GET requests to avoid having to collect POST payloads\n   # Only save the request headers if this is not a retried request\n   if { [HTTP::method] eq \"GET\" && $retries == 0 }{\n         set request_headers [HTTP::request]\n         log local0. \"Saving HTTP request headers: $request_headers\"\n   }\n}\n\nwhen LB_SELECTED {\n   # Select a new pool member from the VS default pool if we are retrying this request\n   if { $retries > 0 } {\n      LB::reselect pool $default_pool\n   }\n}\n\nwhen HTTP_RESPONSE {\n   # Check for server errors\n   if { [HTTP::status] starts_with \"5\" } {\n\n      # Server error, retry the request if we have not already retried more times than there are pool members\n      incr retries\n      log local0. \"5xx error caught: retry $retries out of [active_members $default_pool]\"\n\n      if { $retries < [active_members $default_pool] } {\n         # Retry this request\n         HTTP::retry $request_headers\n\n         # Exit this event from this iRule so we do not reset retries to 0\n         return\n      }\n   }\n   # If we are still in the rule we are not retrying this request\n   set retries 0\n}\n\n\n\n# Retry 404 responses once to a second pool\nwhen CLIENT_ACCEPTED {\n\n        # Track whether this is a retried request\n        set retried 0\n\n        # Save the name of the VS default pool\n        set default_pool [LB::server pool]\n\n        # Track whether we have the headers for this request\n        set request_headers \"\"\n}\n\nwhen HTTP_REQUEST {\n\n        # Select the VS default pool by default\n        pool $default_pool\n\n\n        # Check if this is a retried request\n        if {$retried == 0}{\n\n                # Only save request headers if it is a GET request\n                # We do not want to retry requests with payloads\n                if {[HTTP::method] eq \"GET\"}{\n\n                        # Save the HTTP request headers\n                        set request_headers [HTTP::request]\n                        log local0. \"HTTP request: $request_headers\"\n\n                } else {\n\n                        # Null the headers to make sure we only retry GETs\n                        set request_headers \"\"\n                }\n        } else {\n                # Select the other pool for the retry\n                pool other_pool\n        }\n}\n\nwhen HTTP_RESPONSE {\n\n        # Check if we got a 404 from the default pool\n        if { [HTTP::status] == 404 && $request_headers ne \"\" && [LB::server pool] eq $default_pool } {\n\n                # Track that we are retrying this request\n                set retried 1\n                log local0. \"404 error caught from default pool. Retrying.\"\n\n                HTTP::retry $request_headers\n        } else {\n                # Track that we are retrying this request\n                set retried 0\n        }\n}\n\n\n# One can save a WAN round trip by following a redirect at the LTM and responding to the\n# original client request with the result of the redirect\nwhen HTTP_REQUEST {\n\n   # Save the host header value\n   set host [HTTP::host]\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response is a redirect based on the status code\n   if { [HTTP::is_redirect] } {\n\n      # Now generate a GET request to the new location\n      HTTP::retry \"GET [HTTP::header location] HTTP/1.1\\r\\nHost: $host\\r\\n\\r\\n\"\n   }\n}","returnValue":""},
{"commandName":"HTTP::status","description":"Returns the response status code as defined in RFC2616\n\nSyntax\n\nHTTP::status\n\n     * Returns the response status code as defined in RFC2616","examples":"when HTTP_RESPONSE {\n  if { [HTTP::status] == 404 } {\n    HTTP::redirect \"http://www.example.com/not_found.html\"\n }\n}","returnValue":"Returns the response status code."},
{"commandName":"HTTP::uri","description":"Returns or sets the URI part of the HTTP request. This command replaces\nthe BIG-IP 4.X variable http_uri.\n\nFor the following URL:\nhttp://www.example.com:8080/main/index.jsp?user=test&login=check\nThe URI is: /main/index.jsp?user=test&login=check\n\nNote that in the HTTP_PROXY_REQUEST event, this command returns the complete\nproxy URI. This includes the scheme, host and port, and thus the result would be:\nhttp://www.example.com:8080/main/index.jsp?user=test&login=check\n\nSyntax\n\nHTTP::uri\n\n     * Returns the URI given in the request. This typically does not\n       include the protocol (http or https) or hostname, just the path and\n       query string, starting with a slash.\n\nHTTP::uri <string>\n\n     * Changes the URI passed to the server. It should always start with a\n       slash (unless using an absolute URI). Rewriting the URI will only\n       affect the request to the pool member. The client will not see the\n       update unless the web application uses the requested URI to\n       generate response headers and/or content. If you want the client to\n       see the update to the URI in the browser's address bar, you can\n       send an HTTP redirect using HTTP::redirect or\n       HTTP::respond.\n\nHTTP::uri -normalized\n\n    * Returns the URI normalized in a form for consistent comparisons.","examples":"when HTTP_REQUEST {\n  if { [HTTP::uri] ends_with \"cgi\" } {\n     pool cgi_pool\n  } elseif { [HTTP::uri] starts_with \"/abc\" } {\n     pool abc_servers\n }\n}\n\n\n# Make uri path start with /prefix if it doesn't already\nwhen HTTP_REQUEST {\n  if { not ([HTTP::uri] starts_with \"/prefix\") } {\n    HTTP::uri /prefix[HTTP::uri]\n  }\n}\n\nNote: If you want to check the file extension in a request, it would be\nmore efficient to use '[HTTP::path] ends_with \".ext\"' instead of\nHTTP::uri, as HTTP::uri includes the query string and HTTP::path does\nnot.\n\nwhen HTTP_PROXY_REQUEST {\n   log local.0 \"This proxy request is:[HTTP::uri]\"\n}","returnValue":"Returns the URI part of the HTTP request."},
{"commandName":"HTTP::username","description":"Returns the username part of HTTP basic authentication.\nAs described in RFC2617 the username and password in basic\nauthentication is sent by the client in the Authorization header. The\nclient base64 encodes the username and password in the format of:\nAuthorization: Basic base64encoding(username:password)\nThe HTTP::username command parses and base64 decodes the username.\nThe HTTP::password command parses and base64 decodes the password.\n\nSyntax\n\nHTTP::username\n\n     * Returns the username part of HTTP basic authentication.","examples":"# Small chunk of an iRule for radius authentication\nwhen HTTP_REQUEST {\n  AUTH::username_credential $auth_sid [HTTP::username]\n  AUTH::password_credential $auth_sid [HTTP::password]\n}\nwhen CLIENT_ACCEPTED {\n  set auth_sid [AUTH::start pam default_radius]\n}","returnValue":"Returns the username part of HTTP basic authentication"},
{"commandName":"HTTP::version","description":"Returns or sets the HTTP version of the request or response. This\ncommand replaces the BIG-IP 4.X variable http_version.\nIf needed, Connection and Host headers will automatically be added\nappropriately.\nHTTP::version will return the original version of the request or\nresponse, even if it has been changed.  Note that this will return\nthe \"effective\" version used, which may be different than the actual\nversion string in the request or response.  For example, invalid\nversion numbers may be parsed as 1.1 in order to increase\ninter-operability with common HTTP servers.\n\nSyntax\n\nHTTP::version [\"0.9\" | \"1.0\" | \"1.1\"]\n\n     * Returns or sets the HTTP version of the request or response.","examples":"when HTTP_RESPONSE {\n  HTTP::version \"1.1\"\n}","returnValue":"Returns the HTTP version of the request or response"},
{"commandName":"HTTP::proxy","description":"When an Explicit HTTP profile is applied to a virtual server, HTTP::proxy allows control of whether the BIG-IP will handle the proxy of the connection locally or send it to a downstream pool for processing instead.\n\nThis functionality was introduced in v11.6, and is available for v11.5.1 via an Engineering Hotfix.\n\n\nHTTP::proxy dest allows inspection of the results of the DNS lookup used in the Explicit HTTP Proxy.\n\nWhen a HTTP Proxy Chaining profile is applied to a virtual server, HTTP::proxy chain may be used to control the CONNECT request used to connect to the next proxy in the chain.\n\nThis functionality was introduced in v13.0.\n\nSyntax\n\nHTTP::proxy\n\n    * Returns true (1) if the local proxy handler is enabled, or false (0) if it is presently disabled.\n\nHTTP::proxy <enable | disable>\n\n    * Allows control of proxy processing. If HTTP::proxy disable is called, the proxy will not attempt to look up the proxy request's hostname, it will simply send the request, unmodified, to the default pool.\n\nHTTP::proxy uri-rewrite <enable | disable>\n\n    * Allows control of the uri sent to the next hop.  The uri will be re-written into \"proxy form\" if this is enabled, with an added \"http://<host name>\" or \"https://<host name> prefix.\n\nHTTP::proxy addr\n\n    * Returns the IP address resolved by the HTTP Explicit Proxy for the hostname in the request.\n\nHTTP::proxy port\n\n    * Gets the port used to connect to the remote server for a HTTP Explicit Proxy request.\n\nHTTP::proxy rtdom\n\n    * Returns the route domain id being used to connect to the remote server for the HTTP Explicit Proxy request.\n\nHTTP::proxy exists\n\n    * Returns TRUE if the HTTP Explicit Proxy has resolved the request's hostname.  (This command may be used to check whether other HTTP::proxy dest commands may be safely used in this context.)\n\nHTTP::proxy iptuple\n\n    * Returns the full IP Tuple resolved by the HTTP Explicit Proxy for the request.\n\nHTTP::proxy chain <enable | disable>\n\n    * Allows control of the HTTP Proxy Chaining feature.  If it is disabled, then a HTTP CONNECT will not be added to the outgoing request.\n\nHTTP::proxy chain host <hostname> <port>\n\n    * Allows getting or setting the hostname used in the HTTP Proxy Chaining CONNECT request.  The port field is optional\n\nHTTP::proxy chain port <port>\n\n    * Allows getting or setting the port described in the hostname used for HTTP Proxy Chaining.\n\nHTTP::proxy chain retry\n\n    * If the status code in the response from the HTTP Proxy Chaining CONNECT request was not a 200, then the connection will be aborted.  If this command is called, then the request will be retried once again.  (It may be useful to alter the headers sent to include extra authentication information in the new CONNECT request.)","examples":"# Example 1: Simple Proxy Chaining\n\nwhen HTTP_PROXY_REQUEST {\n    if { (not [HTTP::method] == \"CONNECT\") && [URI::host [HTTP::uri]] ends_with \".internal.domain.com\" } {\n          HTTP::proxy disable\n          pool internal_proxy_3128\n    } else {\n          HTTP::proxy enable\n    }\n}\n\n# Example 2: Advanced Proxy Chaining & URI Rewriting\n\nwhen HTTP_PROXY_REQUEST {\n    log local0. \"[HTTP::method] [HTTP::uri]\"\n    switch [string tolower [URI::host [HTTP::uri]]] {\n        \"www.google.com\" {\n             # send request to default pool (aka proxy-chaining)\n             HTTP::proxy disable\n         }\n         \"www.abc.com\" {\n             # change request to a different host - remains a proxy request\n             HTTP::uri http://www.google.com/\n         }\n         \"www.def.com\" {\n             # change request to a normal (not proxy) request - goes to the default pool\n             HTTP::uri /def.html\n          }\n     }\n}\n\nwhen HTTP_REQUEST {\n    log local0. \"[HTTP::method] [HTTP::uri]\"\n}\n\n# Example 3: Proxy Chaining via Categorization (Requires either an SWG or URL Filtering Subscription)\n\nwhen RULE_INIT {\n    log local0. \"Proxy Chain iRule\"\n    set static::Proxy_Chain_categories {\n       /Common/Restaurants_and_Dining\n    }\n    set static::Proxy_Chain_debug 1\n}\n\nwhen HTTP_PROXY_REQUEST {\n    set proxy_chain 0\n    if { $static::Proxy_Chain_debug } { log local0. \"URI: [HTTP::uri]\" }\n\n    # Check for a category match\n    set reply [getfield [CATEGORY::lookup [HTTP::uri]] \" \" 1]\n    if {[lsearch -exact $static::Proxy_Chain_categories $reply] >= 0}{\n        if { $static::Proxy_Chain_debug } { log local0. \"HIT: The category $reply should be bypassed for [HTTP::uri]\" }\n        set proxy_chain 1\n    }\n\n    # Check for a URI::host for HTTP connections\n    if {[URI::host [HTTP::uri]] == \"www.cariboucoffee.com\"} {\n        set proxy_chain 1\n    }\n\n    # Perform the prescibed action\n    if { $proxy_chain } {\n        if { $static::Proxy_Chain_debug } { log local0. \"Proxy Chain: [HTTP::method] URI:[HTTP::uri]\" }\n        HTTP::proxy disable\n        snat 10.10.1.10\n        pool squid\n    }\n}\n\n# Example 4: Explicit Proxy logging\n\nwhen HTTP_REQUEST {\n    if { [HTTP::proxy dest exists] } {\n        log local0. \"Explicit proxy request: [HTTP::proxy dest addr]:[HTTP::proxy dest port] [HTTP::uri]\"\n    } else {\n        log local0. \"Local request:[HTTP::uri]\"\n    }\n\n}\n\n# Example 5: Proxy Chaining through a VIP-on-VIP solution\n\nwhen HTTP_REQUEST {\n    if { [HTTP::proxy dest exists] } {\n        # Use the tunnel_http_80 virtual, but keep the\n        # resolved address to connect to.\n        virtual tunnel_http_80 [HTTP::proxy dest addr] [HTTP::proxy dest port]\n     }\n}","returnValue":""},
{"commandName":"HTTP2::active","description":"Returns 1 if the HTTP request is generated by HTTP/2. Returns 0 otherwise.","examples":"when HTTP_REQUEST {\n    if {[HTTP2::active]} {\n        log local0. \"request from HTTP/2 client\"\n    }\n}","returnValue":"The return is 1 if the HTTP request is generated by HTTP/2, 0 otherwise."},
{"commandName":"HTTP2::concurrency","description":"Returns number of active concurrent streams in the current HTTP/2 session.","examples":"when HTTP_REQUEST {\n    log local0. \"Number of active concurrent streams is [HTTP2::concurrency]\"\n}","returnValue":"The return is a number indicating the active concurrent streams in current HTTP/2 session."},
{"commandName":"HTTP2::disconnect","description":"Cleanly terminates the current HTTP/2 session, if HTTP/2 is active.","examples":"when HTTP_REQUEST {\n    if {[HTTP2::active]} {\n        HTTP2::disconnect\n    }\n}","returnValue":"The return is 0 if the disconnect was clean. If a GOAWAY frame cannot be sent, an error will be returned."},
{"commandName":"HTTP2::requests","description":"Returns the count of requests received in the current HTTP/2 session. This includes the current request. Returns 0 if HTTP/2 is not active.","examples":"when HTTP_REQUEST {\n    log local0. \"Number of requests received in current session is [HTTP2::requests]\"\n}","returnValue":"The return is a number indicating count of requests received in current HTTP/2 session. The return is 0 if HTTP/2 is not active."},
{"commandName":"HTTP2::stream","description":"This command can be used to determine the stream attributes including id and priority. This command can also be used to set the priority for a current active stream.\n\nHTTP2::stream\n    Returns the stream id. Returns 0 if HTTP/2 is not active.\n\nHTTP2::stream id\n    Returns the stream id. Returns 0 if HTTP/2 is not active.\n\nHTTP2::stream priority\n    Returns the priority of the current stream.\n\nHTTP2::stream priority <priority>\n    Sets the priority of the current active stream. The return is 0 is the priority was set. Return is an error if the priority is out of bounds (exceeding 8 bits).","examples":"when HTTP_REQUEST {\n    if {[HTTP2::version] != 0} {\n        set new_pri [URI::query [HTTP::uri] pri]\n        if { $new_pri != \"\" } {\n             HTTP2::stream priority $new_pri\n        }\n        HTTP::header insert \"X-HTTP2-Values stream/pritority \" \"[HTTP2::stream]/[HTTP2::stream priority]\"\n    }\n}","returnValue":""},
{"commandName":"HTTP2::version","description":"Returns the HTTP/2 protocol version used. Returns 0 if no HTTP/2 request is active.","examples":"when HTTP_REQUEST {\n    if {[HTTP2::version] != 0} {\n        HTTP::header insert \"X-HTTP2-Values version \" \"[HTTP2::version]\"\n    }\n}","returnValue":"The return is a string containing HTTP/2 protocol version, 0 if HTTP/2 is not active."},
{},
{},
{"commandName":"ICAP::header","description":"The ICAP::header command sets or returns attributes in the ICAP header.\n\nSyntax\n\nICAP::header exists <attr_name>\n\n    * Returns true if header <attr_name> exists and is not empty.\n\nICAP::header values <attr_name>\n\n    * Returns all values of the specified ICAP header <attr_name>.\n      If there is only one header of this name, returns its value.\n      If there are multiple headers with the same name, returns a\n      Tcl list of the values.\n\nICAP::header value <attr_name> [<attr_value>]\n\n    * Returns the value of the last ICAP header <attr_name>,\n      that is the value of the last occurrence of that attribute.\n      Optionally replaces that value with the supplied new value.\n\nICAP::header names\n\n    * Returns a list of the names of all ICAP headers present.\n\nICAP::header count [<attr_name>]\n\n    * Returns the number of ICAP headers present.\n      Optionally returns the number of headers named <attr_name>.\n\nICAP::header at <index>\n\n    * Returns the ICAP header name at the zero-based <index>\n      position. Index 0 refers to the first header.\n\nICAP::header replace <attr_name> <attr_value>\n\n    * Replace the specified ICAP header attribute with the provided\n      value.\n\nICAP::header remove <attr_name>\n\n    * Remove the specified ICAP header attribute\n\nICAP::header add <attr_name> <attr_value>\n\n    * Adds the specified ICAP header attribute\n\nICAP::header replace-all <header_text>\n\n    * Replace the current ICAP header with the provided text\n\n    Used primarily to add custom headers specific to the application.\n    If modifying standard ICAP headers, be careful that the resulting\n    ICAP headers make sense to the ICAP server and do not misrepresent\n    the behavior of the BigIP ICAP client. For example, DO NOT do this:\n\n    ICAP::header add Allow 204\n    (the server would be misled to believe the BigIP client can accept\n    a 204 response after resuming payload beyond the preview).","examples":"when ICAP_REQUEST {\n                ICAP::header add X-ICAP-my-custom-header foobar\n            }\n            when ICAP_RESPONSE {\n                ICAP::header remove X-ICAP-my-custom-header\n            }","returnValue":""},
{"commandName":"ICAP::method","description":"The ICAP::method command returns the ICAP request method.\nThis will either be \"REQMOD\" or \"RESPMOD\"\n\nSyntax\n\nICAP::method\n\n    * Returns the ICAP request method","examples":"when ICAP_REQUEST {\n                if {[ICAP::method] == \"REQMOD\"} {\n                    ICAP::header add X-Request $seqno\n                }\n            }","returnValue":"Returns the ICAP request method."},
{"commandName":"ICAP::status","description":"The ICAP::status command gets the ICAP response status code. For\nexample, 100, 200, 204.\n\nSyntax\n\nICAP::status","examples":"when ICAP_RESPONSE {\n                if {[ICAP::status] == 204} {\n                    log local0. \"ICAP server responded 204\"\n                }\n            }","returnValue":"Return the ICAP response status code."},
{"commandName":"ICAP::uri","description":"The ICAP::uri command sets or returns the ICAP request URI.\n\nSyntax\n\nICAP::uri\n\n    * Returns the ICAP request URI\n\nICAP::uri <uri>\n\n    * Sets the ICAP request URI.","examples":"when ICAP_REQUEST {\n                if {[ICAP::uri] contains \"movie\"} {\n                    ICAP::uri http://icap.mydomain.org/video\n                }\n            }","returnValue":"Returns the ICAP request URI."},
{"commandName":"ILX::init","description":"Creates a handle for future use by ILX::call and ILX::notify.  This handle is a reference to a running ILX plugin extension.  The lifetime of this variable affects the behavior of the ILX target if controlled by BIG-IP.  Instances of the plugin extension will be held in draining mode as long as there are open references to the ILX handle in any event.","examples":"when CLIENT_ACCEPTED {\n    # Get a handle to the running extension instance to call into.\n    set RPC_HANDLE [ILX::init my_plugin my_extension]\n    # Make the call and store the response in $rpc_response\n    set rpc_response [ILX::call $RPC_HANDLE my_js_function arg1 arg2]\n}","returnValue":"Returns a handle to the running extension to call into."},
{"commandName":"ILX::call","description":"Make a call to a method defined within the plugin extension referenced by the handle.  Provide the method with the arguments listed in ARGS, do not continue processing the iRule until a response is received.","examples":"when CLIENT_ACCEPTED {\n    # Get a handle to the running extension instance to call into.\n    set RPC_HANDLE [ILX::init my_plugin my_extension]\n    # Make the call and store the response in $rpc_response\n    set rpc_response [ILX::call $RPC_HANDLE my_js_function arg1 arg2]\n}","returnValue":"The return value is the argument passed to response.reply() call on the extension side (eg. an array, a string, etc)."},
{"commandName":"ILX::notify","description":"Make a call to the plugin extension defined by the handle but do not wait for a response before continuing to process the remainder of the iRule. The delivery of the call to the plugin extension is \"best effort\" and is not guaranteed.","examples":"when CLIENT_ACCEPTED {\n    # Get a handle to the running extension instance to call into.\n    set RPC_HANDLE [ILX::init my_plugin my_extension]\n    # Make the asynchronous call\n    ILX::notify $RPC_HANDLE my_js_function arg1 arg2\n}","returnValue":"None"},
{"commandName":"IP::addr","description":"IP address comparison\n\nPerforms comparison of IP address/subnet/supernet to IP address/subnet/supernet.\n\nReturns 0 if no match, 1 for a match.\n\nUse of IP::addr is not necessary if the class (v10+) or matchclass (v9) command is used to perform the address-to-address comparison.\n\nDoes NOT perform a string comparison. To perform a literal string comparison, simply compare the 2 strings with the appropriate operator (equals, contains, starts_with, etc) rather than using the IP::addr comparison.\n\nFor versions 10.0 - 10.2.1, use the \"slash notation\" such as \"/16\" or \"/24\" instead of dotted decimal for the netmask like \"/255.255.255.0\". The latter dotted decimal netmask notation passes iRule validation in versions 10.0 - 10.2.1, but does not reliably work. You can, however, specify the IP and mask as follows: \"10.1.1.0 mask 255.255.255.0\" (no slash at all with double quotes). The dotted decimal notation for / is restored in version 10.2.2. (bug id 347628)\n            \nParses the value in <binary field> into an IPv4 dotted quad address, starting at the given offset in bytes. The value of binary field must be 4 or more binary bytes intended to be parsed as an IP address. If the -swap option is specified, network byte order conversion is performed on the bytes before parsing the address.","examples":"# To perform comparison of IP address 10.10.10.1 with subnet 10.0.0.0. (Will return 1, since it is a match.)\n[IP::addr 10.10.10.1 equals 10.0.0.0/8]\n\n# To perform comparison of client-side IP address with subnet 10.0.0.0. (Will return 1 or 0, depending on client IP address.)\n[IP::addr [IP::client_addr]/8 equals 10.0.0.0]\n\n[IP::addr \"10.0.0.0 mask 255.0.0.0\" equals [IP::client_addr]]\n[IP::addr 10.42.2.0/24 equals 10.42.2.1]: 1\n[IP::addr 10.42.2.2 equals 10.42.2.0/24]: 1\n\n# To select a specific pool for a specific client IP address.\nwhen CLIENT_ACCEPTED {\n   if { [IP::addr [IP::client_addr] equals 10.10.10.10] } {\n      pool my_pool\n   }\n}\n\n# To perform a comparison of IP address 10.10.10.1 with a list of addresses in a Data Group List, use class (v10) or matchclass (v9) instead:\n[class match 10.10.10.1 equals client_ip_class]\n[matchclass 10.10.10.1 equals myIPs]\n\n# To validate an IP address, you can use catch statement (by natty76)\nset a \"1.1.1.1\"\nlog local0. \"catch $a => [catch {IP::addr $a mask 255.255.255.255} ]\"\nset a \"256.256.256.256\"\nlog local0. \"catch $a => [catch {IP::addr $a mask 255.255.255.255} ]\"\n\n# To convert 4 binary bytes into an IPv4 address (10.2.0-HF2 or higher only):\nwhen CLIENT_ACCEPTED {\n    set input_option [TCP::option get 28]\n    # since the option kind 28 data begins with a 1-byte version code,\n    # and we just want the address that follows it, use offset 1\n    set forwarded_ip [IP::addr parse $input_option 1]\n    log local0. \"The IP address was $forwarded_ip\"\n}\n\n# To use a switch statement to utilize different networks:\nwhen HTTP_REQUEST {\n    switch [IP::addr [IP::client_addr] mask 255.255.255.0] {\n        \"10.10.4.0\" -\n        \"192.168.4.0\" {\n            pool pool_http_server_1\n        }\n        default {\n            reject\n        }\n    }\n}","returnValue":"Returns 0 IF NO MATCH, 1 for a match."},
{"commandName":"IP::client_addr","description":"Returns the client IP address of a connection. This command is equivalent to the command clientside { IP::remote_addr } and to the BIG-IP 4.X variable client_addr.","examples":"when CLIENT_ACCEPTED {\n  if { [IP::addr [IP::client_addr] equals 10.10.10.10] } {\n     pool my_pool\n }\n}\n\n# In BIG-IP 10.x with Route Domains:\nwhen CLIENT_ACCEPTED {\n   # Check if client IP is 10.10.10.10, in route domain 100\n   if { [IP::addr [IP::client_addr] equals 10.10.10.10%100] } {\n      pool my_pool\n   }\n}\n\nwhen CLIENT_ACCEPTED {\n   # Check if client IP is 10.10.10.10, in any route domain\n   if { [IP::addr [getfield [IP::client_addr] \"%\" 1] equals 10.10.10.10] } {\n       pool my_pool\n   }\n}","returnValue":"In BIG-IP 10.x with route domains enabled if the client is in any non-default route domain, this command returns the client IP address in the x.x.x.x%rd. For clients in the default route domain, it returns just the IPv4 address."},
{"commandName":"IP::hops","description":"This command is used to give you the estimated number of hops between the peer in question, and the client machine making the request.","examples":"when HTTP_REQUEST {\n  if { [IP::hops] >= 10 } {\n      COMPRESS::disable\n  }\n}","returnValue":"Number of hops"},
{"commandName":"IP::idle_timeout","description":"Returns the idle timeout value, or specifies an idle timeout value as the criteria for selecting the pool to which you want the BIG-IP system to send traffic.","examples":"when HTTP_REQUEST {\n  if {[HTTP::uri] starts_with \"/portal\" } {\n    IP::idle_timeout 3600\n  }\n}\n\n# Update the idle timeout for the client and serverside connection if a condition in the HTTP_REQUEST event is true. This could be a test to see if the request was for a specific URI.¶\nwhen HTTP_REQUEST {\n   if {$some_condition == 1}{\n      log local0. \"original timeout: [IP::idle_timeout]\"\n      IP::idle_timeout 1801\n      log local0. \"updated timeout: [IP::idle_timeout]\"\n      set update_serverside_idle_timeout 1\n   }\n}\n\nwhen SERVER_CONNECTED {\n   log local0. \"original timeout: [IP::idle_timeout]\"\n   if {[info exists update_serverside_idle_timeout] && $update_serverside_idle_timeout}{\n      IP::idle_timeout 1802\n      log local0. \"updated timeout: [IP::idle_timeout]\"\n   }\n}\n\n# You can check the ltm log for the log output to see that the rule triggered.\n# idle_timeout_rule <HTTP_REQUEST>: original timeout: 300\n# idle_timeout_rule <HTTP_REQUEST>: updated timeout: 1801\n# idle_timeout_rule <SERVER_CONNECTED>: original timeout: 300\n# idle_timeout_rule <SERVER_CONNECTED>: updated timeout: 1802\n\n# And you can check the b conn output for your client IP to see the idle timeout.\n#  b conn client 10.0.0.10 show all\n\n# VIRTUAL 2.2.2.2:http <-> NODE any6:any\n#     CLIENTSIDE 10.0.0.10:4161 <-> 2.2.2.2:http\n#         (pkts,bits) in = (2, 960), out = (1, 528)\n#     SERVERSIDE 3.3.3.3:4409 <-> 3.3.3.4:80\n#         (pkts,bits) in = (3, 4952), out = (4, 2440)\n#      PROTOCOL tcp   UNIT 1   IDLE 58 (1801)   LASTHOP 4093 00<!--:00:00:e2:1a:2e-->\n\n# Check the client's destination port\n# Set the idle timeout based on the protocol\nwhen CLIENT_ACCEPTED {\n    switch [TCP::local_port] {\n        20 -\n        21 -\n        22 {\n            # FTP, SSH: use a longer timeout\n            set idle 3600\n            IP::idle_timeout 3600\n        }\n        80 -\n        443 -\n        8080 -\n        8443 {\n            # HTTP and proxy ports: use a shorter timeout\n            set idle 300\n            IP::idle_timeout 300\n        }\n        default {\n            # Default port, use a middle length timeout\n            set idle 600\n            IP::idle_timeout 600\n        }\n    }\n}\nwhen SERVER_CONNECTED {\n    IP::idle_timeout $idle\n}","returnValue":"idle timeout value in seconds"},
{"commandName":"IP::local_addr","description":"When called in a clientside context, this command returns the IP address of the virtual server the client is connected to. When called in a serverside context it returns the self-ip address or spoofed client IP address LTM is using for the serverside connection.\n\nThis command is primarily useful for generic rules that are re-used. Also, it is useful in reusing the connected endpoint in another statement (such as with the listen command) or to make routing type decisions. You can also specify the IP::client_addr and IP::server_addr commands.\n\nThis command in BIG-IP 10.x returns identical output as BIG-IP 9.x if the IP address of virtual or self-ip is in the default route domain else it returns the IP address as well as the route domain in the x.x.x.x%rd format.\n\nThis command is equivalent to the BIG-IP 4.X variable local_addr.","examples":"when CLIENT_ACCEPTED {\n  if { [IP::addr [IP::local_addr] equals 172.16.32.2] } {\n     pool deprecated_site\n  } else {\n     pool current_site_pool\n }\n}\n\n# In BIG-IP 10.x with a virtual address in a route domain matching the x.x.x.x%rd format\nwhen CLIENT_ACCEPTED {\n  if { [IP::addr [IP::local_addr] equals 172.16.32.2%1000] } {\n     pool deprecated_site\n  } else {\n     pool current_site_pool\n }\n}\n\n# In BIG-IP 10.x with a virtual address in a route domain matching the IPv4 portion of the IP::local_addr\nwhen CLIENT_ACCEPTED {\n  if { [IP::addr [getfield [IP::local_addr] \"%\" 1] equals 172.16.32.2] } {\n     pool deprecated_site\n  } else {\n     pool current_site_pool\n }\n}\n\nwhen SERVER_CONNECTED {\n   log local0. \"Source IP address for connection to node: [IP::local_addr]\"\n}\n\n# In BIG-IP 10.x with a self-ip in a route domain, prints only the IPv4 portion of the address\nwhen SERVER_CONNECTED {\n   log local0. \"Source IP address for connection to node: [getfield [IP::local_addr] \"%\" 1]\"\n}","returnValue":"Returns the IP address being used in the connection."},
{"commandName":"IP::protocol","description":"Returns the IP protocol value. This command replaces the BIG-IP 4.X variable ip_protocol.\nFor a list of the IP protocol numbers, see /etc/protocols or the L<IANA protocol number list|http://www.iana.org/assignments/protocol-numbers/protocol-numbers.xml>","examples":"when CLIENT_ACCEPTED {\n  if { [IP::protocol] == 6 } {\n     pool tcp_pool\n  } else {\n     pool slow_pool\n  }\n}","returnValue":"IP protocol"},
{"commandName":"IP::version","description":"Returns the IP version of a connection. When called in a clientside event, this command returns the IP version for the clientside connection. When called in a serverside event, this command returns the IP version for the serverside connection.","examples":"when CLIENT_ACCEPTED {\n   log local0. \"Client [IP::client_addr], VS: [IP::local_addr],\\\n      \\[IP::version\\]: [IP::version], \\[IP::protocol\\]: [IP::protocol]\"\n}\n\n# Log output for a TCP connection over IPv4:\n# <CLIENT_ACCEPTED>: Client 10.1.0.11, VS: 10.1.0.15, [IP::version]: 4, [IP::protocol]: 6\n\n# Log output for a TCP connection over IPv6:\n# <CLIENT_ACCEPTED>: Client fc00::1, VS: fc00::2, [IP::version]: 6, [IP::protocol]: 6","returnValue":"IP version of a connection"},
{"commandName":"IP::remote_addr","description":"Returns the IP address of the host on the far end of the connection. In the clientside context, this is the client IP address. In the serverside context this is the node IP address. You can also specify the IP::client_addr and IP::server_addr commands, respectively.\n\nIn BIG-IP 10.x with route domains enabled this command returns the remote IP address in the x.x.x.x%rd of the server or client (depending on the context) that is in any non-default route domain else it returns just the IP address as expected.\n\nThis command is equivalent to the BIG-IP 4.X variable remote_addr.","examples":"when CLIENT_ACCEPTED {\n  if { [IP::addr [IP::remote_addr] equals 206.0.0.0 mask 255.0.0.0] } {\n     pool clients_from_206\n  } else {\n     pool other_clients_pool\n }\n}\n\nwhen SERVER_CONNECTED {\n   log local0. \"Node IP address is: [IP::remote_addr]\"\n}","returnValue":"IP address of the host on the far end of the connection"},
{"commandName":"IP::server_addr","description":"Returns the server's (node's) IP address once a serverside connection has been established. This command is equivalent to the command serverside { IP::remote_addr } and to the BIG-IP 4.X variable server_addr. The command returns 0 if the serverside connection has not been made.\n\nIn BIG-IP 10.x with route domains enabled this command returns the server's (node's) address once the serverside connection is established in the x.x.x.x%rd if the server is in any non-default route domains else it returns just the IPv4 address as expected.","examples":"when SERVER_CONNECTED {\n   log local0. \"Node IP address: [IP::server_addr]\"\n}\n\n# In BIG-IP 10.x this returns only the IPv4 portion of the address regardless of the route domain\nwhen SERVER_CONNECTED {\n   log local0. \"Node IP address: [getfield [IP::server_addr] \"%\" 1\"\n}","returnValue":"server's IP address"},
{"commandName":"IP::stats","description":"This command supplies information about the number of packets or bytes being sent or received in a given connection.\n\nIP::stats\nReturns a list with Packets In, Packets Out, Bytes In, Bytes Out & Age\n\nIP::stats pkts in\nReturns number of packets received\n\nIP::stats pkts out\nReturns number of packets sent\n\nIP::stats pkts\nReturns a Tcl list of packets in and packets out\n\nIP::stats bytes in\nReturns number of bytes received\n\nIP::stats bytes out\nReturns number of bytes sent\n\nIP::stats bytes\nReturns Tcl list of bytes in and bytes out\n\nIP::stats age\nReturns the age of the connection in milliseconds","examples":"# The following example calculates and logs response time:\nwhen HTTP_REQUEST {\n    set reqAge [IP::stats age]\n    set reqURI [HTTP::uri]\n    set reqClient [IP::remote_addr]:[TCP::remote_port]\n}\nwhen HTTP_RESPONSE {\n    set respTime [expr {[IP::stats age] - $reqAge}]\n    log local0. \"Client at $reqClient requested $reqURI. \\\nServer response was received $respTime milliseconds after the request was sent to the server.\"\n}","returnValue":"number of packets or bytes being sent or received in a given connection"},
{"commandName":"IP::tos","description":"Returns (or sets) the ToS value encoded within a packet. The Type of Service (ToS) standard is a means by which network equipment can identify and treat traffic differently based on an identifier. As traffic enters the site, the BIG-IP system can apply a rule that sends the traffic to different pools of servers based on the ToS level within a packet, or can set the ToS value on traffic matching specific patterns.\n\nNote: If using DSCP values, know that is a bit-shifted value within the tos field, so if you need the value to be DSCP 46, the actual value you need to use with the command is 184 (bit-shifted twice, so 22=4 * DSCP = TOS). Please use this table for refererence:\n\nDSCP Mappings for IP::tos Command\nPrecedence   Type of Service   DSCP Class   DSCP Value   IP::tos Value\n0            0                 none         0            0\n1            0                 cs1          8            32\n1            1                 af11         10           40\n1            10                af12         12           48\n1            11                af13         14           56\n10           0                 cs2          16           64\n10           1                 af21         18           72\n10           10                af22         20           80\n10           11                af23         22           88\n11           0                 cs3          24           96\n11           1                 af31         26           104\n11           10                af32         28           112\n11           11                af33         30           120\n100          0                 cs4          32           128\n100          1                 af41         34           136\n100          10                af42         36           144\n100          11                af43         38           152\n101          0                 cs5          40           160\n101          11                ef           46           184\n110          0                 cs6          48           192\n111          0                 cs7          56           224\nThis command is equivalent to the BIG-IP 4.X variable ip_tos.","examples":"when CLIENT_ACCEPTED {\n  if { [IP::tos] == 64 } {\n     pool telnet_pool\n  } else {\n     pool slow_pool\n }\n}\n\nwhen CLIENT_ACCEPTED {\n  if { [TCP::local_port] == 554 } {\n    # this sets DSCP to 46 (EF)\n    IP::tos 184\n  }\n}","returnValue":"Returns the ToS value encoded within a packet"},
{"commandName":"IP::ttl","description":"Returns the TTL of the latest IP packet received.","examples":"","returnValue":"Returns the TTL of the latest IP packet received."},
{"commandName":"IP::reputation","description":"Performs a lookup of the supplied IP address against the IP reputation database. Returns a TCL list containing possible reputation categories:\n\nCategory                     Description\nBotnets                      IP addresses of computers that are infected with malicious software and are controlled as a group, and are now part of a botnet. Hackers can exploit botnets to send spam messages, launch various attacks, or cause target systems to behave in other unpredictable ways.\nCloud Provider Networks      IP addresses of cloud providers.\nDenial of Service            IP addresses that have launched Denial of Service (DoS) attacks. These attacks are usually requests for legitimate services, but occur at such a fast rate that targeted systems cannot respond and become bogged down or unable to service legitimate clients.\nInfected Sources             IP addresses that issue HTTP requests with a low reputation index score, or are known malware sites.\nMobile Threats               IP addresses of malicious and unwanted mobile applications.\nPhishing                     IP addresses that are associated with phishing web sites that masquerade as legitimate web sites.\nProxy                        IP addresses that are associated with web proxies that shield the originator's IP address (such as anonymous proxies).\nScanners                     IP addresses that have been observed to perform port scans or network scans, typically to identify vulnerabilities for later exploits.\nTor Proxy                    IP addresses that act as exit nodes for the Tor Network.\nWeb Attacks                  IP addresses that have launched web attacks of various forms.\nWindows Exploits             IP addresses that have exercised various exploits against Windows resources using browsers, programs, downloaded files, scripts, or operating system vulnerabilities.\n\nAn IP intelligence database is a list of IP addresses with questionable reputations. IP addresses gain a questionable reputation and are added to the database as a result of having performed exploits or attacks, or these addresses might represent proxy servers, scanners, or systems that have been infected. You can prevent system attacks by excluding traffic from malicious IP addresses. The IP Intelligence database is maintained online by a third party.\n\nThe BIG-IP system can connect to an IP intelligence database, download the contents, and automatically keep the database up to date. You use iRules to instruct the system on how to use IP address intelligence information. For example, iRules can instruct the system to verify the reputation of and log the originating IP address of all requests.\n\nYou can also use the IP address intelligence information within security policies in the Application Security Manager to log or block requests from IP addresses with questionable reputations.\n\nThe requirements for using IP address intelligence are:\n\nThe system must have an IP Intelligence license. The system must have an Internet connection either directly or through a proxy server. The system must have DNS configured (go to System > Configuration > Device > DNS).","examples":"# Look up a set of IP addresses in the IP reputation database and log the output. As an example, check if the IP is a Proxy (lsearch returns a non -1 value).\nwhen RULE_INIT {\n    # Only log once regardless of however many TMMs are running\n    if {[TMM::cmp_unit]==0}{\n        # Loop through some known bad IPs\n        foreach ip [list 8.5.1.16 1.1.17.0 1.161.40.194 2.32.20.157 2.50.32.55 2.56.0.0 254.46.202.147] {\n            # Log the IP, reputation list, count of reputation hits and a sample search to see if the IP is a Proxy (non -1 = true)\n            log local0. \"$ip: \\\"[IP::reputation $ip]\\\", count: [llength [IP::reputation $ip]], lsearch for Proxy: [lsearch [IP::reputation $ip] Proxy] \"\n        }\n    }\n}\n\n# Log output:\n#<RULE_INIT>: 8.5.1.16: \"{Web Attacks} BotNets Scanners Proxy\", count: 4, lsearch for Proxy: 3\n#<RULE_INIT>: 1.1.17.0: \"{Web Attacks} Scanners\", count: 2, lsearch for Proxy: -1\n#<RULE_INIT>: 1.161.40.194: \"{Windows Exploits} Scanners\", count: 2, lsearch for Proxy: -1\n#<RULE_INIT>: 2.32.20.157: \"Proxy\", count: 1, lsearch for Proxy: 0\n#<RULE_INIT>: 2.50.32.55: \"{Spam Sources} Proxy\", count: 2, lsearch for Proxy: 1\n#<RULE_INIT>: 2.56.0.0: \"{Spam Sources} {Web Attacks}\", count: 2, lsearch for Proxy: -1\n#<RULE_INIT>: 254.46.202.147: \"Phishing\", count: 1, lsearch for Proxy: -1\n\n# Here are a few example IPs with reputations:\n# 1.1.17.0    Scanners\n# 2.32.20.157 Proxy\n# 2.56.0.0    Spam Sources, Web Attacks\n# 198.200.32.76   Spam Sources, Scanners\n\n\n#Drop the packet after initial TCP handshake if the client has a bad reputation\nwhen CLIENT_ACCEPTED {\n    # Check if the IP reputation list for the client IP is not 0\n    if {[llength [IP::reputation [IP::client_addr]]] != 0}{\n        # Drop the connection\n        drop\n    }\n}\n\nwhen DNS_RESPONSE {\n    # If Query type was A and response is an answer.\n    if { ([DNS::question type] eq \"A\") and ([DNS::ptype] == \"ANSWER\") } {\n        set rrs [DNS::answer]\n        foreach rr $rrs {\n            if { [DNS::type $rr] eq \"A\" } {\n                if {[llength [IP::reputation [DNS::rdata $rr]]] != 0} {\n                    # Bad IP Reputation for destination detected\n                    log local0. \"$rr: \\\"[IP::reputation $ip]\\\", count: [llength [IP::reputation $rr]]\"\n                }\n            }\n        }\n    }\n}","returnValue":"Return a TCL list containing reputation categories."},
{"commandName":"IP::intelligence","description":"This iRules command returns a Tcl list of IP intelligence category names for a given IP address. It checks up to 3 (configured) IP intelligence policies - global policy, policy attached to virtual server and policy attached to route domain. If any of the policies use IP reputation database, it will also be checked. This command is an extention of the IP::reputation command, which checked only IP reputation database available from external source. This new command checks user defined IP classification configured in IP intelligence policies, which get their lists of IP addresses and categories from user defined feeds. Each policy can additionally use the legacy IP reputation database, but is not required to.\n\nThe requirements for using IP address intelligence are:\n-- The system must have an IP Intelligence license.\n-- The system must have an Internet connection either directly or through a proxy server.\n-- The system must have DNS configured (go to System > Configuration > Device > DNS).","examples":"# This irule can be used to test IP Intelligence dwbl (feed lists).\n# if a request comes in with a URI query:  ?ip=10.0.0.2, it returns the intelligence record.\n# if no query is supplied, it returns the intelligence file.  You can use this in the feed list configuration.\nwhen HTTP_REQUEST {\n    set ip [URI::query [HTTP::uri] ip]\n    if { $ip equals \"\" } {\n        log local0. \"Got a Feed List update request from [IP::client_addr]\"\n    HTTP::respond 200 content {10.0.0.2,32,bl,spam_sources\n10.0.0.3,,wl,botnets\n10.10.0.12,,botnets\n10.0.0.12,,,\n10.0.0.13,,bl,\n    }\n    } else {\n        HTTP::respond 200 content \"<html>Reputation of $ip is: [IP::intelligence $ip]</html>\"\n    }\n}","returnValue":"Return a Tcl list of IP intelligence category names for a given IP address"},
{},
{},
{"commandName":"IPFIX::template","description":"This command provides the ability to create and delete user defined IPFIX\nmessage templates that may be used to send IPFIX messages to a specified\ndestination.\n\nSyntax\n\nIPFIX::template create TEMPLATE_STRING\n\n    * When called with the create keyword and a valid template string,\n      IPFIX::template create returns a IPFIX_TEMPLATE object.  The\n      IPFIX_TEMPLATE object is then used when creating an IPFIX message\n      via the IPFIX::msg command.  It is recommend to store the resulting\n      template object in a static variable so that it is accessible for\n      all instances of the rule.  If the IPFIX_TEMPLATE object is not\n      stored statically, the template will be regenerated each time\n      the rule is executed.\n\n      The TEMPLATE_STRING consists of a space delimited list of IPFIX\n      elements.  The default elements can be listed via the \"tmsh list\n      sys IPFIX element\" command.  Enterprise IPFIX elements can be\n      created via the \"tmsh create ipfix element\" command.\n\nIPFIX::template delete IPFIX_TEMPLATE\n\n    * Template objects can be deleted be via the IPFIX::template delete\n      IPFIX_TEMPLATE command to free any resources associated with the\n      object.","examples":"when RULE_INIT {\n    set static::http_track_dest \"\"\n    set static::http_track_tmplt \"\"\n}\n\nwhen CLIENT_ACCEPTED {\n    if { $static::http_track_dest == \"\" } {\n       # open the logging destination if it has not been, opened yet\n       set static::http_track_dest [IPFIX::destination open -publisher /common/ipfix_publisher]\n    }\n\n    if { $static::http_track_tmplt == \"\" } {\n       # if the template has not been created yet, create the template\n       set static::http_track_tmplt [IPFIX::template create \"flowStartSeconds sourceIPv4Address \\\n                                                             tcpSourcePort destinationIPv4Address \\\n                                                             tcpDestinationPort\" ]\n    }\n}\n\nwhen HTTP_REQUEST {\n    # create a new message for this request\n    set msg [IPFIX::msg create $static::http_track_tmplt]\n    #set information in the message from the http request\n    IPFIX::msg set $msg flowStartSeconds [clock seconds]\n    IPFIX::msg set $msg sourceIPv4Address [IP::client_addr]\n    IPFIX::msg set $msg tcpSourcePort [TCP::client_port]\n}\n\nwhen HTTP_RESPONSE_RELEASE {\n    # set information in the message from the response\n    IPFIX::msg set $msg destinationIPv4Address [IP::server_addr]\n    IPFIX::msg set $msg tcpDestinationPort [TCP::server_port]\n    # send the message\n    IPFIX::destination send $static::http_track_dest $msg\n}","returnValue":"IPFIX::template create TEMPLATE_STRING returns an IPFIX template object\nthat is used by the IPFIX::msg create command and IPFIX::template delete\ncommand."},
{"commandName":"IPFIX::destination","description":"Provides the ability to open and close IPFIX logging destinations in\nthe context of an iRule, as well as the ability to send IPFIX messages\nto the IPFIX logging destinations.\n\nSyntax\n\nIPFIX::destination open -publisher LOG_PUBLISHER\n\n    * Returns an IPFIX_DESTINATION object that allows the user to send\n      messages to the specified LOG_PUBLISHER via the IPFIX::destination\n      send command.\n\n      It is recommended to store the resulting IPFIX_DESTINATION object\n      in a static variable so that it is accessible for all instances of\n      the rule.  If the IPFIX_DESTINATION object is not stored\n      statically, it will be opened each time the rule is executed and\n      a new IPFIX_DESTINATION object will be generated each time.\n\n      The LOG_PUBLISHER is a reference to a log publisher configured\n      on the BIGIP that includes a netflow or IPFIX logging destination.\n      e.g. /Common/my_log_publisher\n\nIPFIX::destination close IPFIX_DESTINATION\n\n    * Closes the specified IPFIX_DESTINATION.\n\nIPFIX::destination send IPFIX_DESTINATION IPFIX_MESSAGE\n\n    * Causes the provided IPFIX_MESSAGE to be sent to the specified\n       IPFIX_DESTINATION.  The IPFIX_MESSAGE object is created via the\n       IPFIX::msg create command, and the IPFIX_DESTINATION is created\n       vi the IPFIX::destination open command.","examples":"when RULE_INIT {\n    set static::http_track_dest \"\"\n    set static::http_track_tmplt \"\"\n}\n\nwhen CLIENT_ACCEPTED {\n    if { $static::http_track_dest == \"\" } {\n       # open the logging destination if it has not been, opened yet\n       set static::http_track_dest [IPFIX::destination open -publisher /common/ipfix_publisher]\n    }\n\n    if { $static::http_track_tmplt == \"\" } {\n       # if the template has not been created yet, create the template\n       set static::http_track_tmplt [IPFIX::template create \"flowStartSeconds sourceIPv4Address \\\n                                                             tcpSourcePort destinationIPv4Address \\\n                                                             tcpDestinationPort\" ]\n    }\n}\n\nwhen HTTP_REQUEST {\n    # create a new message for this request\n    set msg [IPFIX::msg create $static::http_track_tmplt]\n    #set information in the message from the http request\n    IPFIX::msg set $msg flowStartSeconds [clock seconds]\n    IPFIX::msg set $msg sourceIPv4Address [IP::client_addr]\n    IPFIX::msg set $msg tcpSourcePort [TCP::client_port]\n}\n\nwhen HTTP_RESPONSE_RELEASE {\n    # set information in the message from the response\n    IPFIX::msg set $msg destinationIPv4Address [IP::server_addr]\n    IPFIX::msg set $msg tcpDestinationPort [TCP::server_port]\n    # send the message\n    IPFIX::destination send $static::http_track_dest $msg\n}","returnValue":"IPFIX::destination open returns an IPFIX_DESTINATION object that\nis used by the IPFIX::destination close or send command."},
{"commandName":"IPFIX::msg","description":"Provides the ability to create, delete and set data values in an IPFIX\nmessage based on the provided IPFIX_TEMPLATE.\n\nSyntax\n\nIPFIX::msg create IPFIX_TEMPLATE\n\n    * Create an IPFIX_MESSAGE object based on the provided IPFIX_TEMPLATE.\n      It is necessary to create an IPFIX_MESSAGE before filling in the\n      values in the message.  The values may be filled in from multiple\n      events within the context of a single connection.\n\n      The IPFIX::msg create command returns an IPFIX_MESSAGE\n      object which is used by the IPFIX::msg set|delete and\n      IPFIX::destination send commands.\n\n      The IPFIX_TEMPLATE object is created via the IPFIX::template create\n      command.\n\nIPFIX::msg set IPFIX_MESSAGE IPFIX_FIELDTYPE (-pos IPFIX_POS) \\\n           IPFIX_FIELDVALUE\n\n    * Sets the value of a field in an IPFIX_MESSAGE.  Fields are\n      referenced by the IPFIX element type in the template.\n\n      If there is more than one instance of a particular IPFIX element\n      type in a template, the optional -pos IPFIX_POS flag can be\n      specified to set the value of the correct field in the message.\n      IPFIX_POS starts from index 0.\n\nIPFIX:msg delete IPFIX_MESSAGE\n\n    * Deletes the provided IPFIX_MESSAGE.  This is not generally\n      necessary as the object is automatically destroyed when it\n      goes out of scope.","examples":"when RULE_INIT {\n    set static::http_track_dest \"\"\n    set static::http_track_tmplt \"\"\n}\n\nwhen CLIENT_ACCEPTED {\n    if { $static::http_track_dest == \"\" } {\n       # open the logging destination if it has not been, opened yet\n       set static::http_track_dest [IPFIX::destination open -publisher /common/ipfix_publisher]\n    }\n\n    if { $static::http_track_tmplt == \"\" } {\n       # if the template has not been created yet, create the template\n       set static::http_track_tmplt [IPFIX::template create \"flowStartSeconds sourceIPv4Address \\\n                                                             tcpSourcePort destinationIPv4Address \\\n                                                             tcpDestinationPort action action\" ]\n    }\n}\n\nwhen HTTP_REQUEST {\n    # create a new message for this request\n    set msg [IPFIX::msg create $static::http_track_tmplt]\n    #set information in the message from the http request\n    IPFIX::msg set $msg flowStartSeconds [clock seconds]\n    IPFIX::msg set $msg sourceIPv4Address [IP::client_addr]\n    IPFIX::msg set $msg tcpSourcePort [TCP::client_port]\n    IPFIX::msg set $msg action -pos 0 \"Request\"\n}\n\nwhen HTTP_RESPONSE_RELEASE {\n    # set information in the message from the response\n    IPFIX::msg set $msg destinationIPv4Address [IP::server_addr]\n    IPFIX::msg set $msg tcpDestinationPort [TCP::server_port]\n    IPFIX::msg set $msg action -pos 1 \"Response\"\n    # send the message\n    IPFIX::destination send $static::http_track_dest $msg\n}","returnValue":"IPFIX::msg create returns an IPFIX_MESSAGE object that is used by\nthe IPFIX::msg set|delete and IPFIX::destination send commands."},
{"commandName":"PROTOCOL_INSPECTION::id","description":"This command provides inspection match result.\n\nSyntax\n\nPROTOCOL_INSPECTION::id\n\n     * Returns inspection match ids in form of array","examples":"In the example, the PROTOCOL_INSPECTION::id array is logged.\n\nwhen PROTOCOL_INSPECTION_MATCH {\n    set id [PROTOCOL_INSPECTION::id]\n    log local0.debug \"inspection id: $id\"\n}","returnValue":"PROTOCOL_INSPECTION::id returns inspection id array"},
{"commandName":"PROTOCOL_INSPECTION::disable","description":"Disables inspection of the flow","examples":"","returnValue":""},
{"commandName":"ISESSION::deduplication","description":"Allows selection of deduplication based on L7 content inspection\n\n\nSyntax\n\nISESSION::deduplication enable|disable\n\n     * Allows selection of deduplication based on L7 content inspection","examples":"","returnValue":""},
{"commandName":"ISTATS::get","description":"Reads in the value associated with the given iStats key\n\nSyntax\n\nISTATS::get <key>\n\n     * Always reads aggregate (not tmm-local) value","examples":"when HTTP_REQUEST {\n        if { [string tolower [HTTP::uri]] equals \"/12345\" } {\n                ISTATS::incr \"uri /12345 counter Requests\" 1\n                HTTP::uri \"/\"\n                HTTP::redirect \"http://www.mysite.com\"\n        } elseif { [string tolower [HTTP::uri]] equals \"/stats\" } {\n                  HTTP::respond 200 content \"<html><body>Requests for /12345: [ISTATS::get \"uri /12345 counter Requests\"]</body></html>\"\n        }\n}","returnValue":"Returns the value associated with the given key."},
{"commandName":"ISTATS::incr","description":"Increments the specified key by the given value. The increment value must be non-negative for a counter.\n\nNote that text string iStats may not be incremented.\n\nSyntax\n\nISTATS::incr <key> <value>\n\n     * Increments the specified iStats key by the given value.\n\n     Note that there is no default increment value, so the value is\n     required, not optional.","examples":"when HTTP_REQUEST {\n        if { [string tolower [HTTP::uri]] equals \"/12345\" } {\n                ISTATS::incr \"uri /12345 counter Requests\" 1\n                HTTP::uri \"/\"\n                HTTP::redirect \"http://www.mysite.com\"\n        } elseif { [string tolower [HTTP::uri]] equals \"/stats\" } {\n                  HTTP::respond 200 content \"<html><body>Requests for /12345: [ISTATS::get \"uri /12345 counter Requests\"]</body></html>\"\n        }\n}","returnValue":""},
{"commandName":"ISTATS::remove","description":"Removes the given iStat entirely.\n\nSyntax\n\nISTATS::remove \"<key>\"\n\n    * The \"<key>\" must be in quotes and identical to the key used to\n    set/incr/get the iStat.\n\n    ISTATS::remove is valid in all events/contexts in data plane iRules and\n    control plane iCall scripts","examples":"ISTATS::remove \"ltm.pool /Common/mypool counter some_counter\"","returnValue":""},
{"commandName":"ISTATS::set","description":"Set the given key's value within iStats\n\nSyntax\n\nISTATS::set <key> <value>\n\n     * Set the given key's value within iStats. The key consists of a\n       class, object, measure type (counter, gauge, string), and measure\n       name, separated by whitespace and enclosed in double quotes.","examples":"when HTTP_REQUEST {\n  # send request to /invalidate?policy=<policy>\n  if { [HTTP::path] eq \"/invalidate\" } {\n        set wa_policy [URI::query [HTTP::uri] policy]\n        if { $wa_policy ne \"\" } {\n          ISTATS::set \"WA policy string $wa_policy\" \"invalidated\"\n        }\n        HTTP::respond 200 content \"<html><body>Cache Invalidated for Policy: $wa_policy</body></html>\"\n  }\n}","returnValue":""},
{"commandName":"IVS_ENTRY::result","description":"Send a result code to the IVS (Internal Virtual Server) client\n(usually ADAPT). The intent is to allow an IVS to be used in a\nuser-defined way without a specific IVS profile like \"icap\". If an\n\"icap\" profile is present, IVS_ENTRY::result should not be used as\nit would cause a second result to be sent to the IVS client\n(usually ADAPT), with undefined effect.\n\nSyntax\n\nIVS_ENTRY::result [noop | modified | response]\n\n    * Sends a result code to the IVS client","examples":"when IVS_ENTRY_REQUEST {\n                # Tell primary virtual the IVS will not handle this request\n                IVS_ENTRY::result noop\n            }","returnValue":""},
{"commandName":"LB::bias","description":"","examples":"","returnValue":""},
{"commandName":"LB::class","description":"Provides the name of the traffic class that matched the connection","examples":"","returnValue":"Return the name of the traffic class that matched the connection"},
{"commandName":"LB::command","description":"","examples":"","returnValue":""},
{"commandName":"LB::connlimit","description":"Set the connection limit for virtual/node/poolmember","examples":"","returnValue":""},
{"commandName":"LB::connect","description":"","examples":"","returnValue":""},
{},
{"commandName":"LB::detach","description":"This command detaches the server-side connection from the client-side.\n\nLB::detach\n    Detaches the server side connection from the client-side connection.\n    Use in conjunction with TCP::notify as best practice.","examples":"when SERVER_CONNECTED {\n    if { $connRetry >= $maxAttempts } {\n        TCP::notify response\n    }\n}\nwhen USER_RESPONSE {\n    LB::detach\n}","returnValue":""},
{},
{},
{"commandName":"LB::mode","description":"Sets the load balancing mode, overriding the mode set in the pool definition\n\nLB::mode [default | rr | roundrobin | leastconns |\n          fastest | predictive | observed | ratio |\n          dynratio | nodeleastconns | noderatio]","examples":"when LB_SELECTED {\n    if { $myretry >= 1 } {\n        LB::mode rr\n        LB::reselect pool $mypool\n    }\n}","returnValue":""},
{"commandName":"LB::persist","description":"This command forces the system to make a persistence decision, and returns a string that can be evaluated to activate that selection, or with the use of the parameter, returns a persistence key that may be used in conjunction with the persist command to manipulate the persistence table.\n\nThis enables an iRule to evaluate the pending load balancing/persistence decision early, and use that information to manage the connection.","examples":"","returnValue":""},
{},
{"commandName":"LB::reselect","description":"This command is used to advance to the next available node in a pool, either using the load balancing settings of that pool, or by specifying a member explicitly. Note that the reselect may not happen immediately; it may wait until the current iRule event is completely finished executing.\n\nThere is no reselect retry limit built into the command: You MUST implement a limiting mechanism in your iRule using logic similar to that in the examples below. For more information, refer to AskF5 SOL10386 - Using LB::reselect iRules command without a limiting mechanism may result in a SYN flood\n\nLB::reselect\n    Selects the next available member in the current pool, based on pool Load Balancing options\n\nLB::reselect nexthop <IP address>\n    Selects the MAC address for the selected IP address as the nexthop\n    See nexthop for possible additional options\n\nLB::reselect pool <pool_name>\n    Selects the next available member in the specified pool, based on the Load Balancing options of that pool\n\nLB::reselect pool <pool_name> <member>\n    Selects the specified member from the specified pool\n\nLB::reselect rateclass <rateclass name>\n    Selects the specified rate class\n\nLB::reselect virtual <virtual server name>\n    Selects the specified virtual server\n\nLB::reselect vlan <vlan name>\n    Selects the specified VLAN","examples":"when CLIENT_ACCEPTED {\n    set def_pool [LB::server pool]\n    set lb_fails 0\n}\nwhen LB_FAILED {\n    if { $lb_fails < [active_members $def_pool] } {\n        LB::mode rr\n        LB::reselect pool $def_pool\n    } else {\n        ... add failure logic here\n    }\n    incr lb_fails\n}","returnValue":""},
{},
{"commandName":"LB::server","description":"This command allows you to query for information about the member selected after a load balancing decision has been made.\n\nIf no server was selected (all servers down), this command with either no arguments or the \"name\" argument will return the pool name only--useful for determining the default pool applied to a virtual server. If the node command is called prior to this command a null string is returned as the node command overrides any prior pool selection logic.\n\nLB::server [name | pool | route_domain | addr | port | priority | ratio | weight | ripeness]","examples":"when LB_SELECTED {\n    # Once pool member has been selected check if it's 10.0.0.25\n    if { [IP::addr [LB::server addr] equals 10.0.0.25] } {\n\n        # Reselect a new pool member within the pool\n        LB::reselect\n\n        # Retry the request to the new pool member\n        HTTP::retry\n    }\n}\n\nDo something if all servers are down in the default pool:\n\nwhen HTTP_REQUEST {\n    # Check if the default pool has less than one active member\n    if { [active_members [LB::server pool]] < 1 } {\n        [do something]\n    }\n}\n\nGet the default pool of the VIP's name before it could have been changed by an iRule, HTTP class or other method:\n\nwhen CLIENT_ACCEPTED {\n    # Save the name of the VIP's default pool\n    set default_pool [LB::server pool]\n}","returnValue":"LB::server\n    returns a Tcl list with pool, pool member address and port. If no server was selected yet or all servers are down, returns default pool name only.\n\nLB::server name\n    returns a Tcl list with pool, pool member address and port. If no server was selected yet or all servers are down, returns default pool name only.\n\nLB::server pool\n    Returns the pool of the currently selected member. If no server was selected yet or all servers are down, returns default pool name.\n\nLB::server addr\n    Returns the IP address of the currently selected pool member. If no server was selected yet or all servers are down, returns null.\n\nLB::server port\n    Returns the port of the currently selected pool member. If no server was selected yet or all servers are down, returns null.\n\nLB::server priority\n    Returns the priority of the currently selected pool member. If no server was selected yet or all servers are down, returns null. If priority is not configured for the pool member, the default priority value of 1 is returned.\n\nLB::server ratio\n    Returns the ratio value of the currently selected pool member. If no server was selected yet or all servers are down, returns null. If ratio is not configured for the pool member, the default ratio value of 1 is returned.\n\nLB::server route_domain¶\n    Returns the route domain ID of the currently selected pool member. If no server was selected yet or all servers are down, returns null. Also returns null if the route domain is 0 (default).\n\nLB::server weight\n    Returns the weighting of the currently selected pool member. If no server was selected yet or all servers are down, returns null.\n\nLB::server ripeness\n    Returns the ripeness information of the currently selected pool member. If no server was selected yet or all servers are down, returns null."},
{"commandName":"LB::snat","description":"This command returns information on the SNAT configuration for the current connection.\n\nPossible output values are those which can be set by the snat and snatpool commands.","examples":"when CLIENT_ACCEPTED {\n    # Check if SNAT is enabled on the VIP\n    if {[LB::snat] eq \"none\"}{\n        log local0. \"Snat disabled on [virtual name]\"\n    } else {\n        log local0. \"Snat enabled on [virtual name].  Currently set to [LB::snat]\"\n    }\n}","returnValue":"LB::snat\n\nReturns a TCL list based on the current connection's SNAT configuration. The possible values seem to be 'none', 'automap', 'snatpool <snat_pool_name>, 'snat <IP address>'. The 'snat <IP address>' output only seems to be logged when snat is explicitly set using 'snat <IP address>' in an iRule."},
{"commandName":"LB::status","description":"Returns the status of a node address or pool member. Possible status values are up, down, session_enabled, and session_disabled. If you supply no arguments, returns the status of the currently-selected pool member.\nSyntax:\n    LB::status\n    LB::status node <address>\n    LB::status pool <pool name> member <IP address> <port>\n    LB::status <up | down | session_enabled | session_disabled>\n    LB::status node <address> <up | down | session_enabled | session_disabled>\n    LB::status pool <pool name> member <address> <port> <up | down | session_enabled | session_disabled>\n\nSlight difference for GTM syntax, rather than node, use vs:\n    LB::status vs <server> <vs>\n    LB::status vs <server> <vs> <up | down | session_enabled | session_disabled>","examples":"when LB_FAILED {\n    if { [LB::status pool $poolname member $ip $port] eq \"down\" } {\n        log \"Server $ip $port down!\"\n    }\n}","returnValue":"LB::status\n    Returns the status of the currently-selected node (after LB_SELECTED event only). Possible values are: up | down | session_enabled | session_disabled\n\nLB::status node <IP address>\n    Returns the status of the node with the specified IP address. Possible values are: up | down | session_enabled | session_disabled\n\nLB::status pool <pool name> member <IP address> <port>¶\n    Returns the status of the specified pool member. Possible values are: up | down | session_enabled | session_disabled\n\nLB::status <up | down | session_enabled | session_disabled>¶\n    Returns TRUE if the status of the currently-selected node matches the specified status argument.\n\nLB::status node <address> <up | down | session_enabled | session_disabled>¶\n    Returns TRUE if the status of the specified node matches the specified status argument.\n\nLB::status pool <pool name> member <address> <port> <up | down | session_enabled | session_disabled>¶\n    Returns TRUE if the status of the specified pool member matches the specified argument. (This syntax doesn't seem to be working as expected in 9.2.3 at least... use alternate syntax in Example below)"},
{"commandName":"LB::up","description":"Sets the status of the specified node or pool member as being up. If you specify no arguments, the status of the currently-selected node is modified.\n\nSyntax\n    LB::up\n    LB::up node <address>\n    LB::up pool <pool> member <address> <port>\n\nLB::up\n    Sets the status of the currently-selected node as being up.\n\nLB::up node <address>\n    Sets the status of the specified node as being up.\n\nLB::up pool <pool> member <address> <port>\n    Sets the status of the specified pool member as being up.","examples":"","returnValue":""},
{"commandName":"LB::down","description":"Sets the status of the specified node or pool member as being down. If you specify no arguments, the status of the currently-selected node is modified.\nNote: Calling LB::down in an iRule triggers an immediate monitor probe regardless of the monitor interval settings.\n\nLB::down\n    Sets the status of the currently-selected node as being down.\n\nLB::down node <address>\n    Sets the status of the specified node as being down.\n    Doesn't work. Use LB::down or LB::down pool <pool> member <address> <port>. Refer to BZ222047 for details.\n\nLB::down pool <pool> member <address> <port>\n    Sets the status of the specified pool member as being down.","examples":"when HTTP_RESPONSE {\n    if { [HTTP::status] == 500 } {\n        LB::down\n    }\n}","returnValue":""},
{"commandName":"LB::queue","description":"Returns queue information. Connection queuing details:\n\n    * Operates at the TCP level\n    * Only engages when the connection limit is hit\n    * Queue is specified by length, time, or both (in the pool configuration)\n    * Queues operate per-tmm, there is no state sharing\n        * Length limit divided by tmm count\n        * FIFO guarantees only per-tmm\n    * Queued at the pool level for non-persistent connections\n    * Queued at the pool member level for persistent connections.\n        * If connection limit is overridden by persistence, that connection is not queued\n    * When a pool member becomes available, it checks the head of its queue, and of the pool's queue, and services the flow that got there first.\n\n\nCurrently, there is no explicit control over queuing. Once queued, you can still use existing commands to control flows (e.g. HTTP::respond, node, pool, drop, reject, etc.) There is no support for queue priority at this time, it is strictly FIFO.\n\nSyntax:\n    LB::queue limit depth|time [<pool name>]\n    LB::queue on connlimit [<pool name>]\n    LB::queue depth all|one [<pool name> [<addr> <port>]]\n    LB::queue age head|max|edm|ema [<pool name [<addr> <port>]]\n    LB::queue queued","examples":"when LB_QUEUED {\n    log local0. \"[IP::local_addr] was queued - [LB::queue depth one pool1] / [LB::queue limit depth pool1]\"\n}\n\nwhich with a queue depth of 5 returns:\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 1/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 2/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 3/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 4/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 5/5\nRule queue_log <LB_QUEUED>: 10.10.128.1 was queued - 5/5","returnValue":"LB::queue limit depth|time [<pool name>]\n    Returns queue limit info (depth is per-tmm)\n\n\nLB::queue on connlimit [<pool name>]\n    Returns \"enabled\" or \"disabled\"\n\n\nLB::queue depth all|one [<pool name> [<addr> <port>]]\n    Returns queue depth information (all is sum of pool members)\n\n\nLB::queue age head|max|edm|ema [<pool name [<addr> <port>]]\n    Returns queue age statistics\n    Current head of queue, all-time max, exponential-decaying max, or exponential moving-average\n\nLB::queue queued\n    Returns true if this connection is or was queued"},
{"commandName":"LDAP::enable","description":"Enable LDAP STARTTLS","examples":"when CLIENT_ACCEPTED {\n                if { !([IP::addr [IP::client_addr] equals 10.0.0.0/8]) } {\n                    LDAP::enable\n                }\n            }","returnValue":""},
{"commandName":"LDAP::disable","description":"Disable LDAP STARTTLS","examples":"when CLIENT_ACCEPTED {\n                if { ([IP::addr [IP::client_addr] equals 10.0.0.0/8]) } {\n                    LDAP::disable\n                }\n            }","returnValue":""},
{"commandName":"LDAP::activation_mode","description":"Sets the activation mode to none (it will never activate), allow (if the SMTP client sends STARTTLS, we will activate TLS), or require (all commands will be rejected until STARTTLS is received).","examples":"when CLIENT_ACCEPTED {\n                if { !([IP::addr [IP::client_addr] ne 10.0.0.0/8) } {\n                    LDAP::activation_mode require\n                }\n            }","returnValue":""},
{},
{},
{"commandName":"LINK::lasthop","description":"Returns the MAC address of the last hop.\nNote:\n  * In 11.4, you can extend LINK::lasthop with sub-commands to retrieve\n    the lasthop id, type, name, respectively. Without sub-command,\n    LINK::lasthop returns the MAC address as before.\n\nSyntax\n\nLINK::lasthop [id]\n\n     * Returns the MAC address of the last hop.\n\nLINK::lasthop type\n\n     * Returns the type of the last hop, namely \"VLAN\", \"VLAN-GROUP\",\n       \"TUNNEL\", \"LOOPBACK\" or \"UNKNOWN\".\n\nLINK::lasthop name\n\n     * Returns the name of the last hop.","examples":"when CLIENT_ACCEPTED {\n  set lastmac [LINK::lasthop]\n  session add uie [IP::client_addr] $lastmac 180\n}\n\n\n# Logging example\nwhen CLIENT_ACCEPTED {\n        log local0. \"\\[LINK::lasthop\\]: [LINK::lasthop], \\[LINK::nexhop\\]: [LINK::nexthop]\"\n        log local0. \"\\[LINK::lasthop\\]: [LINK::lasthop] [LINK::lasthop type] [LINK::lasthop name] [LINK::lasthop id]\"\n}\nwhen SERVER_CONNECTED {\n        log local0. \"\\[clientside {LINK::lasthop}\\]: [clientside {LINK::lasthop}], \\[clientside {LINK::nexthop}\\]: [clientside {LINK::nexthop}]\"\n        log local0. \"\\[LINK::lasthop\\]: [LINK::lasthop], \\[LINK::nexhop\\]: [LINK::nexthop]\"\n}\n\n/var/log/ltm output where CLIENT_MAC is the MAC address of the clientside hop and SERVER_MAC is the serverside hop.\n\n<CLIENT_ACCEPTED>: [LINK::lasthop]: CLIENT_MAC, [LINK::nexhop]: ff:ff:ff:ff:ff:ff\n<CLIENT_ACCEPTED>: [LINK::lasthop]: CLIENT_MAC VLAN /Common/clientnet CLIENT_MAC\n<SERVER_CONNECTED>: [clientside {LINK::lasthop}]: CLIENT_MAC, [clientside {LINK::nexthop}]: SERVER_MAC\n<SERVER_CONNECTED>: [LINK::lasthop]: SERVER_MAC, [LINK::nexhop]: CLIENT_MAC","returnValue":"LINK::lasthop [id]\n\n     * Returns the MAC address of the last hop.\n\nLINK::lasthop type\n\n     * Returns the type of the last hop, namely \"VLAN\", \"VLAN-GROUP\",\n       \"TUNNEL\", \"LOOPBACK\" or \"UNKNOWN\".\n\nLINK::lasthop name\n\n     * Returns the name of the last hop."},
{"commandName":"LINK::nexthop","description":"Returns the MAC address of the next hop. Returns the broadcast address\nff:ff:ff:ff:ff:ff when called before a serverside connection has been\nestablished.\nNote:\n  * In 11.4, you can use LINK::nexthop with sub-commands to retrieve\n    the id, type and name of the next hop, respectively. Without\n    sub-commands, LINK::nexthop returns the MAC address as before.\n\nSyntax\n\nLINK::nexthop [id]\n\n     * Returns the MAC address of the next hop.\n\nLINK::nexthop type\n\n     * Returns the type of the next hop, namely \"VLAN\", \"VLAN-GROUP\",\n       \"TUNNEL\", \"LOOPBACK\" or \"UNKNOWN\".\n\nLINK::nexthop name\n\n     * Returns the name of the next hop.","examples":"# log requests\nwhen CLIENT_ACCEPTED {\n    set info \"client { [IP::client_addr]:[TCP::client_port] -> [IP::local_addr]:[TCP::local_port] }\"\n    append info \" ethernet { [string range [LINK::lasthop] 0 16] -> [string range [LINK::nexthop] 0 16] tag [LINK::vlan_id] qos [LINK::qos] }\"\n    log local0. $info\n}\n\n\n# Logging example\nwhen CLIENT_ACCEPTED {\n        log local0. \"\\[LINK::lasthop\\]: [LINK::lasthop], \\[LINK::nexhop\\]: [LINK::nexthop]\"\n}\nwhen SERVER_CONNECTED {\n        log local0. \"\\[clientside {LINK::lasthop}\\]: [clientside {LINK::lasthop}], \\[clientside {LINK::nexthop}\\]: [clientside {LINK::nexthop}]\"\n        log local0. \"\\[LINK::lasthop\\]: [LINK::lasthop], \\[LINK::nexhop\\]: [LINK::nexthop]\"\n        log local0. \"\\[serverside {LINK::nexthop}\\]: [serverside {LINK::nexthop}] [serverside {LINK::nexthop type}] [serverside {LINK::nexthop name}] [serverside {LINK::nexthop id}]\"\n        log local0. \"\\[serverside {LINK::lasthop}\\]: [serverside {LINK::lasthop}] [serverside {LINK::lasthop type}] [serverside {LINK::lasthop name}] [serverside {LINK::lasthop id}]\"\n}\n\n/var/log/ltm output where CLIENT_MAC is the MAC address of the clientside hop and SERVER_MAC is the serverside hop.\n\n<CLIENT_ACCEPTED>: [LINK::lasthop]: CLIENT_MAC, [LINK::nexhop]: ff:ff:ff:ff:ff:ff\n<SERVER_CONNECTED>: [clientside {LINK::lasthop}]: CLIENT_MAC, [clientside {LINK::nexthop}]: SERVER_MAC\n<SERVER_CONNECTED>: [LINK::lasthop]: SERVER_MAC, [LINK::nexhop]: CLIENT_MAC\n<SERVER_CONNECTED>: [serverside {LINK::nexthop}]: CLIENT_MAC VLAN /Common/inet2CLIENT_MAC\n<SERVER_CONNECTED>: [serverside {LINK::lasthop}]: SERVER_MAC VLAN /Common/snet SERVER_MAC","returnValue":"LINK::nexthop [id]\n\n     * Returns the MAC address of the next hop.\n\nLINK::nexthop type\n\n     * Returns the type of the next hop, namely \"VLAN\", \"VLAN-GROUP\",\n       \"TUNNEL\", \"LOOPBACK\" or \"UNKNOWN\".\n\nLINK::nexthop name\n\n     * Returns the name of the next hop."},
{"commandName":"LINK::vlan_id","description":"Returns the VLAN tag of the packet. This command is equivalent to the\nBIG-IP 4.X variable vlan_id.\n\nSyntax\n\nLINK::vlan_id\n\n     * Returns the VLAN tag of the packet.","examples":"# log requests\nwhen CLIENT_ACCEPTED {\n    set info \"client { [IP::client_addr]:[TCP::client_port] -> [IP::local_addr]:[TCP::local_port] }\"\n    append info \" ethernet \"\n    append info \" { [string range [LINK::lasthop] 0 16] -> [string range [LINK::nexthop] 0 16] \"\n    append info \"tag [LINK::vlan_id] qos [LINK::qos] }\"\n    log local0. $info\n}","returnValue":"LINK::vlan_id\n\n     * Returns the VLAN tag of the packet."},
{"commandName":"LINK::qos","description":"Returns the QoS level set for the current packet.\nThe Quality of Service (QoS) standard is a means by which network\nequipment can identify and treat traffic differently based on an\nidentifier.\nThis command can be used to direct traffic based on the QoS level\nwithin a packet.\nThis command is equivalent to the BIG-IP 4.X variable link_qos.\n\nSyntax\n\nLINK::qos\n\n     * Returns the QoS level set for the current packet","examples":"when CLIENT_ACCEPTED {\n  if { [LINK::qos] > 2 } {\n     pool fast_pool\n  } else {\n     pool slow_pool\n }\n}","returnValue":"LINK::qos\n\n     * Returns the QoS level set for the current packet"},
{"commandName":"LSN::address","description":"Explicitly set the translation address regardless of the configured LSN pool.\n\nThe LSN::address command can be used while processing CLIENT_DATA. This event can occur before and after address translation. If this command is used after translation has occurred an error is thrown.\n\nAgruments:\n    LSN::address - Set the explicit translation IPv4 or IPv6 address for the connection in the current context.","examples":"when HTTP_REQUEST {\n    LSN::address 10.0.0.1\n}","returnValue":""},
{"commandName":"LSN::disable","description":"Disables LSN translation for the current connection if LSN translation has been configured.\n\nArguments:\n    LSN::disable - If LSN translation is configured, disables translation for this connection.","examples":"when HTTP_REQUEST {\n    LSN::disable\n}","returnValue":""},
{"commandName":"LSN::inbound","description":"Disable inbound mapping for translation address and port associated with the current connection.","examples":"when HTTP_REQUEST {\n    LSN::inbound disable\n}","returnValue":"LSN::inbound disable\n- Inbound connections can be permitted for a particular LSN pool to provide end-point independent filtering, described in RFC 4787.\n- When end-point independent filtering is enabled, once a client has sent traffic to a remote system, that remote system may thereafter use the translation address and port to send traffic back to the sourcing client.\n- When end-point independent filtering is used, translation address/port pairs must be reserved after first use, and will thus significantly reduce the overall number of translations for a given address pool set.\n- Configuration of end-point independent filtering may significantly decrease overall performance because traffic may need to be pushed between TMM instances.\n- If inbound connections are not configured for an LSN pool, this command will have no effect."},
{"commandName":"LSN::inbound-entry","description":"This command creates and gets the inbound mapping for a translation address, translation port and protocol.\n\nLSN::inbound-entry get <translation_address>:<translation_port> <protocol>\nLSN::inbound-entry create [-dslite <dslite local address> <dslite remote address>] <LSN pool name> <timeout> <client IP:client port> <translation address:translation port> <protocol>\n\nv11.5+\nLSN::inbound-entry delete <translation_address>:<translation_port> <protocol>","examples":"","returnValue":"LSN::inbound-entry get <translation IP>:<translation port> <protocol>\n    - Gets inbound entry for the specified translation IP, translation port and protocol. Protocol can be set TCP or UDP. This command returns the client IP address, port and route domain ID.\n\n\nLSN::inbound-entry create [-dslite <dslite local address> <dslite remote address>] <LSN pool name> <timeout> <client IP:client port> <translation address:translation port> <protocol>\n    - Creates an inbound mapping for the specified translation address and port. For a dslite client \"-dslite\" option should be used to specify the dslite tunnel details. The mapping is not saved If a matching entry for the specified translation address and port already exists. This command cannot be used if LSN pool mode is set to Deterministic. For NAPT mode the specified address must be in the LSN pool member list and the port must be within the translation port range.Timeout specifies the idle timeout for the entry. \"protocol\" specifies the protocol an external client will use to connect to the client IP/port behind LSN. This command returns the translation IP address, port and route domain ID.\n\n\nLSN::inbound-entry delete <translation_address>:<translation_port> <protocol>\n    - Deletes an inbound mapping for the specified translation address, port, and protocol."},
{"commandName":"LSN::persistence","description":"Set the translation address and port selection mode for the current connection, and the translation entry timeout.\n\nLSN::persistence <none|address|address-port> <timeout>","examples":"","returnValue":"LSN::persistence none\n\n    Disable LSN persistence for the current connection. In this mode, when a new connection is initiated from an arbitrary client IP address, the address used for translation is the next address available in the translation pool. The selection starts with the numerically lowest address, and the allocation of a new address is preferred over the allocation of a new port for a translation address that is already in use.\n\n\nLSN::persistence address <timeout>\n\n    Change LSN persistence mode to \"address\", setting the persistence timeout for the connection to <timeout> (in seconds). In this mode, when a connection is established from a particular client IP, a persistence entry is created. Each subsequent connection initiated from that client IP is mapped to the same translation address, when possible. If no connections are active from a client IP for <timeout> seconds, the persistence entry is removed and future client connection from that given IP may be persisted to a different translation IP.\n\n\nLSN::persistence port <timeout>\n\n    Change LSN persistence mode to \"port\", setting the persistence timeout for the connection to <timeout> (in seconds). In this mode, when a connection is established from a particular client IP and source port combination, a persistence entry is created. Each subsequent connection initiated from that client IP and souce port is mapped to the same translation address and port, when possible. If no connections are active from the particular client IP and source port for <timeout> seconds, the persistence entry is removed and future client connection from that given IP may be persisted to a different translation IP and port. See RFC 4787, REQ-1 for more information."},
{"commandName":"LSN::persistence-entry","description":"Create or lookup LSN translation address. Those commands are linked to CGNAT module introduced in 11.3. You need to license and provision this module to use this command.\n\nLSN::persistence-entry create [-override] <client_address>[:<client_port>] [<translation_address>[:<translation_port>]]\nLSN::persistence-entry get <client_address>[:<client_port>]\n\nv11.4+\nLSN::persistence-entry create [-override] <lsn_pool>  <client_address>[:<port>] <translation_address>[:<port>]]  [timeout]\n\nv11.5+\nLSN::persistence-entry delete <client_address>","examples":"when CLIENT_ACCEPTED {\n    set clientIP [IP::client_addr]\n}\nwhen SERVER_CONNECTED {\n    log local0. \"Client IP: $clientIP - LSN Persistence: [LSN::persistence-entry get $clientIP]\"\n}\n\nLog generated:\nMar 20 13:36:35 bigip2 info tmm9506: Rule /Common/LSNiRule : Client IP: 10.100.30.252 - LSN Persistence: 10.100.30.136:36753","returnValue":"LSN::persistence-entry create\n\n    Create a specific translation entry. Normally, this is occurs when a client initiates outbound traffic.\n    If the translation address is not provided, then the address is allocated based on the method configured on the LSN pool.\n\n\nLSN::persistence-entry get\n    Retrieve an existing translation record for the identified client.\n    The Persistence Mode must be set to Address or Address and Port in the LSN Pool Configuration.\n\n\nLSN::persistence-entry delete <client_address>\n    Deletes a specific client's translation entry."},
{"commandName":"LSN::pool","description":"Explicitly set the LSN pool used for translation.\n\nLSN::pool <pool_name>","examples":"","returnValue":"LSN::pool\n\nSet or override the LSN translation pool used for this connection. The LSN translation pool contains the candidate addresses to which a client address may be translated.\nThis command has no effect if the translation type is deterministic."},
{"commandName":"LSN::port","description":"Explicitly set the translation address regardless of the configured LSN pool.\n\nThe LSN::port command can be used while processing CLIENT_DATA. This event can occur before and after address translation. If this command is used after translation has occurred an error is thrown.\n\nLSN::port <translation_port>","examples":"","returnValue":"LSN::port\n\nProvide the explicit translation TCP or UDP source port for the connection in the current context. If the <translation_port> is outside of the configured port range for the LSN pool, or the translation mode is Deterministic, calls to LSN::port have no effect."},
{"commandName":"MQTT::respond","description":"This command can be used to transmit MQTT message back to sender of the incoming message.\nIf called from MQTT_CLIENT_INGRESS message will be sent to the client.\nIf called from MQTT_SERVER_INGRESS message will be sent to the server.\nPlease note that current message will be forwarded to destination. Use MQTT::drop to drop the current message.\nThis command is valid for all MQTT message types:\n\n    CONNECT, CONNACK,\n    PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP,\n    SUBSCRIBE, SUBACK,\n    UNSUBSCRIBE, UNSUBACK,\n    PINGREQ, PINGRESP,\n    DISCONNECT\n\nSyntax\n\nMQTT::respond type CONNACK return_code <return-code>\n                   [ session_present <session-present-flag> ]\n\n    * The <return-code> values must be set to one of the following:.\n            0 - Connection Accepted.\n            1 - Connection Refused, unacceptable protocol version.\n            2 - Connection Refused, identifier rejected.\n            3 - Connection Refused, Server unavailable.\n            4 - Connection Refused, bad username or password.\n            5 - Connection Refused, not authorized.\n      The <session-present-flag> can be set to 0 or 1. The default value is 0.\n\nMQTT::respond type PUBLISH topic <topic-name> payload <content>\n                   [{qos 0} | {qos (1 | 2) packet_id <packet-id-number>} ]\n                   [dup (0 | 1)]\n                   [retain (0 | 1)]\n\n    * For PUBLISH, the topic and payload are required parameters. If qos is 1 or 2, then packet_id must also be specified.\n      <packet-id-number> must be smaller than 65536.\n      Default values for optional parameters are:\n            qos         -: 0\n            dup         -: 0\n            retain      -: 0\n\nMQTT::respond type PUBACK  packet_id <packet-id-number>\nMQTT::respond type PUBREC  packet_id <packet-id-number>\nMQTT::respond type PUBREL  packet_id <packet-id-number>\nMQTT::respond type PUBCOMP packet_id <packet-id-number>\n    * For PUBACK, PUBREC, PUBREL, and PUBCOMP, packet_id is a required parameter. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n\nMQTT::respond type SUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For SUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536. <qos> can only be 0,1, or 2.\n\nMQTT::respond type SUBACK packet_id <packet-id-number> return_code_list {<return-code>}+\n    * For SUBACK, packet_id and return_code_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n\nMQTT::respond type UNSUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For UNSUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      Please note that <qos> values will be ignored. It is required to make format of topic_list same between SUBSCRIBE and UNSUBSCRIBE.\n      UNSUBSCRIBE does not need the qos.\n\nMQTT::respond type UNSUBACK packet_id <packet-id-number>\n    * For UNSUBACK, packet_id is required parameter.\n\nMQTT::respond type PINGREQ\n    * For PINGREQ should be used with no parameter.\n\nMQTT::respond type PINGRESP\n    * For PINGRESP should be used with no parameter.\n\nMQTT::respond type DISCONNECT\n    * For DISCONNECT should be used with no parameter.","examples":"#Enrich MQTT username with SSL client-certificate common name, reject unauthorized accesses:\nwhen CLIENT_ACCEPTED {\n    set cn \"\"\n}\n\nwhen CLIENTSSL_CLIENTCERT {\n    set cn [ lindex [ split [lindex [ split [X509::subject [SSL::cert 0]] \",\" ] 0 ] \"=\" ] 1 ]\n    log local0. \"Client Cert Common Name: $cn\"\n}\n\nwhen MQTT_CLIENT_INGRESS {\n    if {[MQTT::type] == \"CONNECT\"} {\n        if {$cn == \"\"} {\n            MQTT::drop\n            MQTT::respond type CONNACK return_code 5\n        } else {\n            set user [MQTT::username]\n            MQTT::username \"$cn:$user\"\n        }\n    }\n}","returnValue":"None."},
{"commandName":"MQTT::replace","description":"This command can be used to replace current MQTT message.\nThis command is valid for all MQTT message types:\n\n    CONNECT, CONNACK,\n    PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP,\n    SUBSCRIBE, SUBACK,\n    UNSUBSCRIBE, UNSUBACK,\n    PINGREQ, PINGRESP,\n    DISCONNECT\n\nSyntax\n\nMQTT::replace type CONNECT client_id <client-id>\n                   [keep_alive <time-in-seconds>] [clean_session (0 | 1)]\n                   [protocol_name <name-string>] [protocol_version <level-number>]\n                   [username <name-string>] [password <password-string>]\n                   [will_topic <topic-string>] [will_message <message-string>]\n                   [will_qos (0 | 1 |2)] [will_retain (0 | 1)]\n\n    * The client_id is required parameter.\n      keep_alive <time-in-seconds> must be smaller than 65536.\n      Default values for optional parameters are:\n        keep_alive          -: 60 seconds.\n        clean_session       -: 1\n        protocol_name       -: MQTT\n        protocol_version    -: 4\n        username            -: \"\"\n        password            -: \"\"\n        will_topic          -: \"\"\n        will_message        -: \"\"\n        will_qos            -: 0\n        will_retain         -: 0\n\nMQTT::replace type CONNACK return_code <return-code>\n                   [ session_present <session-present-flag> ]\n\n    * The <return-code> values must be set to one of the following:.\n            0 - Connection Accepted.\n            1 - Connection Refused, unacceptable protocol version.\n            2 - Connection Refused, identifier rejected.\n            3 - Connection Refused, Server unavailable.\n            4 - Connection Refused, bad username or password.\n            5 - Connection Refused, not authorized.\n      The <session-present-flag> can be set to 0 or 1. The default value is 0.\n\nMQTT::replace type PUBLISH topic <topic-name> payload <content>\n                   [{qos 0} | {qos (1 | 2) packet_id <packet-id-number>} ]\n                   [dup (0 | 1)]\n                   [retain (0 | 1)]\n\n    * For PUBLISH, the topic and payload are required parameters. If qos is 1 or 2, then packet_id must also be specified.\n      <packet-id-number> must be smaller than 65536.\n      Default values for optional parameters are:\n            qos         -: 0\n            dup         -: 0\n            retain      -: 0\n\nMQTT::replace type PUBACK  packet_id <packet-id-number>\nMQTT::replace type PUBREC  packet_id <packet-id-number>\nMQTT::replace type PUBREL  packet_id <packet-id-number>\nMQTT::replace type PUBCOMP packet_id <packet-id-number>\n    * For PUBACK, PUBREC, PUBREL, and PUBCOMP, packet_id is a required parameter. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n\nMQTT::replace type SUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For SUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536. <qos> can only be 0,1, or 2.\n\nMQTT::replace type SUBACK packet_id <packet-id-number> return_code_list {<return-code>}+\n    * For SUBACK, packet_id and return_code_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n      For return_code_list, each number in the list must be smaller than 256. Valid values are:\n      0     : Success - Maximum QoS 0.\n      1     : Success - Maximum QoS 1.\n      2     : Success - Maximum QoS 2.\n      128   : Failure\n      Other : Reserved for future use.\n\nMQTT::replace type UNSUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For UNSUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      Please note that <qos> values will be ignored. It is required to make format of topic_list same between SUBSCRIBE and UNSUBSCRIBE.\n      UNSUBSCRIBE does not need the qos.\n\nMQTT::replace type UNSUBACK packet_id <packet-id-number>\n    * For UNSUBACK, packet_id is required parameter.\n\nMQTT::replace type PINGREQ\n    * For PINGREQ should be used with no parameter.\n\nMQTT::replace type PINGRESP\n    * For PINGRESP should be used with no parameter.\n\nMQTT::replace type DISCONNECT\n    * For DISCONNECT should be used with no parameter.","examples":"#Example: Split SUBSCRIBE with multiple topics into individual SUBSCRIBE messages\nwhen MQTT_CLIENT_INGRESS {\n  set type [MQTT::type]\n  switch $type {\n     \"SUBSCRIBE\" {\n         set count [MQTT::topic count]\n         if { $count > 1 } {\n            set topiclist [MQTT::topic list]\n            set qoslist [list]\n            foreach topic $topiclist {\n               lappend qoslist [MQTT::topic qos $topic]\n            }\n            set i 0\n            foreach topic $topiclist {\n                if { $i == 0 } {\n                    MQTT::replace type SUBSCRIBE packet_id [MQTT::packet_id] $topic [lindex $qoslist $i]\n                } else {\n                    MQTT::insert after type SUBSCRIBE packet_id [expr { 1000 + $i}] $topic [lindex $qoslist $i]\n                }\n                set i [expr { $i + 1 }]\n            }\n         }\n     }\n  }\n}\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"SUBACK\" {\n         if {[MQTT::packet_id] > 1000} {\n             MQTT::drop\n         }\n      }\n   }\n}","returnValue":"None."},
{"commandName":"MQTT::insert","description":"This command can be used to insert an MQTT message before or after current message.\nThis command is valid for all MQTT message types:\n\n    CONNECT, CONNACK,\n    PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP,\n    SUBSCRIBE, SUBACK,\n    UNSUBSCRIBE, UNSUBACK,\n    PINGREQ, PINGRESP,\n    DISCONNECT\n\nSyntax\n\nMQTT::insert (before | after) type CONNECT client_id <client-id>\n                              [keep_alive <time-in-seconds>] [clean_session (0 | 1)]\n                              [protocol_name <name-string>] [protocol_version <level-number>]\n                              [username <name-string>] [password <password-string>]\n                              [will_topic <topic-string>] [will_message <message-string>]\n                              [will_qos (0 | 1 |2)] [will_retain (0 | 1)]\n    * The client_id is required parameter.\n      keep_alive <time-in-seconds> must be smaller than 65536.\n      Default values for optional parameters are:\n        keep_alive           -: 60 seconds.\n        clean_session       -: 1\n        protocol_name       -: MQTT\n        protocol_version    -: 4\n        username            -: \"\"\n        password            -: \"\"\n        will_topic          -: \"\"\n        will_message        -: \"\"\n        will_qos            -: 0\n        will_retain         -: 0\n\nMQTT::insert (before | after) type CONNACK return_code <return-code>\n                              [ session_present <session-present-flag> ]\n\n    * The <return-code> values must be set to one of the following:.\n            0 - Connection Accepted.\n            1 - Connection Refused, unacceptable protocol version.\n            2 - Connection Refused, identifier rejected.\n            3 - Connection Refused, Server unavailable.\n            4 - Connection Refused, bad username or password.\n            5 - Connection Refused, not authorized.\n      The <session-present-flag> can be set to 0 or 1. The default value is 0.\n\nMQTT::insert (before | after) type PUBLISH topic <topic-name> payload <content>\n                              [{qos 0} | {qos (1 | 2) packet_id <packet-id-number>} ]\n                              [dup (0 | 1)]\n                              [retain (0 | 1)]\n\n    * For PUBLISH, the topic and payload are required parameters. If qos is 1 or 2, then packet_id must also be specified.\n      <packet-id-number> must be smaller than 65536.\n      Default values for optional parameters are:\n            qos         -: 0\n            dup         -: 0\n            retain      -: 0\n\nMQTT::insert (before | after) type PUBACK  packet_id <packet-id-number>\nMQTT::insert (before | after) type PUBREC  packet_id <packet-id-number>\nMQTT::insert (before | after) type PUBREL  packet_id <packet-id-number>\nMQTT::insert (before | after) type PUBCOMP packet_id <packet-id-number>\n    * For PUBACK, PUBREC, PUBREL, and PUBCOMP, packet_id is a required parameter. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n\nMQTT::insert (before | after) type SUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For SUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536. <qos> can only be 0,1, or 2.\n\nMQTT::insert (before | after) type SUBACK packet_id <packet-id-number> return_code_list {<return-code>}+\n    * For SUBACK, packet_id and return_code_list are required parameters. No other parameter should be specified.\n      <packet-id-number> must be smaller than 65536.\n\nMQTT::insert (before | after) type UNSUBSCRIBE packet_id <packet-id-number> topic_list {<topic-name> <qos>}+\n    * For UNSUBSCRIBE, packet_id and topic_list are required parameters. No other parameter should be specified.\n      Please note that <qos> values will be ignored. It is required to make format of topic_list same between SUBSCRIBE and UNSUBSCRIBE.\n      UNSUBSCRIBE does not need the qos.\n\nMQTT::insert (before | after) type UNSUBACK packet_id <packet-id-number>\n    * For UNSUBACK, packet_id is required parameter.\n\nMQTT::insert (before | after) type PINGREQ\n    * For PINGREQ should be used with no parameter.\n\nMQTT::insert (before | after) type PINGRESP\n    * For PINGRESP should be used with no parameter.\n\nMQTT::insert (before | after) type DISCONNECT\n    * For DISCONNECT should be used with no parameter.","examples":"#Example: Auto subscribe for a topic\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"CONNECT\" {\n            MQTT::insert after type SUBSCRIBE packet_id 1001 topic_list \"/Mandatory/Topic\" 0\n       }\n    }\n}\n\nwhen MQTT_SERVER_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"SUBACK\" {\n          if { [MQTT::packet_id > 1000] } {\n             MQTT::drop\n          }\n       }\n    }\n}","returnValue":"None."},
{"commandName":"MQTT::enable","description":"This command enables MQTT parsing on a connection.\n\nSyntax\n\nMQTT::enable","examples":"#Example: Enable MQTT processing when server is connected\nwhen CLIENT_ACCEPTED {\n   MQTT::disable\n}\n\nwhen SERVER_CONNECTED {\n   MQTT::enable\n}","returnValue":"None."},
{"commandName":"MQTT::disable","description":"This command disables MQTT parsing on a connection.\n\nSyntax\n\nMQTT::disable","examples":"#Example: Enable MQTT processing when server is connected\nwhen CLIENT_ACCEPTED {\n   MQTT::disable\n}\n\nwhen SERVER_CONNECTED {\n   MQTT::enable\n}","returnValue":"None."},
{"commandName":"MQTT::collect","description":"Collects the specified amount of MQTT message payload data before triggering a MQTT_CLIENT_DATA or MQTT_SERVER_DATA event.\n\nWhen collecting data in a clientside event, the MQTT_CLIENT_DATA event will be triggered.\nWhen collecting data in a serverside event, the MQTT_SERVER_DATA event will be triggered.\n\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n\nThis command allows you to perform various operations on MQTT PUBLISH message like modify its contents.\nNOTE: Please make sure that MQTT PUBLISH message expects to receive a payload by using [MQTT::payload length].\nThis is to make sure that the payload length is not zero before calling this command.\n\n\nSyntax\n\nMQTT::collect [<collect_bytes>]\n\nMQTT::collect\n    Collect the entire payload of the MQTT message. To stop collecting\n    use MQTT::release command.\n\nMQTT::collect <collect_bytes>\n    Collect <collect_bytes> bytes of payload of the MQTT message.\n    If paylaod is smaller than <collect_bytes> collect entire payload.\n    The collected data can be accessed via the MQTT::payload command.\n    To stop collecting use MQTT::release command.","examples":"#Example: Prohibit PUBLISH payloads with blocked keywords defined in\n#blacklisted_keywords_datagroup in first 200 bytes\n#\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"PUBLISH\" {\n          if { [class exists  blacklisted_keywords_datagroup] } {\n             MQTT::collect 200\n          }\n       }\n    }\n}\n\nwhen MQTT_CLIENT_DATA {\n   set type [MQTT::type]\n   switch $type {\n       \"PUBLISH\" {\n          set payload [MQTT::payload]\n          MQTT::release\n          set found [class match $payload contains blacklisted_keywords_datagroup]\n          if { $found != \"\" } {\n              MQTT::disconnect\n          }\n       }\n   }\n}","returnValue":""},
{"commandName":"MQTT::release","description":"Releases the payload data collected via MQTT::collect iRule command for further processing.\n\nThis command is valid only when MQTT::collect has been called.\n\nSyntax\n\nMQTT::release\n     Releases the payload data collected via MQTT::collect for further processing.","examples":"#Example: Prohibit PUBLISH payloads with blocked keywords defined in\n#blacklisted_keywords_datagroup in first 200 bytes\n#\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"PUBLISH\" {\n          if { [class exists  blacklisted_keywords_datagroup] } {\n             MQTT::collect 200\n          }\n       }\n    }\n}\n\nwhen MQTT_CLIENT_DATA {\n   set type [MQTT::type]\n   switch $type {\n       \"PUBLISH\" {\n          set payload [MQTT::payload]\n          MQTT::release\n          set found [class match $payload contains blacklisted_keywords_datagroup]\n          if { $found != \"\" } {\n              MQTT::disconnect\n          }\n       }\n   }\n}","returnValue":""},
{"commandName":"MQTT::disconnect","description":"This command disconnects the MQTT connection.\n\nSyntax\n\nMQTT::disconnect","examples":"#Example: Prohibit PUBLISH payloads with blocked keywords defined in\n#blacklisted_keywords_datagroup in first 200 bytes\n#\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"PUBLISH\" {\n          if { [class exists  blacklisted_keywords_datagroup] } {\n             MQTT::collect 200\n          }\n       }\n    }\n}\n\nwhen MQTT_CLIENT_DATA {\n   set type [MQTT::type]\n   switch $type {\n       \"PUBLISH\" {\n          set payload [MQTT::payload]\n          MQTT::release\n          set found [class match $payload contains blacklisted_keywords_datagroup]\n          if { $found != \"\" } {\n              MQTT::disconnect\n          }\n       }\n   }\n}","returnValue":""},
{"commandName":"MQTT::type","description":"This command can be used to get type of MQTT message.\nThis command is valid for all MQTT message types:\n\n    CONNECT, CONNACK,\n    PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP,\n    SUBSCRIBE, SUBACK,\n    UNSUBSCRIBE, UNSUBACK,\n    PINGREQ, PINGRESP,\n    DISCONNECT\n\nSyntax\n\nMQTT::type","examples":"# Typical usage pattern...\n#\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"CONNECT\" {\n         # Do connect processing\n      }\n      \"SUBSCRIBE\" {\n         # Do subscribe processing\n      }\n      \"PUBLISH\" {\n         # Do publish processing\n      }\n   }\n}","returnValue":"A string representation of MQTT message types:\n\n    'CONNECT', 'CONNACK',\n    'PUBLISH', 'PUBACK', 'PUBREC', 'PUBREL', 'PUBCOMP',\n    'SUBSCRIBE', 'SUBACK',\n    'UNSUBSCRIBE', 'UNSUBACK',\n    'PINGREQ', 'PINGRESP',\n    'DISCONNECT'"},
{"commandName":"MQTT::length","description":"This command can be used to get length of MQTT message.\nThis command is valid for all MQTT message types:\n\n    CONNECT, CONNACK,\n    PUBLISH, PUBACK, PUBREC, PUBREL, PUBCOMP,\n    SUBSCRIBE, SUBACK,\n    UNSUBSCRIBE, UNSUBACK,\n    PINGREQ, PINGRESP,\n    DISCONNECT\n\n\nSyntax\n\nMQTT::length","examples":"# Drop connections with messages that exceed an administrative max\n#\nwhen MQTT_CLIENT_INGRESS {\n  set length [MQTT::length]\n  if { $length > 65536 } {\n     MQTT::disconnect\n  }\n}","returnValue":"This command returns the length of MQTT message."},
{"commandName":"MQTT::packet_id","description":"This command can be used to get or set packet-id field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH (if QoS > 0)\n    PUBACK\n    PUBREC\n    PUBREL\n    PUBCOMP\n    SUBSCRIBE\n    SUBACK\n    UNSUBSCRIBE\n    UNSUBACK\n    PINGREQ\n    PINGRESP\n    DISCONNECT\n\nSyntax\n\nMQTT::packet_id [<packet_id_number>]\n\nMQTT::packet_id\n    * Returns the packet-id of the MQTT message.\n\nMQTT::packet_id <packet_id_number>\n    * Replaces the packet-id of the MQTT message with <packet_id_number>. The value supplied must be less than 65536.","examples":"#Example: Split SUBSCRIBE with multiple topics into separate SUBSCRIBE messages\nwhen MQTT_CLIENT_INGRESS {\n  set type [MQTT::type]\n  switch $type {\n     \"SUBSCRIBE\" {\n         set count [MQTT::topic count]\n         if { $count > 1 } {\n            set topiclist [MQTT::topic list]\n            set qoslist [list]\n            foreach topic $topiclist {\n               lappend qoslist [MQTT::topic qos $topic]\n            }\n            set packetid [MQTT::packet_id]\n            set i 0\n            foreach topic $topiclist {\n                if { $i == 0 } {\n                    MQTT::replace type SUBSCRIBE packet_id $packetid $topic [lindex $qoslist $i]\n                    table add -subtable \"outstanding_packetid_table\" \"[client_addr]_[client_port]_${packetid}\" $count\n                } else {\n                    MQTT::insert after type SUBSCRIBE packet_id [expr { ($packetid + 1000 + $i)%65535}] $topic [lindex $qoslist $i]\n                }\n                set i [expr { $i + 1 }]\n            }\n         }\n     }\n  }\n}\n\nwhen SERVER_CONNECTED {\n   set suback_count 0\n   set rclist [list]\n}\n\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"SUBACK\" {\n         set packetid [MQTT::packet_id]\n         if { $suback_count == 0 } {\n             set count [table lookup -subtable \"outstanding_packetid_table\" \"[client_addr]_[client_port]_${packetid}\"]\n             if { $count != \"\" } {\n                set suback_count $count\n             } elseif { [llength $rclist] > 0 } {\n                MQTT::replace type SUBACK return_code_list $rclist\n                set rclist [list]\n             }\n         }\n         if { $suback_count > 0 } {\n             set suback_count [expr { $suback_count - 1}]\n             lappend rclist [MQTT::return_code_list]\n             MQTT::drop\n         }\n      }\n   }\n}","returnValue":"When called without an argument, this command returns the packet-id of MQTT message"},
{"commandName":"MQTT::qos","description":"This command can be used to get or set qos field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n\nSyntax\n\nMQTT::qos [ 0 | 1 | 2 ]\n\nMQTT::qos\n    * Get the qos field of MQTT PUBLISH message\n\nMQTT::qos 0\n    * Set the qos of MQTT PUBLISH message to at most once delivery.\n      When QoS is changed to 0 from 1 or 2, the packet-id field\n      of the PUBLISH message will be removed. Call MQTT::packet_id before\n      calling MQTT::qos 0 to save original packet-id if needed.\n\nMQTT::qos 1\n    * Set the qos of MQTT PUBLISH message to at least once delivery.\n      When changing from 0, this call must be followed by\n      MQTT::packet_id <packet-id> to maintain MQTT protocol correctness.\n      This is because packet-id is not present in PUBLISH messages at QoS 0,\n      while it is required at levels 1 and 2.\n\nMQTT::qos 2\n    * Set the qos field of MQTT PUBLISH message to exactly once delivery\n      When changing from 0, this call must be followed by\n      MQTT::packet_id <packet-id> to maintain MQTT protocol correctness.\n      This is because packet-id is not present in PUBLISH messages at QoS 0,\n      while it is required at levels 1 and 2.","examples":"#Downgrading QoS to 0:\n\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"PUBLISH\" {\n            set in_qos [MQTT::qos]\n            if { $in_qos > 0 } {\n                set pktid [MQTT::packet_id]\n            }\n            MQTT::dup 0\n            MQTT::qos 0\n            if { $in_qos == 1 } {\n                MQTT::respond type PUBACK packet_id $pktid\n            } elseif { $in_qos == 2 } {\n                MQTT::respond type PUBREC packet_id $pktid\n            }\n        }\n        \"PUBREL\" {\n            set pktid [MQTT::packet_id]\n            MQTT::drop\n            MQTT::respond type PUBCOMP packet_id $pktid\n        }\n    }\n}\n\n#Changing QoS to 1:\n\nwhen CLIENT_ACCEPTED {\n   set self_pktid 1\n}\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"PUBLISH\" {\n            set in_qos [MQTT::qos]\n            MQTT::qos 1\n            if { $in_qos == 0 } {\n                MQTT::packet_id $self_pktid\n                set self_pktid [$self_pktid + 1]\n            }\n        }\n        \"PUBREL\" {\n            set pktid [MQTT::packet_id]\n            MQTT::drop\n            MQTT::respond type PUBCOMP packet_id $pktid\n        }\n    }\n}\n\nwhen MQTT_SERVER_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"PUBACK\" {\n           if {$in_qos == 0} {\n               MQTT::drop\n           } elseif {$in_qos == 2} {\n               set pktid [MQTT::packet_id]\n               MQTT::replace type PUBREC packet_id $pktid\n           }\n        }\n    }\n}","returnValue":"When called without an argument, this command returns the qos of MQTT message"},
{"commandName":"MQTT::dup","description":"This command can be used to get or set duplicate flag of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n\nSyntax\n\nMQTT::dup [ 0 | 1 ]\n\nMQTT::dup\n    * Get the duplicate flag of MQTT PUBLISH message.\n\nMQTT::dup 0\n    * reset the duplicate flag of MQTT PUBLISH message. This will convert the\n      message to as if it was the first occasion that client or server has\n      attempted to  send this MQTT PUBLISH message.\n\nMQTT::dup 1\n    * Set the duplicate flag of MQTT PUBLISH message. This will convert the message\n      to as if the message was a redelivery of an earlier attempt to send the message.","examples":"#Downgrading QoS to 0:\n\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"PUBLISH\" {\n            set in_qos [MQTT::qos]\n            if { $in_qos > 0 } {\n                set pktid [MQTT::packet_id]\n            }\n            MQTT::dup 0\n            MQTT::qos 0\n            if { $in_qos == 1 } {\n                MQTT::respond type PUBACK packet_id $pktid\n            } elseif { $in_qos == 2 } {\n                MQTT::respond type PUBREC packet_id $pktid\n            }\n        }\n        \"PUBREL\" {\n            set pktid [MQTT::packet_id]\n            MQTT::drop\n            MQTT::respond type PUBCOMP packet_id $pktid\n        }\n    }\n}","returnValue":"When called without an argument, this command returns the duplicate flag of MQTT message."},
{"commandName":"MQTT::retain","description":"This command can be used to get or set retain flag of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n\nSyntax\n\nMQTT::retain [ 0 | 1 ]\n\nMQTT::retain\n    * Get the retain flag of MQTT PUBLISH message.\n\nMQTT::retain 0\n    * Reset the retain flag of MQTT PUBLISH message.\n\nMQTT::retain 1\n    * Set the retain flag of MQTT PUBLISH message.","examples":"# Convert PUBLISH for topics in a retain_datagroup to retain messages\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"PUBLISH\" {\n          if {[MQTT::retain] eq 0} {\n              if { [class exists retain_datagroup] } {\n                  if {[class match [MQTT::topic] starts_with retain_datagroup]} {\n                     MQTT::retain 1\n                  }\n              }\n          }\n      }\n   }\n}","returnValue":"When called without an argument, this command returns the retain flag of MQTT PUBLISH message."},
{"commandName":"MQTT::protocol_name","description":"This command can be used to get or set protocol name of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::protocol_name [ <name_string> ]\n\nMQTT::protocol_name\n    * Get the protocol name of MQTT CONNECT message.\n\nMQTT::protocol_name <name_string>\n    * Set the protocol name of MQTT CONNECT message.\n      To set to MQTT 3.1.1 use 'MQTT'.\n      To set to MQTT 3.1 use 'MQIsdp', capitalized as shown.","examples":"# Upgrade protocol from 3.1 to 3.1.1\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNECT\" {\n          if {[MQTT::protocol_version] == 3 } {\n             MQTT::protocol_version 4\n             MQTT::protocol_name \"MQTT\"\n          }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the protocol name of MQTT CONNECT message"},
{"commandName":"MQTT::protocol_version","description":"This command can be used to get or set protocol revision level of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::protocol_version [ <revision_number> ]\n\nMQTT::protocol_version\n    * Get the protocol revision level of MQTT CONNECT message.\n\nMQTT::protocol_version <revision_number>\n    * Set the protocol revision level of MQTT CONNECT message.\n      To set to MQTT 3.1.1 specify 4. (MQTT::protocol_version 4).\n      To set to MQTT 3.1 specify 3. (MQTT::protocol_version 3).","examples":"# Upgrade protocol from 3.1 to 3.1.1\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNECT\" {\n          if {[MQTT::protocol_version] == 3 } {\n             MQTT::protocol_version 4\n             MQTT::protocol_name \"MQTT\"\n          }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the protocol revision of MQTT CONNECT message"},
{"commandName":"MQTT::client_id","description":"This command can be used to get or set client identifier of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::client_id [ <client_identifier> ]\n\nMQTT::client_id\n    * Get the client identifier of MQTT CONNECT message.\n\nMQTT::client_id <client_identifier>\n    * Set the client identifier of MQTT CONNECT message to specified string.","examples":"# Block connections from clientid in the blacklist_clientid_datagroup\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNECT\" {\n           set cid [MQTT::client_id]\n           if { [class exists blacklist_clientid_datagroup] } {\n               if {[class match  $cid equals blacklist_clientid_datagroup] != \"\"} {\n                   MQTT::drop\n                   MQTT::respond type CONNACK return_code 2\n                   MQTT::disconnect\n               }\n           }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the client identifier of MQTT message."},
{"commandName":"MQTT::username","description":"This command can be used to get or set username field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::username [ <user_name> ]\n\nMQTT::username\n    * Get the user-name field of MQTT CONNECT message.\n\nMQTT::username <user_name>\n    * Set the user-name field of MQTT CONNECT message to specified string.","examples":"#Enrich MQTT username with SSL client-certificate common name, reject unauthorized accesses:\nwhen CLIENT_ACCEPTED {\n    set cn \"\"\n}\n\nwhen CLIENTSSL_CLIENTCERT {\n    set cn [ lindex [ split [lindex [ split [X509::subject [SSL::cert 0]] \",\" ] 0 ] \"=\" ] 1 ]\n    log local0. \"Client Cert Common Name: $cn\"\n}\n\nwhen MQTT_CLIENT_INGRESS {\n    if {[MQTT::type] == \"CONNECT\"} {\n        if {$cn == \"\"} {\n            MQTT::drop\n            MQTT::respond type CONNACK return_code 5\n        } else {\n            set user [MQTT::username]\n            MQTT::username \"$cn:$user\"\n        }\n    }\n}","returnValue":"When called without an argument, this command returns the user-name field of MQTT CONNECT message."},
{"commandName":"MQTT::password","description":"This command can be used to get or set password field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::password [ <password> ]\n\nMQTT::password\n    * Get the password field of MQTT CONNECT message.\n\nMQTT::password <password>\n    * Set the password field of MQTT CONNECT message to specified string.","examples":"# Reject connections with no password\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"CONNECT\" {\n            if {[MQTT::username] == \"\" } {\n               MQTT::respond type CONNACK return_code 4\n               MQTT::disconnect\n            }\n        }\n    }\n}","returnValue":"When called without an argument, this command returns the password field of MQTT CONNECT message."},
{"commandName":"MQTT::keep_alive","description":"This command can be used to get or set keep_alive field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::keep_alive [ <keepalive_seconds> ]\n\nMQTT::keep_alive\n    * Get the keep_alive field of MQTT CONNECT message.\n\nMQTT::keep_alive <keepalive_seconds>\n    * Set the keep_alive field of MQTT CONNECT message to specified number.\n      The number must be smaller than 65536.","examples":"# Increase keep-alive to at least 60 seconds\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNECT\"  {\n           if { [MQTT::keep_alive] < 60} {\n              MQTT::keep_alive 60\n           }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the keep_alive field of MQTT CONNECT message."},
{"commandName":"MQTT::clean_session","description":"This command can be used to get or set clean_session flag of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::clean_session [ 0 | 1 ]\n\nMQTT::clean_session\n    * Get the clean_session flag of MQTT CONNECT message.\n\nMQTT::clean_session 0\n    * Clear the clean_session flag of MQTT CONNECT message.\n\nMQTT::clean_session 1\n    * Set the clean_session flag of MQTT CONNECT message.","examples":"# Convert non-clean-session connections to clean-session connections\nwhen MQTT_CLIENT_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNECT\" {\n           if { [MQTT::clean_session] == 1} {\n              MQTT::clean_session 0\n           }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the clean_session flag of MQTT CONNECT message."},
{"commandName":"MQTT::session_present","description":"This command can be used to get or set session_present flag of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNACK\n\nSyntax\n\nMQTT::session_present [ 0 | 1 ]\n\nMQTT::session_present\n    * Get the session_present flag of MQTT CONNACK message.\n\nMQTT::session_present 0\n    * Clear the session_present flag of MQTT CONNACK message.\n\nMQTT::session_present 1\n    * Set the session_present flag of MQTT CONNACK message.","examples":"# Prevent session_present from being 1\nwhen MQTT_SERVER_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"CONNACK\" {\n            if { [MQTT::session_present] == 1 } {\n                MQTT::session_present 0\n            }\n        }\n    }\n}","returnValue":"When called without an argument, this command returns the session_present flag of MQTT CONNACK message."},
{"commandName":"MQTT::return_code","description":"This command can be used to get or set return-code field of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNACK\n\nSyntax\n\nMQTT::return_code [ <return_code> ]\n\nMQTT::return_code\n    * Get the return-code field of MQTT CONNACK message.\n\nMQTT::return_code <return_code>\n    * Set the return-code field of MQTT CONNACK message to specified number.\n      The number must be smaller than 256.\n      0     : Connection Accepted.\n      1     : Connection Refused. Protocol level not supported.\n      2     : Connection Refused. The client-identifier is not allowed by the server.\n      3     : Connection Refused. The MQTT service is not available.\n      4     : Connection Refused. The data in the username or password is malformed.\n      5     : Connection Refused. The client is not authorized to connect.\n      6-255 : Reserved for future use.","examples":"# For security reasons convert all refused reasons to 5\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n       \"CONNACK\" {\n          if { [MQTT::return_code] != 0 } {\n             MQTT::return_code 5\n          }\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the return-code field of MQTT CONNACK message."},
{"commandName":"MQTT::return_code_list","description":"This command can be used to get return-code-list of MQTT message.\nNote that this command does not support a 'set' operation.\nIn order to change the retun-code-list please use 'MQTT::replace type SUBACK'.\nThis command is valid only for following MQTT message types:\n\n    SUBACK\n\nSyntax\n\nMQTT::return_code_list\n\n    * Get the return-code-list of MQTT SUBACK message.\n      Each number in the list should be smaller than 256. Valid values are:\n      0     : Success - Maximum QoS 0.\n      1     : Success - Maximum QoS 1.\n      2     : Success - Maximum QoS 2.\n      128   : Failure\n      Other : Reserved for future use.","examples":"#Example: Split SUBSCRIBE with multiple topics into separate SUBSCRIBE messages\nwhen MQTT_CLIENT_INGRESS {\n  set type [MQTT::type]\n  switch $type {\n     \"SUBSCRIBE\" {\n         set count [MQTT::topic count]\n         if { $count > 1 } {\n            set topiclist [MQTT::topic list]\n            set qoslist [list]\n            foreach topic $topiclist {\n               lappend qoslist [MQTT::topic qos $topic]\n            }\n            set packetid [MQTT::packet_id]\n            set i 0\n            foreach topic $topiclist {\n                if { $i == 0 } {\n                    MQTT::replace type SUBSCRIBE packet_id $packetid $topic [lindex $qoslist $i]\n                    table add -subtable \"outstanding_packetid_table\" \"[client_addr]_[client_port]_${packetid}\" $count\n                } else {\n                    MQTT::insert after type SUBSCRIBE packet_id [expr { ($packetid + 1000 + $i)%65535}] $topic [lindex $qoslist $i]\n                }\n                set i [expr { $i + 1 }]\n            }\n         }\n     }\n  }\n}\n\nwhen SERVER_CONNECTED {\n   set suback_count 0\n   set rclist [list]\n}\n\nwhen MQTT_SERVER_INGRESS {\n   set type [MQTT::type]\n   switch $type {\n      \"SUBACK\" {\n         set packetid [MQTT::packet_id]\n         if { $suback_count == 0 } {\n             set count [table lookup -subtable \"outstanding_packetid_table\" \"[client_addr]_[client_port]_${packetid}\"]\n             if { $count != \"\" } {\n                set suback_count $count\n             } elseif { [llength $rclist] > 0 } {\n                MQTT::replace type SUBACK return_code_list $rclist\n                set rclist [list]\n             }\n         }\n         if { $suback_count > 0 } {\n             set suback_count [expr { $suback_count - 1}]\n             lappend rclist [MQTT::return_code_list]\n             MQTT::drop\n         }\n      }\n   }\n}","returnValue":"When called without an argument, this command returns the return-code-list of MQTT SUBACK message."},
{"commandName":"MQTT::drop","description":"This command can be used to drop the current MQTT message. The MQTT message will not be forwarded to its destination.\nThis command is valid for all MQTT message types.\n\n\nSyntax\n\nMQTT::drop","examples":"#Enrich MQTT username with SSL client-certificate common name, reject unauthorized accesses:\nwhen CLIENT_ACCEPTED {\n    set cn \"\"\n}\n\nwhen CLIENTSSL_CLIENTCERT {\n    set cn [ lindex [ split [lindex [ split [X509::subject [SSL::cert 0]] \",\" ] 0 ] \"=\" ] 1 ]\n    log local0. \"Client Cert Common Name: $cn\"\n}\n\nwhen MQTT_CLIENT_INGRESS {\n    if {[MQTT::type] == \"CONNECT\"} {\n        if {$cn == \"\"} {\n            MQTT::drop\n            MQTT::respond type CONNACK return_code 5\n        } else {\n            set user [MQTT::username]\n            MQTT::username \"$cn:$user\"\n        }\n    }\n}","returnValue":"None."},
{"commandName":"MQTT::will","description":"This command can be used to get or set will-topic, will-message, will-qos, and will-retain fields of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    CONNECT\n\nSyntax\n\nMQTT::will (topic [<topic>]) | (message [<message>]) | (qos [<qos>]) | (retain [<retain>])\n\nMQTT::will topic\n    * Get the will-topic field of MQTT CONNECT message.\n\nMQTT::will topic <will-topic>\n    * Set the will-topic field of MQTT CONNECT message to specified string.\n\nMQTT::will message\n    * Get the will-message field of MQTT CONNECT message.\n\nMQTT::will message <will-message>\n    * Set the will-message field of MQTT CONNECT message to specified string.\n\nMQTT::will qos\n    * Get the will-qos field of MQTT CONNECT message.\n\nMQTT::will qos <will-qos>\n    * Set the will-qos field of MQTT CONNECT message to specified number.\n      <will-qos> can only be 0, 1, or 2.\n\nMQTT::will retain\n    * Get the will-retain field of MQTT CONNECT message.\n\nMQTT::will retain <will-retain-flag>\n    * Set the will-retain field of MQTT CONNECT message to specified number.\n      <will-retain-flag> can only be 0 or 1.","examples":"# Enforce a mandatary default will message, if will is not present in connect\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n        \"CONNECT\" {\n            if { [MQTT::will topic] == \"\" } {\n                MQTT::will topic \"/bigip/default/will/[MQTT::username]/[MQTT::client_id]/[client_addr]\"\n                MQTT::will message \"client disconnected without sending DISCONNECT message\"\n                MQTT::will qos 0\n                MQTT::will retain 0\n            }\n        }\n    }\n}","returnValue":"When called without an argument, each of the sub-commands return the will-topic, will-message, will-qos, or will-retain field of MQTT CONNECT message."},
{"commandName":"MQTT::topic","description":"This command can be used to manipulate topic(s) of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n    SUBSCRIBE\n    UNSUBSCRIBE\n\nSyntax\n\nMQTT::topic [ replace <topic-name> | count | list | index <index-number> |\n              add <topic-name> [<qos>] | delete <topic-name> ]\n\nMQTT::topic\n    * Get the topic-name of MQTT PUBLISH message. Or the first topic of a SUBSCRIBE or UNSUBSCRIBE message.\n\nMQTT::topic replace <topic-name>\n    * Set the topic-name of MQTT PUBLISH message to specified string.\n      This command is valid only for PUBLISH messages.\n\nMQTT::topic count\n    * Get the number of topics in MQTT SUBSCRIBE and UNSUBSCRIBE messages.\n\nMQTT::topic list\n    * Get the list of topics in MQTT SUBSCRIBE and UNSUBSCRIBE messages.\n\nMQTT::topic index <index-number>\n    * Get the topics at index <index-number> in the list of topics in MQTT SUBSCRIBE and UNSUBSCRIBE messages.\n\nMQTT::topic qos <topic-name>\n    * This command is valid for SUBSCRIBE messages only. It returns the QoS value of the given <topic-name>.\n\nMQTT::topic add <topic-name> [<qos>]\n    * For SUBSCRIBE messages, add the specified <topic-name> and <qos> to the end of list of topics.\n      <qos> can only be 0,1, or 2. If not specified QoS 0 will be used.\n      For UNSUBSCRIBE messages, add the specified <topic-name> to the end of list of topics.\n      UNSUBSCRIBE messages do not need QoS. If supplied, it will be ignored.\n\nMQTT::topic delete <topic-name>\n    * Delete the specified <topic-name> and its qos from the topics in MQTT SUBSCRIBE and UNSUBSCRIBE messages.","examples":"#Automatically assign a subscription to the client for topic \"$SYS/broker/alerts/critical\":\nwhen MQTT_CLIENT_INGRESS {\n    set cmtype [MQTT::type]\n    if { $cmtype == \"SUBSCRIBE\" } {\n        set topic_count [MQTT::topic count]\n        set mid [MQTT::packet_id]\n        table add -subtable \"packetid_count_table\" \"[client_addr]_[client_port]_${mid}\" $topic_count\n        MQTT::topic add \"$SYS/broker/alerts/critical\" 0\n    }\n}\n\nwhen MQTT_SERVER_INGRESS {\n    set smtype [MQTT::type]\n    if {$smtype == \"SUBACK\"} {\n       set mid [MQTT::packet_id]\n       set tc [table lookup -subtable \"packetid_count_table\" \"[client_addr]_[client_port]_${mid}\"]\n       set return_codes [MQTT::return_code_list]\n       set return_codes [lreplace $return_codes $tc $tc]\n       MQTT::replace type SUBACK packet_id $mid return_code_list $return_codes\n    }\n}","returnValue":"When called without an argument, this command returns the topic-name of MQTT PUBLISH message,\nor the topic-name of the first topic of MQTT SUBSCRIBE and UNSUBSCRIBE messages."},
{"commandName":"MQTT::payload","description":"This command can be used to manipulate payload of MQTT message.\nThis command is valid only for following MQTT message types:\n\n    PUBLISH\n\nSyntax\n\nMQTT::payload [ length | replace <content> | prepend <content> | append <content> ]\n\nMQTT::payload\n    * Returns the collected payload obtained as a result of a prior call to MQTT::collect.\n      This command should be called without an argument only from MQTT_CLIENT_DATA or MQTT_SERVER_DATA events.\n\nMQTT::payload length\n    * Returns the length of payload of MQTT PUBLISH message.\n      Make sure to call this method and call MQTT::collect only when payload length is not zero.\n\nMQTT::payload replace <content>\n    * Replace the entire payload of the MQTT PUBLISH message with specified <content>.\n\nMQTT::payload prepend <content>\n    * Add the specified <content> to the beginning of the payload of MQTT PUBLISH message.\n\nMQTT::payload append <content>\n    * Add the specified <content> to the end of the collected payload of MQTT PUBLISH message.\n      For this command to work, MQTT::collect must be called prior to calling this.\n      This command should be called only from MQTT_CLIENT_DATA or MQTT_SERVER_DATA events.\n      Please note that in order to append the <content> at the end of payload, the MQTT::collect\n      must collect entire payload. If collect is partial, this command will append <content> to\n      the end of the data collected at the time this command is invoked. This can happen when\n      MQTT::collect is called with a length smaller than the payload length as the argument.","examples":"#Example: Redirect PUBLISH that has payloads with blocked keywords defined in\n#blacklisted_keywords_datagroup in first 200 bytes. Prepend a admin message in\n#the payload.\n#\nwhen MQTT_CLIENT_INGRESS {\n    set type [MQTT::type]\n    switch $type {\n       \"PUBLISH\" {\n          if { [class exists  blacklisted_keywords_datagroup] } {\n             MQTT::collect 200\n          }\n       }\n    }\n}\n\nwhen MQTT_CLIENT_DATA {\n   set type [MQTT::type]\n   switch $type {\n       \"PUBLISH\" {\n          set payload [MQTT::payload]\n          set found [class match $payload contains blacklisted_keywords_datagroup]\n          if { $found != \"\" } {\n             set topic [MQTT::topic]\n             MQTT::topic \"/bigip/quarantined/$topic\"\n             MQTT::payload prepend \"!!!!!! QUARANTINED Message !!!!!!\"\n          }\n          MQTT::release\n       }\n   }\n}","returnValue":"When called without an argument, this command returns the collected payload of MQTT PUBLISH message."},
{"commandName":"MR::protocol","description":"returns generic, sip or diameter","examples":"when MR_INGRESS {\n    log local0. \"[MR::protocol] router instance [MR::instance]\"\n}","returnValue":"returns generic, sip or diameter"},
{"commandName":"MR::instance","description":"returns the name of the current mr_router instance","examples":"when MR_INGRESS {\n    log local0. \"[MR::protocol] router instance [MR::instance]\"\n}","returnValue":"returns the name of the current mr_router instance"},
{"commandName":"MR::flow_id","description":"Returns a unique identifier for the current connection. This identifier can be used to generate the lasthop and nexthop of a message.","examples":"when MR_INGRESS {\n    set orig_flowid [MR::flow_id]\n    MR::store orig_flowid\n}\nwhen MR_EGRESS {\n    MR::restore orig_flowid\n    log local0. \"message from $orig_flowid to [MR::flow_id]\"\n}","returnValue":"Returns a unique identifier for the current connection."},
{"commandName":"MR::transport","description":"Returns the name and type (virtual or config) of the transport used to configure the current connection. These values can be used to generate routes or to set the route of a message.","examples":"when MR_EGRESS {\n    log local0. \"sending message via [MR::transport]\"\n}","returnValue":"Returns the name and type (virtual or config) of the transport used to configure the current connection."},
{"commandName":"MR::connection_instance","description":"returns the connection instance number of the current connection and the number of\nconnections as configured in the peer object used to create the connection.\nThe return will be formated as \"<instance> of <num_connections>\".\nFor incoming connections, it will return \"0 of 1\".","examples":"when SERVER_CONNECTED {\n    log local0. \"[MR::connection_instance] [MR::connection_mode]\"\n}","returnValue":"returns the connection instance number and the number of connections formatted\nas \"<instance> of <num_connections>\"."},
{"commandName":"MR::connection_mode","description":"returns the connection mode of the current connection and the number of\nas configured in the peer object used to create the connection. Valid\nconnection modes as \"per-peer\", \"per-blade\", \"per-tmm\" or \"per-client\".\nFor incoming connections, it will return \"per-peer\".","examples":"when SERVER_CONNECTED {\n    log local0. \"[MR::connection_instance] [MR::connection_mode]\"\n}","returnValue":"returns the connection mode"},
{"commandName":"MR::store","description":"The MR::store command stores a tcl variable with the mr_message object. This variable will be delivered with the message to the egress connflow. Adding variables does not effect the content of the message.","examples":"when MR_INGRESS {\n    set client_addr [IP::remote_addr]:[TCP::remote_port]\"\n    MR::store client_addr\n}\nwhen MR_EGRESS {\n    MR::restore client_addr\n}","returnValue":""},
{"commandName":"MR::restore","description":"The MR::restore command returns the stored variables to the current context tcl variable store. If no name is provided, it will add all stored variables.","examples":"when MR_INGRESS {\n    set client_addr [IP::remote_addr]:[TCP::remote_port]\"\n    MR::store client_addr\n}\nwhen MR_EGRESS {\n    MR::restore client_addr\n}","returnValue":""},
{"commandName":"MR::equivalent_transport","description":"Gets or sets the transport that is usable as an equivalent transport. The equivalent transport may be used as an alternate when selecting a subsequent connection to the device the current connections communicates with.\n        \nGets the transport that is usable as an equivalent transport. The equivalent transport may be used as an alternate when selecting a subsequent connection to the device the current connections communicates with.\n            \nResets the transport that is usable as an equivalent transport. The equivalent transport may be used as an alternate when selecting a subsequent connection to the device the current connections communicates with.\n            \nGets the transport that is usable as an equivalent transport. The equivalent transport may be used as an alternate when selecting a subsequent connection to the device the current connections communicates with.","examples":"when CLIENT_ACCEPTED {\n    MR::equivalent_transport config /Common/inbound_tc\n}","returnValue":"Returns the current equivalent transport. This will contain the transport type and transport name. For example: 'config /Common/inbound_tc'."},
{"commandName":"MR::message","description":"Returns the contents of the route stored in the message.\n            \nClear any route already set in the message.\n            \nInstructs the route table to route the message to the provided peer or list of peers and a peer-selection-mode. This form of the MR::message route command takes the names of configured peers or dynamic peers created via the MR::peer command.\n            \nInstructs the route table to route the message to the provided peer or list of peers. This form of the MR::message route command takes the names of configured peers or dynamic peers created via the MR::peer command.\n            \nInstructs the route table to route the message to the provided host or pool using the specified virtual server or transport config for creating the outgoing connection. If both a transport config and virtual server are listed, the transport-config will be used for creating a new outgoing connection, but a connection created with either transport will be usable for connection reuse.\n            \nGets the hosts that this message has been routed towards.\n            \nClear any attempted hosts already set in the message.\n            \nSets the attempted hosts list. If set before routing the message (during MR_INGRESS or MR_EGRESS) a host will be selected from the pool that has not already been attempted.\n            \nDrops the current message\n            \nReturns the number of attempts to route this message that have occurred.\n            \nReturns the status of the routing operation (valid only at MR_EGRESS or MR_FAILED). Possible values are:\n    \"unprocessed\"\n    \"route found\"\n    \"no route found\"\n    \"dropped\"\n    \"queue_full\"\n    \"no connection\"\n    \"connection closing\"\n    \"internal error\"\n    \"persist key in use\"\n    \"standby dropped\"\n            \nReturns the transport type, transport name and IP and port of the originator of the message.\n            \nReturns the message's lasthop (details of the connection that originated the message).\n            \nClears the nexthop already set in the message.\n            \nReturns the nextop nexthop (details of the connection the message is to be forwarded to). If the new_nexthop parameter is present, a nexthop may be set for the message.","examples":"when MR_INGRESS {\n    if {[GENERICMESSAGE::message is_request] != 0} {\n        MR::message route config tcp_tc host 10.10.10.34:1234\n    }\n}\nwhen MR_EGRESS {\n    if {[GENERICMESSAGE::message is_request] != 0} {\n        set orig_lasthop [MR::message lasthop]\n    } else {\n        MR::message nexthop \"$orig_lasthop\"\n    }\n}","returnValue":""},
{"commandName":"MR::peer","description":"The MR::peer command defines a peer to use for routing a message to. The peer may either refer to a named pool or a tuple (IP address, port and route domain iD). When creating a connection to a peer, the parameters of either a virtual server or a transport config object will be used. The peer object will only exist in the current connections connflow. When adding a route (via MR::route add), it will first look for a locally created peer object then for a peer object from the configuration. Once the current connection closes, the local peer object will go away.","examples":"when CLIENT_ACCEPTED {\n    MR::peer self_peer config tc1 host \"[IP::remote_addr]:[TCP::remote_port]\"\n    GENERICMESSAGE::route add dest \"[IP::remote_addr]\" peer self_peer\n}","returnValue":""},
{"commandName":"MR::prime","description":"The MR::prime command instructs the Message Routing Framework to establish an outgoing connection to a specified host or pool if one does not exist. The setting of the specified virtual or transport-config will be used to establish the connection. If a pool is provided, outgoing connections will be created to all active poolmembers of the specified pool.","examples":"when CLIENT_ACCEPTED {\n                MR::prime config /Common/my_tc pool /Common/default_pool\n            }","returnValue":""},
{"commandName":"MR::retry","description":"The MR::retry command instructs the Message Routing Framework submit the current message to the router to retry routing. This will clear the message's route status. The script may need to clear the message's existing nexthop and route fields if a new routetable lookup is desired. If a persistence record exists for this message, it may also need to be reset.","examples":"when MR_FAILED {\n    if {[MR::retry_count] < 2} {\n        MR::message nexthop none\n        MR::message route config tc1 host \"10.1.1.1:1234\"\n        MR::retry\n    }\n}","returnValue":""},
{"commandName":"MR::max_retries","description":"returns the number of retries allowed","examples":"when MR_FAILED {\n    if {[MR::message retry_count] < [MR::max_retries]} {\n        MR::message nexthop none\n        MR::retry\n    }\n}","returnValue":"returns the number of retries allowed"},
{"commandName":"MR::ignore_peer_port","description":"The MR::ignore_peer_port command sets or resets the ignore_peer_port mode of the current connection. If ignore_peer_port mode is enabled, the remote port of the connection will be ignored when determining if the connection is usable for forwarding a message to a peer. For example, if a peer at IP 10.1.2.3 connects using a ephemeral port of 12345 and ignore_peer_port is enabled, a message routed to IP 10.1.2.3 port 2345 can be forwarded using this connection since the port will be ignored.","examples":"when CLIENT_ACCEPTED {\n                MR::ignore_peer_port yes\n            }","returnValue":"Returns the current value of the ignore_peer_port flag. This will be 'true' or 'false'."},
{"commandName":"MR::connect_back_port","description":"The MR::connect_back_port command gets or sets connect_back_port for the current connection, which is used to enable bi-directional persistence if the client connected through an ephemeral port.","examples":"when CLIENT_ACCEPTED {\n                MR::connect_back_port 5678\n            }","returnValue":"Returns current connect_back_port value."},
{"commandName":"NAME::lookup","description":"Performs a DNS query, typically returning the A record for the indicated hostname, or the PTR record for the indicated IP address.\n\nStarting in v10.1, the RESOLV::lookup command has been introduced, which is the inline version of this command. With RESOLV::lookup, the iRule execution will suspend and the result will be simply returned, whereas NAME::lookup continues and eventually causes NAME_RESOLVED to fire, where the NAME::response command can be used to retrieve the lookup result.\n\nNAME::lookup <IPaddress>\nPerforms DNS query, returning the PTR record (hostname) for the indicated IP address. Only a single address should be returned.\n\nNAME::lookup <hostname>\nPerforms DNS query, returning the A record (address) for the indicated hostname. If no record is found, a blank string is returned. Multiple addresses may be returned in a tcl list format.\n\nIf you do not include the @{IP/Virtual Name} argument, local bind will be the target of the query. If your local bind is not set up to query recursively, and is not authoritative for the domain in question, you will receive no response.","examples":"# Reverse resolution - get PTR (hostname) for an IP address (Note: Not all names have corresponding PTR records. Reverse resolutions are easily spoofed not guaranteed to be correct) Logs a line reading \"client name = >10.10.10.1<\" if resolved or \"client name = ><\" if not:\nwhen HTTP_REQUEST {\n   # Hold HTTP data until hostname is resolved\n   HTTP::collect\n\n   # Start a name resolution on the hostname\n   NAME::lookup [IP::client_addr]\n}\nwhen NAME_RESOLVED {\n   log local0. \"client name = >[NAME::response]<\"\n\n   # Release HTTP data once hostname is resolved\n   HTTP::release\n}\n\n# Forward resolution - get IP address for hostname. Logs the following for resolution returning 3 addresses: \"IP address list for remotehost.domain.com = >{10.10.10.1 10.10.10.2 10.10.10.3}<\" \"First listed address is >10.10.10.1<\" \"Second listed address is >10.10.10.2<\"\nwhen HTTP_RESPONSE {\n\n   # Hold HTTP data until IP address is resolved\n   HTTP::collect\n\n   # Start a name resolution on the hostname\n   NAME::lookup remotehost.domain.com\n}\nwhen NAME_RESOLVED {\n\n   log local0. \"IP address list for remotehost.domain.com = >[NAME::response]<\"\n   log local0. \"First listed address is >[lindex [NAME::response] 0]<\"\n   log local0. \"Second listed address is >[lindex [NAME::response] 1]<\"\n\n   # Release HTTP data once hostname is resolved\n   HTTP::release\n}","returnValue":"Typically returning the A record for the indicated hostname, or the PTR record for the indicated IP address."},
{"commandName":"NAME::response","description":"Returns a list of records received in response to a DNS query made with the NAME__lookup command. If no records are returned, returns null.\n\nNAME::response\nIf resolution of a name was requested, returns a list of up to 16 records received in response to a lookup request.\nIf reverse resolution of an address was requested, returns the name received in response.\n\nNAME::response address [<index>]\nReturns the address record at the indicated offset from the list of records received in response to a lookup request. (Valid index values are 0 through 15 inclusive. If index is not specified, returns a list of up to 16 address records.)\n\nNAME::response name\nReturns the hostname received in response to a lookup request.","examples":"#Resolve a name to a list of addresses & use the first one\nwhen ... {\n    NAME::lookup $myHostname\n}\nwhen NAME_RESOLVED {\n    log local0. \"NAME_RESOLVED: [NAME::response]\"\n    set server_ip [NAME::response address 0]\n}\n\n#Resolve an address to a name & log it:\nwhen CLIENT_ACCEPTED {\n    NAME::lookup [IP::client_addr]\n}\nwhen NAME_RESOLVED {\n    log local0. \"Client IP resolves to [NAME::response name]\"\n}","returnValue":"Returns a list of records received in response to a DNS query"},
{"commandName":"NSH::path_id","description":"Set: Path ID for NSH.\n            Get(without parameters): path id from NSH.","examples":"# Set the path ID for NSH.\n            when LB_SELECTED {\n                NSH::path_id serverside_egress 10\n                set mypath_id [NSH::path_id]\n            }","returnValue":"None for set, value of path id for get."},
{"commandName":"NSH::service_index","description":"Set: Service index for NSH.\n            Get(without parameters): Service index from NSH.","examples":"# Set the service index for NSH.\n            when LB_SELECTED {\n                NSH::service_index serverside_egress 20\n                set myservice_index [NSH::service_index]\n            }","returnValue":"None."},
{"commandName":"NSH::context","description":"Set: context for NSH.\n            Get(without parameters): context from NSH.","examples":"# Set the context for NSH.\n            when LB_SELECTED {\n                NSH::context 1 serverside_egress 1111\n                set myctx1 [NSH::context 1]\n            }","returnValue":""},
{"commandName":"NSH::mimic","description":"Set mimic option for NSH.","examples":"# Set the mimic for NSH.\n            when LB_SELECTED {\n                NSH::mimic\n            }","returnValue":""},
{"commandName":"NTLM::disable","description":"Disables processing for NTLM\n\nSyntax\n\nNTLM::disable\n\n     * Disables processing for NTLM","examples":"Disables OneConnect & NTLM profile when a WWW-Authenticate \"Negotiate\"\nheader is present:\n\nwhen HTTP_RESPONSE {\n    if { [string tolower [HTTP::header values \"WWW-Authenticate\"]] contains \"negotiate\"} {\n        ONECONNECT::detach disable\n        NTLM::disable\n    }\n}","returnValue":""},
{"commandName":"NTLM::enable","description":"Enables processing for NTLM\n\nSyntax\n\nNTLM::enable\n\n     * Enables processing for NTLM","examples":"","returnValue":""},
{"commandName":"ONECONNECT::detach","description":"Controls the behavior of a server-side connection when a OneConnect\nprofile is on the virtual server. The default behavior is that the\nserver-side connection detaches after each response is completed, and a\nnew load balancing decision and persistence look-up are performed for\nevery request.\nDisabling detaching prevents this behavior.\nNote: the use of the terms \"request\" and \"response\" imply the presence\nof a supported layer 7 profile (e.g. the HTTP profile) on the virtual\nserver. An iRule can also detaching the server-side connection using\nthe LB::detach command.\nNote that this command has no impact on whether or not the server-side\nconnection will return to the idle connection pool when the client\nconnection closes. The ONECONNECT::reuse command controls this\nbehavior.\n\nSyntax\n\nONECONNECT::detach [enable | disable ]\n\n     * When disabled, the server-side connection will not detach.\n     * When enabled, the server-side connection detaches after each layer\n       7 transaction.","examples":"when HTTP_REQUEST {\n    set headreq 0\n    if { [HTTP::method] == \"HEAD\" } {\n        # We are a head request. Set the flag for checking in the response.\n        set headreq 1\n    }\n}\n\nwhen HTTP_RESPONSE {\n    if { $headreq } {\n        # Response to HEAD request. Detach after done.\n        ONECONNECT::detach enable\n        ONECONNECT::reuse enable\n    }\n}","returnValue":""},
{"commandName":"ONECONNECT::label","description":"Associate OneConnect keying information with connection\n\nSyntax\n\nONECONNECT::label update <key>\n\n     * Associate the provided OneConnect key with the connection. If\n       performed while OneConnect is attached to a server-side connection,\n       this associates both the client-side and server-side with the same\n       key. Once a keyed server-side has been detached, OneConnect will\n       only re-attach it to a client-side connection having the same key\n       (even when ONECONNECT::select is set to none, in which case only\n       unkeyed client-side connections will be attached to the server\n       side)","examples":"when HTTP_REQUEST {\n   set keymatch [HTTP::uri]\n   persist uie $keymatch\n   ONECONNECT::select persist\n }\nwhen HTTP_REQUEST_SEND {\n     if { $keymatch == \"/myuri\"} {\n     ONECONNECT::label update $keymatch\n     }\n   }","returnValue":""},
{"commandName":"ONECONNECT::reuse","description":"This command controls whether server-side connections are picked from\nthe pool of idle connections, and whether idle server-side connections\nare returned to the pool or closed when a client connection detaches or\ncloses. It will also display the current status of connection reuse, if\ncalled without any options.\nFor information on how to control the detaching behavior, see\nONECONNECT::detach.\nThe semantics of this command depend on the context in which it is\nbeing executed. Refer to Considering Context Part 1 and\nConsidering Context Part 2 for more information on contexts.\n\nSyntax\n\nONECONNECT::reuse enable\n\n   Note: Reuse being enabled is the default, all other things being equal.\n     * in a serverside context: when client connection detaches/closes,\n       connection is eligible to be returned to the pool of idle\n       connections.\n     * in a clientside context: when picking a server-side connection,\n       re-use a connection from the idle pool if one is available\n       according to the settings of the OneConnect profile.\n\nONECONNECT::reuse disable\n\n     * in a serverside context: when a client connection detaches/closes,\n       close this serverside connection.\n     * in a clientside context: when connecting to a server, do not pick\n       an idle connection from the connection pool; establish a new\n       connection.\n\nONECONNECT::reuse\n\n     * with no option specified, returns the OneConnect status of a\n       connection. Returns '1' for enabled and '0' for disabled. This is\n       available on BIG-IP v10 and higher only.\n\n   Only valid with a OneConnect profile applied to the virtual server.\n   Useful when you need to close a connection after a specific condition\n   is met, but still want to use OneConnect for other traffic traversing\n   the virtual server. (Closing connection after a POST, or to prevent\n   server-side connection re-use after a sensitive transaction is\n   completed.)","examples":"when HTTP_REQUEST {\nif {[HTTP::method] equals GET } {\n      ONECONNECT::reuse enable\n   } else {\n      ONECONNECT::reuse disable\n   }\n}","returnValue":""},
{"commandName":"ONECONNECT::select","description":"The 'select persist' command instructs the proxy to use persistence data as the\nOneConnect keying label when connecting to the server. NTLM connection pooling\nleverages these commands internally, and it is not necessary for the user to\nuse them directly.  Persistance data should be established via the 'persist'\ncommand.\n\nSyntax\n\nONECONNECT::select persist\n    Enable boolean value of persistance.\n\nONECONNECT::select none\n    Disable boolean value of persistance.\n\nONECONNECT::select\n    Returns value of the property based on the value of the property","examples":"when HTTP_REQUEST {\n     set keymatch [HTTP::uri]\n     persist uie $keymatch\n     ONECONNECT::select persist\n   }\nwhen HTTP_REQUEST_SEND {\n     if { $keymatch == \"/myuri\"} {\n     ONECONNECT::label update $keymatch\n     }\n   }","returnValue":""},
{"commandName":"PCP::reject","description":"This command provides the ability to cause a PCP (Port Control\nProtocol) reqeust to fail based on processing in the iRule. If the\nreject command is issued, the PCP request is rejected with the\nspecified result code and no other action is taken by the PCP proxy.\n\nSyntax\n\nPCP::reject <result_code>\n\n     * result_code is an integer field between 0 and 255 and is required","examples":"when PCP_REQUEST {\n     if {[PCP::request opcode] == \"map\" &&\n             [PCP::request internal-port] == 22 } {\n         log \"Rejecting PCP request to map SSH\"\n         PCP::reject 1\n    }\n}","returnValue":""},
{"commandName":"PCP::response","description":"This command provides access to the data in a PCP (Port Control\nProtocol) response packet. Access to this data is read-only, and the\ndata in the PCP response cannot be modified via the PCP::response\ncommand.\n\nSyntax\n\nPCP::response version\n\n     * Returns the PCP version of the response.\n\nPCP::response opcode\n\n     * Returns the opcode of the PCP response as a string, either\n       \"announce\", \"peer\" or \"map\". If the opcode is invalid, the field is\n       returned as an integer.\n\nPCP::response lifetime\n\n     * Returns the lifetime field from the PCP response.\n\nPCP::response protocol\n\n     * Returns the protocol of the matching PCP request as a string,\n       either \"tcp\" or \"udp\". If the protocol is invalid, the field is\n       returned as an integer. This subcommand is only valid for a PCP map\n       response. \"NA\" is returned if called on a peer or announce\n       response.\n\nPCP::response internal-port\n\n     * Returns the internal port of the matching PCP request. This\n       subcommand is only valid for a PCP map response. \"NA\" is returned\n       if called on a peer or announce response.\n\nPCP::response client-addr\n\n     * Returns the client address of the matching PCP request.\n\nPCP::response result\n\n     * Returns the result field of the PCP response. This is an integer\n       between 0 and 255. 0 denotes success. All others denote failure of\n       the PCP request.\n\nPCP::response assigned-ext-port\n\n     * Returns the assigned external port in the PCP response. This\n       subcommand is only valid for a PCP map response. \"NA\" is returned\n       if called on a peer or announce response.\n\nPCP::response assigned-ext-addr\n\n     * Returns the assigned external address in the PCP response. This\n       subcommand is only valid for a PCP map response. \"NA\" is returned\n       if called on a peer or announce response.","examples":"when PCP_RESPONSE {\n    if {[PCP::response opcode] == \"map\" && [PCP::response result] != 0] } {\n        log \"PCP map request from\\\n              [PCP::response client-addr]:[PCP::response internal-port]\\\n              failed with a result of [PCP::response result]\"\n    }\n}","returnValue":""},
{"commandName":"PCP::request","description":"This command provides access to the data sent in a PCP (Port Control\nProtocol) request. Access to this data is read-only, and the data in\nthe PCP request cannot be modified via the PCP::request command.\n\nSyntax\n\nPCP::request version\n\n     * Returns the PCP version of the request\n\nPCP::request opcode\n\n     * Returns the opcode in the PCP request as a string, either\n       \"announce\", \"peer\" or \"map\". If the opcode is invalid the field is\n       returned as an integer.\n\nPCP::request lifetime\n\n     * Returns the lifetime specified in the PCP request.\n\nPCP::request protocol\n\n     * Returns the protocol specified in the PCP request as a string,\n       either \"tcp\" or \"udp\". If the protocol is invalid the field is\n       returned as an integer. This sub-command is only valid for a PCP\n       map request. \"NA\" is returned if called on a peer or announce\n       request.\n\nPCP::request internal-port\n\n     * Returns the internal port specified in the PCP request. This\n       subcommand is only valid for a PCP map request. \"NA\" is returned if\n       called on a peer or announce request.\n\nPCP::request prefer-failure\n\n     * Returns 2 if prefer-failure is set in the PCP request, returns 0 if\n       it is not. This subcommand is only valid for a PCP map request.\n       \"NA\" is returned if called on a peer or announce request.\n\nPCP::request client-addr\n\n     * Returns the client address of the PCP request.\n\nPCP::request third-party\n\n     * Returns 1 if third-party is set in the PCP request, returns 0 if it\n       is not. This subcommand is only valid for a PCP map request. \"NA\"\n       is returned if called on a peer or announce request.\n\nPCP::request third-party-int-addr\n\n     * Returns the third-party IP address specified in the PCP request. If\n       a third-party address is not specified in the PCP request, \"NA\" is\n       returned. This subcommand is only valid for a PCP map request. \"NA\"\n       is returned if called on a peer or announce request.\n\nPCP::request suggested-ext-port\n\n     * Returns the suggested external port specified in the PCP request.\n       If a suggested external port was not specified, 0 is returned. This\n       subcommand is only valid for a PCP map request. \"NA\" is returned if\n       called on a peer or announce request.\n\nPCP::request suggested-ext-addr\n\n     * Returns the suggested external address specified in the PCP\n       request. If a suggested external address was not specified, an\n       address string containing all zero’s is returned. This subcommand\n       is only valid for a PCP map request. \"NA\" is returned if called on\n       a peer or announce request.","examples":"Logs a message each time a PCP map request is received from client\n192.168.1.1:\n\nwhen PCP_REQUEST {\n     if {[PCP::request opcode] == \"map\" && [PCP::request client-addr] == \"192.168.1.1\" } {\n         log \"Received PCP map request for port [PCP::request internal-port] from 192.168.1.1\"\n     }\n}","returnValue":""},
{"commandName":"PEM::session","description":"This command allows you to create, delete or retreive information of a PEM Session in the PEM Session DB.\nEach PEM session carries the following standard attributes: imsi, imeisv, tower-id, user-name, state, aaa-reporting-interval, provision.\n\nDetails (Syntax):\nPEM::session create <framed ip> [subscriber-id <string> subscriber-type <e164 | imsi | nai | private>] [imsi <sring>] [user-name <string>] [tower-id <string>] [imeisv <string>] [provision <yes | no>] [<custom attr> <custom value>]\n    Create a PEM Session for <framed ip> with [attr valule] pair, including custom attribute and custom value\n    Note that if any of the subscriber-id and subscriber-type is specified, the other one should be specified as well.\n\nPEM::session info <ip addr> imsi | imeisv | tower-id | user-name | subs-type | subs-id | state <value>?\n    Retrieve the value of the specified field from the session with <ip addr> if no <value> appended in the end.\n    With <value> appended, the command is used to set the corresponding attribute value for the session.\n\nPEM::session info attr delete <ip addr> <attr>\n    Delete the custom attribute for the session.\n\nPEM::session info attr <ip addr> <attr>\n    Get the value of specified custom attribute name for the session.\n\nPEM::session info attr <ip addr> <attr> <value>\n    Add a custom attribute to the session.\n\nPEM::session info dtos tcp-fingerprint <ttl | window-size | window-scaling | source-port | hdr-length | os> <ip_addr>\n    Get the specified tcp fingerprint attribute for the specified session.\n    The attributes include (ttl, window size, window scaling value, source port, header length).\n\nPEM::session info dtos <user-agent | device>? os <ip_addr>\n    Get the OS identified by specified mechanism, namely user-agent and TAC-code, for the specified session.\n    If no mechanism is specified, return the OS as determined by the sys db variable 'tmm.pem.dtos.sampled.os.from'.\n\nPEM::session info dtos device name <ip_addr>\n    Get the device name identified by the TAC-code for the specified session.\n\nPEM::session info tethering detected <ip_addr>\n    Return true or false based whether tethering was detected for the session.\n\nPEM::session info tethering timestamp <ip_addr>\n    Returns the time at which tethering detected state is changed.\n\nPEM::session info tethering sample-score <ip_addr>\n    Returns score of the last sample. The score is used to determine if the subscriber session is tethering.\n\nPEM::session delete <ip addr>\n    Delete session refered by the IP address.\n\nPEM::session config policy referential set <framed ipaddr> <list of referential policies>\n    Set referential policies to this pem session.\n\nPEM::session config policy referential update <framed ipaddr> add/delete <list of referential policies>\n    Add/delete referential policies to this pem session.\n\nPEM::session config policy get <framed ipaddr>\n    Returns a ist of policies applied to this session.\n\nPEM::session ip <subscriber id> <subscriber type>?\n    Returns subscriber IP address when given subscriber id (subscriber type is optional).","examples":"when HTTP_REQUEST {\n    PEM::session create 10.10.10.10 subscriber-id 12345 subscriber-type e164\n\n    set polisy_var [PEM::session config policy get 10.10.10.10]\n    set ip_var [PEM::session ip 12345 e164]\n    set id_var [PEM::session info 10.10.10.10 subscriber-id]\n\n    PEM::session delete 10.10.10.10\n}","returnValue":""},
{"commandName":"PEM::subscriber","description":"Each PEM session carries the following standard attributes: imsi, imeisv, tower-id, user-name, subscriber-type, subscriber-id, state, aaa-reporting-interval, provision.\n\nDetails (Syntax):\nPEM::subscriber create <subscriber-id> subscriber-type <e164 | imsi | nai | private> ip-address <IP_ADDR> [imsi <sring>] [user-name <string>] [tower-id <string>] [imeisv <string>] [provision <yes | no>] [<custom attr> <custom value>]\n    Create a PEM subscriber session for <subscriber-id> subscriber-type <e164 | imsi | nai | private> ip-address <IP_ADDR> with [attr valule] pair, including custom attribute and custom value.\n    If no subscriber-id-type is specified, it will default to imsi.\n\nPEM::subscriber info <subscriber-id> <e164 | imsi | nai | private> imsi | imeisv | tower-id | user-name | state <value>?\n    Retrieve the value of specified field from the subscriber session with <subscriber-id> <e164 | imsi | nai | private> if no <value> appended in the end.\n    With <value> appended, the command is used to set the corresponding attribute value for the subscriber.\n\nPEM::subscriber info attr delete <subscriber-id> <e164 | imsi | nai | private> <attr>\n    Delete custom attribute for the subscriber session\n\nPEM::subscriber info attr <subscriber-id>  <e164 | imsi | nai | private> <attr>\n    Get the value of specified custom attribute name for the subscriber session\n\nPEM::subscriber info attr <subscriber-id>  <e164 | imsi | nai | private> <attr> <value>\n    Add a custom attribute to the subscriber session\n\nPEM::subscriber info dtos tcp-fingerprint <ttl | window-size | window-scaling | source-port | hdr-length | os> <subscriber-id> <e164 | imsi | nai | private>\n    Get the specified tcp fingerprint attribute for the specified subscriber.\n    The attributes include (ttl, window size, window scaling value, source port, header length).\n\nPEM::subscriber info dtos <user-agent | device>? os <subscriber-id> <e164 | imsi | nai | private>\n    Get the OS identified by specified mechanism, namely user-agent and TAC-code, for the specified subscriber.\n    If no mechanism is specified, return the OS as determined by the sys db variable 'tmm.pem.dtos.sampled.os.from'.\n\nPEM::subscriber info dtos device name <subscriber-id> <e164 | imsi | nai | private>\n    Get the device name identified by the TAC-code for the specified subscriber.\n\nPEM::subscriber info tethering detected <subscriber-id> <e164 | imsi | nai | private>\n    Returns true or false based whether tethering was detected for the subscriber.\n\nPEM::subscriber info tethering timestamp <subscriber-id> <e164 | imsi | nai | private>\n    Returns the time at which tethering detected state is changed.\n\nPEM::susbcriber info tethering sample-score <subscriber-id> <e164 | imsi | nai | private>\n    Returns score of the last sample. The score is used to determine if the subscriber is tethering.\n\nPEM::subscriber delete <subscriber-id> <e164 | imsi | nai | private>\n    Delete the subscriber session.\n\nPEM::subscriber config policy referential set <subscriber-id> <e164 | imsi | nai | private> <list of referential policies>\n    Set referential policies to this pem subscriber session.\n\nPEM::subscriber config policy referential update <subscriber-id> <e164 | imsi | nai | private> add/delete <list of referential policies>\n    Delete/add referential policies to this subscriber session.\n\nPEM::subscriber config policy get <subscriber-id> <e164 | imsi | nai | private>\n    Returns a list of policies applied to the subscriber specifying the subscriber-id and subscriber-id-type.\n\nPEM::subscriber ip <subscriber id> <e164 | imsi | nai | private>? (<ip_address>*)?\n    Returns subscriber IP address when given subscriber id (subscriber-id-type is optional).\n    Or sets the subscriber session with an ip address list.","examples":"when HTTP_REQUEST {\n    PEM::subscriber create 4086007577 subscriber-type e164 ip-address 10.10.10.10\n    PEM::subscriber config policy referential set 4086007577 e164 policy1\n    PEM::subscriber ip 4086007577 e164 10.0.0.92 2001::101\n    PEM::subscriber info 4086007577 e164 imsi 1223456\n    PEM::subscriber info 4086007577 e164 imeisv 2534535\n    PEM::subscriber info 4086007577 e164 tower-id 8248249\n    PEM::subscriber info 4086007577 e164 user-name 2139449\n\n    log local0.  \"policy: [PEM::subscriber config policy get 4086007577 e164]\"\n    log local0.  \"imsi: [PEM::subscriber info 4086007577 e164 imsi]\"\n    log local0.  \"imeisv: [PEM::subscriber info 4086007577 e164 imeisv]\"\n    log local0.  \"tower-id: [PEM::subscriber info 4086007577 e164 tower-id]\"\n    log local0.  \"user-name: [PEM::subscriber info 4086007577 e164 user-name]\"\n    log local0.  \"state: [PEM::subscriber info 4086007577 e164 state]\"\n\n    PEM::subscriber info attr 4086007577 e164 custom1 876\n    log local0.  \"custom1: [PEM::subscriber info attr 4086007577 e164 custom1]\"\n}","returnValue":""},
{"commandName":"PEM::flow","description":"The transciontal disable command disables the transactional feature in PEM for a flow.\nThe eval command trigers the policy evaluation for the flow immediately.","examples":"when HTTP_REQUEST {\n    PEM::flow transactional disable;\n    PEM::flow eval;\n}","returnValue":""},
{"commandName":"PEM::enable","description":"Enable PEM for the current flow. Note that the config must already contain a Policy Enforcement Profile.","examples":"when HTTP_REQUEST {\n    PEM::enable;\n}","returnValue":""},
{"commandName":"PEM::disable","description":"Disable PEM for the current flow. Note that the config must already contain a Policy Enforcement Profile.","examples":"when HTTP_REQUEST {\n    PEM::disable;\n}","returnValue":""},
{"commandName":"POLICY::controls","description":"Returns details about the policy controls for the policies associated\nwith the virtual server that the iRule is enabled on. Policy controls\nare typically virtual server profiles or features which can be enabled,\ndisabled or modified per iRule execution via policies.\n\nAs of v11.4 the following controls are available:\n acceleration        - Application Acceleration Manager (AAM)\n asm                 - Application Security Manager\n avr                 - Application Visibility and Reporting\n caching             - HTTP caching\n classification      - HTTP classification for Policy Enforcement Manager (PEM)\n compression         - HTTP compression\n forwarding          - pool, node, SNAT selection\n l7dos               - Layer 7 Denial of Service profile\n request-adaptation  - request adaptation\n response-adaptation - response adaptation\n server-ssl          - Server SSL\nAs of v12.0\n persistence         - Persistence mode\n\n\nSyntax\n\nPOLICY::controls\n\n     * Returns a list of policy control(s) attached to the virtual server.\n       These are typically virtual server profiles or features which can\n       be enabled, disabled or modified per iRule execution via\n       policies.\n\nPOLICY::controls [ acceleration | asm | avr | caching | classification | compression | forwarding | l7dos | request-adaptation | response-adaptation | server-ssl | persistence]\n\n     * Returns 1 or 0 depending on whether the given control is enabled in\n       the selected policy","examples":"# Log the policy controls for this virtual server\nwhen HTTP_REQUEST {\n\n        # Log the policy controls enabled on this virtual server\n        log local0. \"\\[POLICY::controls\\]: [POLICY::controls]\"\n\n        # Loop through each possible control type and log whether it is enabledor not (1 for enabled, 0 for not enabled)\n        foreach control {acceleration asm avr caching classification compression forwarding l7dos request-adaptation response-adaptation server-ssl} {\n                log local0. \"\\[POLICY::controls $control\\]: [POLICY::controls $control]\"\n        }\n}\n\n# /var/log/ltm output:\n<HTTP_REQUEST>: [POLICY::controls]: forwarding compression server-ssl\n<HTTP_REQUEST>: [POLICY::controls acceleration]: 0\n<HTTP_REQUEST>: [POLICY::controls asm]: 0\n<HTTP_REQUEST>: [POLICY::controls avr]: 0\n<HTTP_REQUEST>: [POLICY::controls caching]: 0\n<HTTP_REQUEST>: [POLICY::controls classification]: 0\n<HTTP_REQUEST>: [POLICY::controls compression]: 1\n<HTTP_REQUEST>: [POLICY::controls forwarding]: 1\n<HTTP_REQUEST>: [POLICY::controls l7dos]: 0\n<HTTP_REQUEST>: [POLICY::controls request-adaptation]: 0\n<HTTP_REQUEST>: [POLICY::controls response-adaptation]: 0\n<HTTP_REQUEST>: [POLICY::controls server-ssl]: 1","returnValue":""},
{"commandName":"POLICY::names","description":"iRule command which returns details about the policy names for the\nvirtual server the iRule is enabled on.\n\nSyntax\n\nPOLICY::names active\n\n     * Returns list of policy name(s) attached to the virtual server\n\nPOLICY::names matched\n\n     * Returns a list of policy name(s) that had policy rules executed\n\nPOLICY::names unmatched\n\n     * Returns a list of policy name(s) attached to the virtual server\n       that had no policy rules executed","examples":"# Log the policy names for this virtual server\nwhen HTTP_REQUEST {\n        log local0. \"Enabled on this VS: \\[POLICY::names active\\]: [POLICY::names active]\"\n        log local0. \"Matched: \\[POLICY::names matched\\]: [POLICY::names matched]\"\n        log local0. \"Not matched: \\[POLICY::names unmatched\\]: [POLICY::names unmatched]\"\n}\n\n# /var/log/ltm output:\n<HTTP_REQUEST>: Enabled on this VS: [POLICY::names active]: /Common/uri_to_pool_policy /Common/serverssl_policy /Common/unmatched_policy\n<HTTP_REQUEST>: Matched: [POLICY::names matched]: /Common/serverssl_policy /Common/uri_to_pool_policy\n<HTTP_REQUEST>: Not matched: [POLICY::names unmatched]: /Common/unmatched_policy","returnValue":""},
{"commandName":"POLICY::rules","description":"Returns the policy rules of the supplied policy that had actions\nexecuted.\n\nSyntax\n\nPOLICY::rules matched <policy>\n\n     * Returns the policy rules of the supplied policy that had actions\n       executed.","examples":"# Log the policy targets for this virtual server\nwhen HTTP_REQUEST {\n\n        log local0. \"Looping through \\[POLICY::names matched\\]: [POLICY::names matched]\"\n        foreach policy [POLICY::names matched] {\n                log local0. \"\\[POLICY::rules matched $policy\\]: [POLICY::rules matched $policy]\"\n        }\n}\n\n# /var/log/ltm output:\n<HTTP_REQUEST>: Looping through [POLICY::names matched]: /Common/serverssl_policy /Common/uri_to_pool_policy\n<HTTP_REQUEST>: [POLICY::rules matched /Common/serverssl_policy]: serverssl_disable_default_rule\n<HTTP_REQUEST>: [POLICY::rules matched /Common/uri_to_pool_policy]: pool2_rule","returnValue":""},
{"commandName":"POLICY::targets","description":"Returns or sets properties of the policy rule targets for the policies\nassociated with the virtual server that the iRule is enabled on. A\npolicy rule target can be considered an action that the policy uses if\nthe rule conditions are met.\n\nAs of v11.4 the following policy targets are available:\n wam              - Application Acceleration Manager (AAM)\n asm              - Application Security Manager\n log              - Log\n http-cookie      - HTTP cookie\n http-header      - HTTP header\n http-host        - HTTP host header\n http-referer     - HTTP referer header\n http-set-cookie  - HTTP set-cookie header\n http-uri         - HTTP URI\n tcl              - Set a Tcl variable name and value\n tcp-nagle        - TCP Nagels algorithm\nAs of v12.0\n persist          - Persistence mode\n\nSyntax\n\nPOLICY::targets\n\n     * Returns a list of policy target(s) attached to the virtual server.\n       These are typically virtual server profiles or features which can\n       be enabled|disabled or modified per iRule execution via\n       policies.\n\nPOLICY::targets [ ltm-policy | http | http-uri | http-host | http-header | http-referer | http-cookie | http-set-cookie | http-reply | log | pem | cache | compress | decompress | forward | wam | asm | l7dos | avr | tcl | request-adapt | response-adapt | tcp-nagle | server-ssl | persist ]\n\n     * Returns 1 or 0 depending on whether the given target is used in the\n       selected policy","examples":"# Log the policy targets for this virtual server\nwhen HTTP_REQUEST {\n\n        # Log the policy targets enabled on this virtual server\n        log local0. \"\\[POLICY::targets\\]: [POLICY::targets]\"\n\n        # Loop through each possible target type and log whether it is enabled or not (1 for enabled, 0 for not enabled)\n        foreach target {asm wam log http-cookie http-header http-host http-referer http-set-cookie http-uri log tcl tcp-nagle} {\n                log local0. \"\\[POLICY::targets $target\\]: [POLICY::targets $target]\"\n        }\n}\n\n# /var/log/ltm output:\n<HTTP_REQUEST>: [POLICY::targets]: log forward server-ssl\n<HTTP_REQUEST>: [POLICY::targets asm]: 0\n<HTTP_REQUEST>: [POLICY::targets wam]: 0\n<HTTP_REQUEST>: [POLICY::targets http-cookie]: 0\n<HTTP_REQUEST>: [POLICY::targets http-header]: 0\n<HTTP_REQUEST>: [POLICY::targets http-host]: 0\n<HTTP_REQUEST>: [POLICY::targets http-referer]: 0\n<HTTP_REQUEST>: [POLICY::targets http-set-cookie]: 0\n<HTTP_REQUEST>: [POLICY::targets http-uri]: 0\n<HTTP_REQUEST>: [POLICY::targets log]: 1\n<HTTP_REQUEST>: [POLICY::targets tcl]: 0\n<HTTP_REQUEST>: [POLICY::targets tcp-nagle]: 0","returnValue":""},
{"commandName":"PROFILE::access","description":"","examples":"","returnValue":""},
{"commandName":"PROFILE::auth","description":"Returns the current value of the specified setting in the assigned authentication profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned authentication profile."},
{"commandName":"PROFILE::clientssl","description":"Returns the current value of the specified setting in the assigned Client SSL profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned Client SSL profile."},
{"commandName":"PROFILE::diameter","description":"Returns the current value of the specified setting in an assigned DIAMETER profile.","examples":"","returnValue":"Returns the current value of the specified setting in an assigned DIAMETER profile."},
{"commandName":"PROFILE::exists","description":"Determine if a profile is configured on a virtual server.\n\nNote that the results of the PROFILE::exists \"profile type\" command is specific to the context of the event. For example, with a client SSL profile associated with the virtual server, PROFILE::exists clientssl will return 1 in clientside events and 0 in serverside events. Likewise, PROFILE::exists serverssl will return 0 in clientside events and 1 in serverside events.","examples":"when CLIENT_ACCEPTED {\n   if { [PROFILE::exists clientssl] == 1} {\n      log local0. \"client SSL profile enabled on virtual server\"\n   }\n}\nwhen SERVER_CONNECTED {\n   if { [PROFILE::exists serverssl] == 1} {\n      log local0. \"server SSL profile enabled on virtual server\"\n   }\n}","returnValue":"Returns 1 if the profile is configured on the current virtual server. Returns 0 if the profile is not configured on the current virtual server."},
{"commandName":"PROFILE::vdi","description":"Returns the current value of the specified setting in the assigned VDI profile.","examples":"when HTTP_REQUEST {\n    log local0. \"\\[PROFILE::vdi msrdp_ntlm_auth_name\\]:    [PROFILE::vdi msrdp_ntlm_auth_name]\"\n    log local0. \"\\[PROFILE::vdi citrix_storefront_replacement\\]:   [PROFILE::vdi citrix_storefront_replacement]\"\n}","returnValue":"Returns the current value of the specified setting in the assigned VDI profile."},
{"commandName":"PROFILE::exchange","description":"","examples":"","returnValue":""},
{"commandName":"PROFILE::fastL4","description":"Returns the current value of the specified setting in the assigned Fast L4 profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned Fast L4 profile."},
{"commandName":"PROFILE::fasthttp","description":"Returns the current value of the specified setting in the assigned Fast HTTP profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned Fast HTTP profile."},
{"commandName":"PROFILE::ftp","description":"Returns the current value of the specified setting in the assigned FTP profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned FTP profile."},
{"commandName":"PROFILE::tftp","description":"Returns the current value of the specified setting in the assigned TFTP profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned TFTP profile."},
{"commandName":"PROFILE::http","description":"Returns the current value of the specified setting in the assigned HTTP profile.","examples":"# For examples of the command output, add a simple logging iRule to a VIP:\nwhen HTTP_REQUEST {\n   log local0. \"\\[PROFILE::http name\\]: [PROFILE::http name]\"\n}\n\n# Note: When testing command options listed above some generated either MCP errors when trying to save the iRule or TCL runtime errors when executing the code in 9.4.5.","returnValue":"Returns the current value of the specified setting in the assigned HTTP profile."},
{"commandName":"PROFILE::httpcompression","description":"Returns the current value of the specified setting in an assigned HTTP compression profile.","examples":"","returnValue":"Returns the current value of the specified setting in an assigned HTTP compression profile."},
{"commandName":"PROFILE::list","description":"This command returns all the names of the profiles of the class asked for that are attached to this virtual server.","examples":"","returnValue":"Returns all the names of the profiles of the class asked for that are attached to this virtual server"},
{"commandName":"PROFILE::oneconnect","description":"Returns the current value of the specified setting in the assigned Oneconnect profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned Oneconnect profile."},
{"commandName":"PROFILE::persist","description":"Returns the current value of the specified setting in the assigned persistence profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned persistence profile."},
{"commandName":"PROFILE::serverssl","description":"Returns the current value of the specified setting in the assigned Server SSL profile.","examples":"when HTTP_REQUEST {\n    if {[PROFILE::exists serverssl] == 1}{\n        log local0. \"server SSL profile enabled: [PROFILE::serverssl name]\"\n    }\n}","returnValue":"Returns the current value of the specified setting in the assigned Server SSL profile."},
{"commandName":"PROFILE::stream","description":"Returns the current value of the specified setting in the assigned Stream profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned Stream profile."},
{"commandName":"PROFILE::tcp","description":"Returns the current value of the specified setting in an assigned TCP profile.","examples":"when CLIENT_ACCEPTED {\n   # To generate this list, I copied the profile options from 'b profile tcp list all'\n   # The commands which are commented out are apparently not valid in an iRule (yet?)\n    log local0. \"\\[PROFILE::tcp reset_on_timeout\\]:    [PROFILE::tcp reset_on_timeout]\"\n    log local0. \"\\[PROFILE::tcp time_wait_recycle\\]:   [PROFILE::tcp time_wait_recycle]\"\n    log local0. \"\\[PROFILE::tcp delayed_acks\\]:        [PROFILE::tcp delayed_acks]\"\n    log local0. \"\\[PROFILE::tcp proxy_mss\\]:           [PROFILE::tcp proxy_mss]\"\n    log local0. \"\\[PROFILE::tcp proxy_options\\]:       [PROFILE::tcp proxy_options]\"\n    log local0. \"\\[PROFILE::tcp deferred_accept\\]:     [PROFILE::tcp deferred_accept]\"\n    log local0. \"\\[PROFILE::tcp selective_acks\\]:      [PROFILE::tcp selective_acks]\"\n    log local0. \"\\[PROFILE::tcp dsack\\]:               [PROFILE::tcp dsack]\"\n    log local0. \"\\[PROFILE::tcp ecn\\]:                 [PROFILE::tcp ecn]\"\n    log local0. \"\\[PROFILE::tcp limited_transmit\\]:    [PROFILE::tcp limited_transmit]\"\n    log local0. \"\\[PROFILE::tcp rfc1323\\]:             [PROFILE::tcp rfc1323]\"\n    log local0. \"\\[PROFILE::tcp slow_start\\]:          [PROFILE::tcp slow_start]\"\n    log local0. \"\\[PROFILE::tcp bandwidth_delay\\]:     [PROFILE::tcp bandwidth_delay]\"\n    log local0. \"\\[PROFILE::tcp nagle\\]:               [PROFILE::tcp nagle]\"\n    log local0. \"\\[PROFILE::tcp abc\\]:                 [PROFILE::tcp abc]\"\n    log local0. \"\\[PROFILE::tcp ack_on_push\\]:         [PROFILE::tcp ack_on_push]\"\n#   log local0. \"\\[PROFILE::tcp md5_sign\\]:            [PROFILE::tcp md5_sign]\"\n    log local0. \"\\[PROFILE::tcp cmetrics_cache\\]:      [PROFILE::tcp cmetrics_cache]\"\n#   log local0. \"\\[PROFILE::tcp md5_sign_passphrase\\]: [PROFILE::tcp md5_sign_passphrase]\"\n    log local0. \"\\[PROFILE::tcp proxy_buffer_low\\]:    [PROFILE::tcp proxy_buffer_low]\"\n    log local0. \"\\[PROFILE::tcp proxy_buffer_high\\]:   [PROFILE::tcp proxy_buffer_high]\"\n    log local0. \"\\[PROFILE::tcp idle_timeout\\]:        [PROFILE::tcp idle_timeout]\"\n#   log local0. \"\\[PROFILE::tcp time_wait\\]:           [PROFILE::tcp time_wait]\"\n#   log local0. \"\\[PROFILE::tcp fin_wait\\]:            [PROFILE::tcp fin_wait]\"\n#   log local0. \"\\[PROFILE::tcp close_wait\\]:          [PROFILE::tcp close_wait]\"\n#   log local0. \"\\[PROFILE::tcp send_buffer\\]:         [PROFILE::tcp send_buffer]\"\n#   log local0. \"\\[PROFILE::tcp recv_window\\]:         [PROFILE::tcp recv_window]\"\n    log local0. \"\\[PROFILE::tcp keep_alive_interval\\]: [PROFILE::tcp keep_alive_interval]\"\n#   log local0. \"\\[PROFILE::tcp max_retrans_syn\\]:     [PROFILE::tcp max_retrans_syn]\"\n#   log local0. \"\\[PROFILE::tcp max_retrans\\]:         [PROFILE::tcp max_retrans]\"\n#   log local0. \"\\[PROFILE::tcp ip_tos\\]:              [PROFILE::tcp ip_tos]\"\n#   log local0. \"\\[PROFILE::tcp link_qos\\]:            [PROFILE::tcp link_qos]\"\n#   log local0. \"\\[PROFILE::tcp congestion_control\\]:  [PROFILE::tcp congestion_control]\"\n#   log local0. \"\\[PROFILE::tcp partition\\]:           [PROFILE::tcp partition]\"\n}\nwhen SERVER_CONNECTED {\n   # Log the idle timeout on the serverside TCP profile of the VIP (default of 300 seconds)\n   log local0. \"\\[PROFILE::tcp idle_timeout\\]: [PROFILE::tcp idle_timeout]\"\n}\n\n# Sample log output for the default tcp-lan-optimized profile in v10.0.1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp reset_on_timeout]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp time_wait_recycle]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp delayed_acks]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp proxy_mss]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp proxy_options]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp deferred_accept]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp selective_acks]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp dsack]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp ecn]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp limited_transmit]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp rfc1323]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp slow_start]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp bandwidth_delay]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp nagle]: 0\n# <CLIENT_ACCEPTED>: [PROFILE::tcp abc]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp ack_on_push]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp cmetrics_cache]: 1\n# <CLIENT_ACCEPTED>: [PROFILE::tcp proxy_buffer_low]: 98304\n# <CLIENT_ACCEPTED>: [PROFILE::tcp proxy_buffer_high]: 131072\n# <CLIENT_ACCEPTED>: [PROFILE::tcp idle_timeout]: 300\n# <CLIENT_ACCEPTED>: [PROFILE::tcp keep_alive_interval]: 1800\n# <SERVER_CONNECTED: [PROFILE::tcp idle_timeout]: 300","returnValue":"Returns the current value of the specified setting in an assigned TCP profile."},
{"commandName":"PROFILE::udp","description":"Returns the current value of the specified setting in an assigned UDP profile.","examples":"","returnValue":"Returns the current value of the specified setting in an assigned UDP profile."},
{"commandName":"PROFILE::webacceleration","description":"Returns the value of an web acceleration profile setting","examples":"","returnValue":"Returns the value of an web acceleration profile setting"},
{"commandName":"PROFILE::xml","description":"Returns the current value of the specified setting in an assigned XML profile.","examples":"","returnValue":"Returns the current value of the specified setting in an assigned XML profile."},
{"commandName":"PROFILE::avr","description":"Returns the current value of the specified setting in the assigned avr profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned avr profile."},
{"commandName":"PROFILE::antifraud","description":"Returns the current value of the specified setting in the assigned ANTIFRAUD profile.","examples":"","returnValue":"Returns the current value of the specified setting in the assigned ANTIFRAUD profile."},
{"commandName":"PSC::aaa_reporting_interval","description":"The PSC::aaa_reporting_interval command gets the AAA reporting interval or sets the AAA reporting interval when the optional value is given.\n\nSyntax\n\nPSC::aaa_reporting_interval\n\n     * Retrieve the AAA reporting interval.\n\nPSC::aaa_reporting_interval <value>\n\n     * Set the AAA reporting interval.","examples":"","returnValue":"Return AAA reporting interval when no argument is given."},
{"commandName":"PSC::attr","description":"The PSC::attr commands get/set/remove the custom attributes.\n\nSyntax\n\nPSC::attr\n\n     * Retrieve the list of custom attribute names.\n\nPSC::attr <name>\n\n     * Get a custom attribute value by name.\n\nPSC::attr <name> <value>\n\n     * Set a custom attribute value. If the attribute does not exist, it\n       is going to be created.\n\nPSC::attr remove <name>\n\n     * Remove a custom attribute by name.\n\nPSC::attr remove\n\n     * Remove all custom attributes.","examples":"","returnValue":"* PSC::attr\n    Return the list of custom attribute names when no argument is given.\n\n* PSC::attr <name>\n    Return the custom attribute value by name."},
{"commandName":"PSC::calling_id","description":"The PSC::calling_id command gets the calling station id or sets the\ncalling station id when the optional value is given.\n\nSyntax\n\nPSC::calling_id\n\n     * Retrieve the calling station id.\n\nPSC::calling_id <value>\n\n     * Set the calling station id.","examples":"","returnValue":"Return the calling station id when no argument is given."},
{"commandName":"PSC::imeisv","description":"The PSC::imeisv command gets the imeisv or sets the imeisv when the\noptional value is given.\n\nSyntax\n\nPSC::imeisv\n\n     * Retrieve the imeisv value.\n\nPSC::imeisv <value>\n\n     * Set the imeisv value.","examples":"","returnValue":"Return the imeisv value when no argument is given."},
{"commandName":"PSC::imsi","description":"The PSC::imsi command gets the imsi or sets the imsi when the optional\nis given.\n\nSyntax\n\nPSC::imsi\n\n     * Retrieve the imsi value.\n\nPSC::imsi <value>\n\n     * Set the imsi value.","examples":"","returnValue":"Return the imsi value when no argument is given."},
{"commandName":"PSC::ip_address","description":"The PSC::ip_address commands get/set/remove the IP addresses.\n\nNote:IP address used in the commands below could be in IPv4 or IPv6 format. The route domain can be specified using % as a separator, e.g. 14.15.16.17%10.\n\nSyntax\n\nPSC::ip_address\n\n    * Retrieve the list of PSC ip addresses.\n\nPSC::ip_address [ip_address1, ip_address2, ...]\n\n    * Set a list of PSC ip addresses.\n\nPSC::ip_address add <ip_address>\n\n    * Add an entry to the PSC ip address list.\n\nPSC::ip_address remove <ip_address>\n\n    * Remove an entry from the PSC ip address list.\n\nPSC::ip_address remove\n\n    * Remove all PSC ip addresses.","examples":"","returnValue":"Return the list of PSC ip addresses when no argument is given."},
{"commandName":"PSC::lease_time","description":"The PSC::lease_time command gets the lease time of the session.\n\nSyntax\n\nPSC::lease_time\n\n    * Retrieve the session lease time.","examples":"","returnValue":"Return the session lease time."},
{"commandName":"PSC::policy","description":"The PSC::policy commands get/set/remove the PSC policies.\n\nSyntax\n\nPSC::policy\n\n     * Retrieve the list of PSC policies.\n\nPSC::policy [policy1, policy2, ...]\n\n     * Set a list of PSC policies.\n\nPSC::policy add <policy>\n\n     * Add an entry to the PSC policy list.\n\nPSC::policy remove <policy>\n\n     * Remove an entry from the PSC policy list.\n\nPSC::policy remove\n\n     * Remove all PSC policies.","examples":"","returnValue":"Return the list of PSC policies when no argument is given."},
{"commandName":"PSC::subscriber_id","description":"The PSC::subscriber_id command gets the subscriber id or sets the subscriber_id when the optional value is given.\n\nSyntax\n\nPSC::subscriber_id\n\n    * Retrieve the subscriber id.\n\nPSC::subscriber_id <subscriber_id>\n\n    * Set the subscriber id.","examples":"","returnValue":"Return the subscriber id when no argument is given."},
{"commandName":"PSC::tower_id","description":"The PSC::tower_id command gets the tower id or sets the tower id when the optional value is given.\n\nSyntax\n\nPSC::tower_id\n\n    * Retrieve the tower id.\n\nPSC::tower_id <name>\n\n    * Set the tower id.","examples":"","returnValue":"Return the tower id when no argument is given."},
{"commandName":"PSC::user_name","description":"The PSC::user_name command gets the user name or sets the user name when the optional value is given.\n\nSyntax\n\nPSC::user_name\n\n    * Retrieve the user name.\n\nPSC::user_name <value>\n\n    * Set the user name.","examples":"","returnValue":"Return the user name when no argument is given."},
{"commandName":"PSM::FTP::disable","description":"To disable PSM for FTP traffic","examples":"","returnValue":""},
{"commandName":"PSM::FTP::enable","description":"To enable PSM for FTP traffic","examples":"","returnValue":""},
{"commandName":"PSM::HTTP::disable","description":"To disable PSM for HTTP traffic","examples":"when HTTP_REQUEST {\n    if { [HTTP::uri] starts_with \"/bypass\" } {\n        PSM::HTTP::disable\n    }\n}","returnValue":""},
{"commandName":"PSM::HTTP::enable","description":"To enable PSM for HTTP traffic","examples":"when HTTP_REQUEST {\n    PSM::HTTP::disable\n    if { [HTTP::uri] starts_with \"/enforce\" } {\n        PSM::HTTP::enable\n    }\n}","returnValue":""},
{"commandName":"PSM::SMTP::disable","description":"To disable PSM for SMTP traffic","examples":"","returnValue":""},
{"commandName":"PSM::SMTP::enable","description":"To enable PSM for SMTP traffic","examples":"","returnValue":""},
{"commandName":"QOE::disable","description":"This command disables the video QOE filter from processing any video or\nnon-video traffic on a connection basis. It is preferred to disable QOE\nif the connection doesn't contain video with formats like MP4, FLV,\ntheir derivitives, or Apple HLS.\n\n\nQOE::disable","examples":"when HTTP_REQUEST {\n  if {not ([HTTP::uri] contains \"any_video_string\")} {\n    QOE::disable\n  }\n}","returnValue":""},
{"commandName":"QOE::enable","description":"This command enables the video QOE filter and allows processing video\non a connection basis. It is preferred to enable QOE if the connection\ncontains video with formats like MP4, FLV, their derivitives, or Apple\nHLS.\n\n\nQOE::enable","examples":"when HTTP_REQUEST {\n  if {([HTTP::uri] contains \"any_video_string\")} {\n    QOE::enable\n  }\n}","returnValue":""},
{"commandName":"QOE::video","description":"This command returns a set of video QOE attributes from the current\nvideo connection.\n\n\nQOE::video width\n\n     * Returns the video width.\n\nQOE::video height\n\n     * Returns the video height.\n\nQOE::video duration\n\n     * Returns the video duration.\n\nQOE::video available\n\n     * Returns 1 if a valid QOE result can be retrieved and 0 if QOE\n       result is not available for any reasons.\n\nQOE::video framerate\n\n     * Returns the video frame rate.\n\nQOE::video nominal_bitrate\n\n     * Returns the nominal bit rate.\n\nQOE::video average_bitrate\n\n     * Returns teh actual bit rate the client side experiences. When\n       average < nominal, it may indicate a degraded user experience.\n\nQOE::video mos\n\n     * Returns the overall score of the video session based on the network\n       condition and the static video attributes.","examples":"","returnValue":""},
{"commandName":"RADIUS::avp","description":"This command returns or adds/changes/removes RADIUS attribute-value pairs. Radius profile must be applied for access to this command.","examples":"when CLIENT_DATA {\n    persist uie [RADIUS::avp 1]\n    RADIUS::avp replace USER-NAME \"foo\"\n}\n\nThis example sends only START and STOP messages to a AAA complex that can’t handle the full load of accounting updates\n    when CLIENT_DATA {\n        set type [RADIUS::avp 40 integer]\n            switch $type {\n                1 -\n                2 {\n                    if { [active_members radius_test_pool] > 0 } {\n                        pool radius_test_pool\n                    }\n                }\n                default {\n                    drop\n                }\n        }\n    }\nIn Version 11.4.0 vendor specific attribute parsing was introduced, here as an example how to add custom attributes to PEM Session\n    when RULE_INIT {\n        set static::DBG_X 1\n        #http://tools.ietf.org/html/rfc2865\n        #http://tools.ietf.org/html/rfc2866\n        array set static::R_AVP {\n            User_Name   1\n            User_Password   2\n            Framed_IP_Address   8\n            Called_Station_Id   30\n            Calling_Station_Id  31\n        }\n\n        array set static::ACCOUNTINGT_STATUS_T {\n            1   START\n            2   STOP\n            3   INTERIM_UPDATE\n        }\n\n        array set static::RADIUS_CODE {\n            4   ACCOUNTING_REQUEST\n            5   ACCOUNTING_RESPONSE\n        }\n\n        # http://www.3gpp.org/ftp/Specs/archive/29_series/29.061/29061_9b0.zip\n        array set static::3GGP {\n            VENDOR_ID   10415\n            3GPP_IMSI        1\n            3GPP_IMEISV      20\n            3GPP_RAT_Type    21\n            3GPP_User_Location_Info 22\n        }\n    }\n\n    when CLIENT_DATA {\n        set radius_code $static::RADIUS_CODE([RADIUS::code])\n\n        if {$static::DBG_X}{\n            log local0. \"$radius_code from [IP::client_addr]:[UDP::client_port]\"\n        }\n\n        switch $radius_code {\n        ACCOUNTING_REQUEST {\n            set user_name  [RADIUS::avp  $static::R_AVP(User_Name) \"string\"]\n            set framed_ip_address [RADIUS::avp  $static::R_AVP(Framed_IP_Address) ip4 ]\n            set accounting_status_t $static::ACCOUNTINGT_STATUS_T([RADIUS::avp 40 \"integer\"])\n\n            switch $accounting_status_t {\n            START {\n                set msisdn  [RADIUS::avp $static::R_AVP(Calling_Station_Id) \"string\"]\n\n                set imsi [RADIUS::avp 26 \"string\" \\\n                            index 0 \\\n                            vendor-id $static::3GGP(VENDOR_ID) \\\n                            vendor-type $static::3GGP(3GPP_IMSI)]\n\n                set imeisv [RADIUS::avp 26 \"string\" \\\n                            index 0 \\\n                            vendor-id $static::3GGP(VENDOR_ID) \\\n                            vendor-type $static::3GGP(3GPP_IMEISV)]\n\n                set rat_type [scan [RADIUS::avp 26 \"octet\" \\\n                            index 0 \\\n                            vendor-id $static::3GGP(VENDOR_ID) \\\n                            vendor-type $static::3GGP(3GPP_RAT_Type)] \"%c\"]\n\n                binary scan [RADIUS::avp 26 \\\n                            index 0 \\\n                            vendor-id $static::3GGP(VENDOR_ID) \\\n                            vendor-type $static::3GGP(3GPP_User_Location_Info) \\\n                            ] H* 3gpp_user_location_info\n\n                PEM::session create $framed_ip_address \\\n                                    subscriber-id $msisdn \\\n                                    subscriber-type e164 \\\n                                    user-name $user_name \\\n                                    imsi $imsi \\\n                                    imeisv $imeisv \\\n                                    tower-id $3gpp_user_location_info \\\n                                    rat_type $rat_type\n\n                if {$static::DBG_X}{\n                    set msg \"Accounting-Status-Type: $accounting_status_t\"\n                    append msg \" PEM::Session create $framed_ip_address subscriber_id $msisdn\"\n                    append msg \" subscriber_type e164 user_name $user_name\"\n                    append msg \" imsi $imsi tower_id $3gpp_user_location_info\"\n                    append msg \" imeisv $imeisv rat_type $rat_type \"\n                    log local0. $msg\n                }\n            }\n\n            STOP {\n                PEM::session delete $framed_ip_address\n\n                if {$static::DBG_X}{\n                    set msg \"Accounting-Status-Type: $accounting_status_t\"\n                    append msg \" PEM::session delete $framed_ip_address\"\n                    log local0. $msg\n                }\n            }\n\n            INTERIM_UPDATE {\n                set rat_type [scan [RADIUS::avp 26 \"octet\" \\\n                            index 0 \\\n                            vendor_id $static::3GGP(VENDOR_ID) \\\n                            vendor_type $static::3GGP(3GPP_RAT_Type)] \"%c\"]\n\n                PEM::session info attr $framed_ip_address rat_type $rat_type\n\n                if {$static::DBG_X}{\n                    set msg \"Accounting-Status-Type: $accounting_status_t\"\n                    append msg \" PEM::session info attr $framed_ip_address RAT_TYPE $rat_type\"\n                    log local0. $msg\n                }\n            }\n            }\n        }\n        }\n    }\nSee this code when you want to sent a RADIUS Accounting Accept\n    when RULE_INIT {\n        set static::secret \"linus\"\n    }\n    when CLIENT_DATA {\n        # getting base information, see also RFC 2865\n        #0                   1                   2                   3\n        #0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n        #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        #|     Code      |  Identifier   |            Length             |\n        #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        #|                         Authenticator                         |\n        #+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        #|  Attributes ...\n        #+-+-+-+-+-+-+-+-+-+-+-+-+-\n\n        binary scan [UDP::payload] caSa16 code id len req_auth\n            # Checking if Radius Code is 4 Accounting-Request\n        if { $code == 4 } {\n\n        # Accounting-Response will be 5, hardcode it\n        # Accounting Response will be 20 bytes long, hardcode it\n        # creating  ResponseAuth =\n        #  MD5(Code+ID+Length+RequestAuth+Attributes+Secret)\n\n        set res_auth [md5 \"\\x05${id}\\x00\\x14${req_auth}${static::secret}\"]\n        set reply [binary format caSa16 5 $id 20 $res_auth]\n        clientside { UDP::respond ${reply}}\n\n        # Drop the packet since we are not going to send it anywhere\n        # If we would, we would not need to sent a reply, right ?\n        UDP::drop\n        }\n    }","returnValue":"RADIUS::avp attr [attr_type]\n    Returns the value of the specified RADIUS attribute. optional attr_type = ( octet | ip4 | ip6 | integer | string)\n\n\nRADIUS::avp attr [attr_type] [index x] [vendor-id y] [vendor-type z]\n    RADIUS Vendor-Specific attribute\n    Optional attr_type = ( octet | ip4 | ip6 | integer )\n    See example below\n    Introduced in Version 11.4.0\n\n\nRADIUS::avp delete attr\n\n    Deletes the specified RADIUS attribute.\n\n\nRADIUS::avp delete attr [index x] [vendor-id y] [vendor-type z]¶\n\n    Returns the value of the specified RADIUS Vendor-Specific attribute\n    Optional attr_type = ( octet | ip4 | ip6 | integer )\n    See example below\n    Introduced in Version 11.4.0\n\n\nRADIUS::avp insert attr value [attr_type]\n\n    Inserts the specified RADIUS attribute and value. optional attr_type = ( octet | ip4 | ip6 | integer | string)\n\n\nRADIUS::avp replace attr value [attr_type]\n\n    Rewrites the specified RADIUS attribute with new value. optional attr_type = ( octet | ip4 | ip6 | integer | string)\n\n\nThe attr should be supplied as the decimal value 1 to 255 or as the UPPERCASE strings specified in RFC 2865 and RFC 2866 . The optional attr_type indicates how a value should be interpreted. Valid types are octet, string, integer, integer64, ip4, ip6, ip4prefix, and ip6prefix, as defined in RFC 8044. An unknown type is treated as octet."},
{"commandName":"RADIUS::code","description":"This command returns the RADIUS message code","examples":"when CLIENT_ACCEPTED {\n    if { [RADIUS::code] == 4 } {\n        set rd 0\n        # Extract the APN information from the AVP\n        set called_station_id [RADIUS::avp 30 \"string\"]\n        if {$called_station_id == \"station1\"} {\n            set rd 1\n        } elseif {$called_station_id == \"station2\"} {\n            set rd 2\n        }\n        # Overwrite the default route domain value with the new value.\n        RADIUS::rtdom $rd\n    }\n}","returnValue":"returns radius message code."},
{"commandName":"RADIUS::id","description":"This command returns the RADIUS message id","examples":"when CLIENT_ACCEPTED {\n    let msg_id [RADIUS::id]\n    log local0. \"recieved radius message with id $msg_id\"\n}","returnValue":"This command returns the RADIUS message id"},
{"commandName":"RADIUS::rtdom","description":"This command overwrites the default route-domain ID in RADIUS scenario with given value","examples":"when CLIENT_ACCEPTED {\n        if { [RADIUS::code] == 4 } {\n            set rd 0\n            # Extract the APN information from the AVP\n            set called_station_id [RADIUS::avp 30 \"string\"]\n            if {$called_station_id == \"station1\"} {\n                set rd 1\n            } elseif {$called_station_id == \"station2\"} {\n                set rd 2\n            }\n            # Overwrite the default route domain value with the new value.\n            RADIUS::rtdom $rd\n        }\n    }","returnValue":""},
{"commandName":"RADIUS::subscriber","description":"","examples":"","returnValue":""},
{"commandName":"RESOLV::lookup","description":"RESOLV::lookup performs a DNS query, returning one or more addresses (A records) for a hostname, a domain name (PTR record) for an IP address, or optionally one or more values for records of other types. Multiple values are returned as a list, so to obtain a single IP address the construction [lindex [RESOLV::lookup $hostname] 0] may be used.\n\nThe key difference between this command and the older NAME::lookup command is that RESOLV::lookup briefly suspends execution of the current iRule (event) then returns the result inline, whereas NAME::lookup is asynchronous (the current rule continues and eventually another event NAME_RESOLVED fires when the result is available. In each NAME_RESOLVED event you must call NAME::response to obtain the result). RESOLV::lookup is almost always more convenient than the older NAME::lookup function.\n\nBy default RESOLV::lookup queries the BIG-IP's local caching nameserver (bind) which you must configure in advance. If your RESOLV::lookup queries don't seem to work you should adjust your BIG-IP configuration as explained in f5 Solution Note SOL12224.\n\nRESOLV::lookup lets you optionally specify a DNS resolver to query. You may give either a single nameserver's IP address or the name (e.g., /Common/myDNS) of a virtual server which sends DNS queries to some pool of nameservers. You may use this feature to implement external DNS-query-based services such as large real time IP block lists.\n\nBy default, TMM will make up to 4 consecutive query attempts (1 original with 3 retries) with an individual query timeout of 5 seconds. These parameters are globally configurable using these database keys:\n\n    b db tmm.resolv.retry\n    b db tmm.resolv.timeout\n\n    Or via tmsh:\n\n    tmsh modify /sys db tmm.resolv.retry value < value >\n    tmsh modify /sys db tmm.resolv.timeout value < value >","examples":"when CLIENT_ACCEPTED {\n    log local0. \"devcentral.f5.com is currently at IP [RESOLV::lookup @10.10.20.1 \"devcentral.f5.com\"]\"\n}\n\nResults in log entry:\nJan 21 20:21:22 local/tmm info tmm[5018]: Rule resolv_test <CLIENT_ACCEPTED>: devcentral.f5.com is currently at IP 65.61.115.213\n\n\n\n# Select the first returned IP address as the destination IP (inherits the destination port from the client's destination port).\nwhen RULE_INIT {\n    set static::dns_vs my_dns_vs\n}\nwhen CLIENT_ACCEPTED {\n    # Get IP(s) for hostname www.example.com against 4.2.2.1 name server\n    set ips [RESOLV::lookup @$static::dns_vs -a \"www.example.com\"]\n\n    # Log result. If there are multiple IP's it could be a TCL list like {1.1.1.1 2.2.2.2 3.3.3.3}.\n    log local0. \"Looked up www.example.com and found $ips, parsed first element: [lindex $ips 0]\"\n\n    # Check if the first list element was empty\n    if {$ips eq \"\"}{\n        # Input wasn't an IP address, take some default action?\n    } else {\n        # Select the IP\n        node [lindex $ips 0]\n    }\n}","returnValue":"If you send queries to a virtual server using an argument of the form @/Common/myDNS and expect those queries to leave the BIG-IP, ensure that you SNAT traffic via that virtual server so the remote nameservers will have a routable address to send replies to (otherwise the query source address will be one of the BIG-IP's loopback addresses, 127.1.x.y). Either set SNAT Automap or assign a SNAT pool to the virtual server, or add a selective-SNAT iRule which triggers when client IP matches 127.1.0.0/16.\n\nThe [inet|inet6] arguments are most useful when querying non-address records. The -a option (query for type A IPv4-address records) is incompatible with 'inet6' and -aaaa (query for type AAAA IPv6-address records) is incompatible with 'inet'.\n\nThe RESOLV::lookup function will not chase through a chain of CNAME records."},
{},
{"commandName":"REWRITE::disable","description":"Changes the REWRITE plugin from full patching to passthrough mode.\n\nSyntax\n\nREWRITE::disable\n\n     * Changes the rewrite plugin from full patching mode to passthrough\n       mode for the lifetime of the TCP connection or until\n       REWRITE::enable is called.","examples":"when ACCESS_ACL_ALLOWED {\n  set host [HTTP::host]\n}\n\nwhen HTTP_RESPONSE {\n  if {$host == \"www.f5.com\"} {\n    REWRITE::disable\n  }\n  log local0. \"host: $host\"\n}\n\nNote: This only works if there are no references of the form\n   \"/path/file\" that starts with a slash.","returnValue":""},
{"commandName":"REWRITE::enable","description":"Changes the REWRITE plugin from passthrough to full patching mode. A\nplace where this might be helpful would be a POST request where REWRITE\nwould modify the post body unnecessarily, so we disable it. However, we\nwant REWRITE to modify the response, so we would enable it later in the\nHTTP_RESPONSE. Use of this command can be extremely tricky to get\nexactly right; its use is not recommended in the majority of cases\n\nSyntax\n\nREWRITE::enable\n\n     * Change the rewrite plugin from passthrough mode to full patching\n       mode.","examples":"","returnValue":""},
{"commandName":"REWRITE::payload","description":"Queries for or manipulates REWRITE payload (content) information. With\nthis command, you can retrieve content, query for content size, or\nreplace a certain amount of content.\n\nSyntax\n\nREWRITE::payload <length>\n\n     * Returns the entire payload or up to the length in bytes. If you do\n       not specify a size, the system returns the entire collected\n       content.\n\nREWRITE::payload length\n\n     * Returns the size of the content.\n\nREWRITE::payload replace <begin> <length> <string>\n\n     * Replaces the amount of content that you specified with the\n       argument, starting at with , adjusting the Content-Length header\n       appropriately. To clarify, the length argument should be the length\n       of original content to replace.","examples":"when REWRITE_RESPONSE_DONE {\n    # The rewrite_response_done event isn't absolutely necessary because browser will just ignore any html tags that it doesn't recongnize.\n    # However, it will be cleaner if we remove it nevertheless\n\n    set data [REWRITE::payload]\n    # Find the tags we inserted\n    set start [string first {<apm_do_not_touch>} $data]\n    set end [string last {</apm_do_not_touch>} $data]\n    # Determines the amount of characters to remove\n    set length_open [string length {<apm_do_not_touch>}]\n    set length_close [string length {</apm_do_not_touch>}]\n\n    # log local0. \"Starting Index:: $start\"\n    # log local0. \"Ending Index:: $end\"\n\n    # Replace the number of characters taken up by the tags with nothing (e.g. null)\n    REWRITE::payload replace $end $length_close {}\n    REWRITE::payload replace $start $length_open {}\n}","returnValue":""},
{"commandName":"REWRITE::post_process","description":"When REWRITE::post_process is called (without any arguments), it\nwill return a \"0\" to signify that it is off, or an \"1\" to signify that\nit is on. By default, it is off. Use the command \"REWRITE::post_process\n1\" to turn on the post process functionality and \"REWRITE::post_process\n0\" to turn it off. When post_process is on, the\nREWRITE_RESPONSE_DONE event is triggered. Otherwise, the\nREWRITE_RESPONSE_DONE event is ignored.\n\nSyntax\n\nREWRITE::post_process <arg>\n\n     * Triggers the REWRITE_RESPONSE_DONE event. Without the\n       argument, it will return a boolean.","examples":"when REWRITE_REQUEST_DONE {\n  if { \"[HTTP::host][HTTP::path]\" eq \"www.external.com/contents.php\" } {\n    # Found the file we wanted to modify\n    REWRITE::post_process 1\n  }\n}","returnValue":""},
{"commandName":"ROUTE::age","description":"The amount of time that has elapsed since the last update to the\nROUTE::rtt, ROUTE::rttvar and ROUTE::bandwidth\nstatistics for the matched route metric entry.\nROUTE::age has a value of 0 when there are no statistics\navailable.\n\nNote: As of v12.0 ROUTE::age is deprecated, as the expiration time,\nrather than the creation time, is now stored. Since deprecation,\nROUTE::age reports the age assuming that initial timeout was the\nsys db variable route.metrics.timeout. Results are incorrect if\ntimeout was changed by the TCP profile or an iRule.\n\nNote: The return value only applies to the TMM executing the\ncommand. It does not consider cache entries on other TMMs.\n\nSyntax\n\nROUTE::age <destination IP address>\n\n     * The age of the route metrics for the given destination IP address.\n\nROUTE::age <destination IP address> <gateway IP address>\n\n     * The age of the route metrics for the given destination IP address\n       reached through the given gateway.","examples":"when CLIENT_ACCEPTED {\n    log local0. \"Cached age is: [ROUTE::age [IP::remote_addr]]\"\n}\n\nwhen CLIENT_ACCEPTED {\n    set Gateway 10.3.1.11\n       #\n       # assume that $Gateway is the gateway address for [IP::remote_addr]\n       #\n    set age [ROUTE::age [IP::remote_addr] $Gateway]\n    if { $age > 0 } {\n        # There is a cache entry\n        log local0. \"Cached age is: [ROUTE::age [IP::remote_addr] $Gateway]\"\n    }\n}","returnValue":"The age of the route metrics in seconds"},
{"commandName":"ROUTE::bandwidth","description":"Returns a bandwidth estimate for a destination derived from\nentries in the congestion metrics cache.\n\nAs of v12.0, divides the cached congestion window (cwnd) value\nby the cached round-trip-time (RTT ) to obtain a bandwidth\nestimate in kbps. If there is no entry, it returns 0.\n\nNote: The return value only applies to the TMM executing the command.\nIt does not consider cache entries on other TMMs.\n\nSyntax\n\nROUTE::bandwidth <destination IP address>\n\n     * The bandwidth estimate to the given destination IP address.\n\nROUTE::bandwidth <destination IP address> <gateway IP address>\n\n     * The bandwidth estimate to the given destination IP address via\n       the given gateway.","examples":"when CLIENT_ACCEPTED {\n    if { [ROUTE::bandwidth [IP::remote_addr]] > 0 } {\n        log local0. \"cached bandwidth is: [ROUTE::bandwidth [IP::remote_addr]]\"\n    }\n}\n\nwhen CLIENT_ACCEPTED {\n    set Gateway 10.3.1.11\n       # assume that $Gateway is the gateway address for [IP::remote_addr]\n    log local0. \"cached bandwidth is: [ROUTE::bandwidth [IP::remote_addr] $Gateway]\"\n}","returnValue":"The bandwidth estimate to the destination and/or gateway in kbps."},
{"commandName":"ROUTE::clear","description":"Removes the congestion metrics and MTU associated with a\ndestination IP address and/or gateway.\n\nClears the entry on all platform TMMs.","examples":"when CLIENT_ACCEPTED {\n    set bandwidth [ROUTE::bandwidth [IP::remote_addr]]\n    if { $bandwidth > 0 && $bandwidth < 1000 } {\n        # Reject cache entries below 1000 kbps\n        ROUTE::clear [IP::remote_addr]\n    }\n}","returnValue":""},
{"commandName":"ROUTE::cwnd","description":"Returns the cached congestion window (cwnd) value for a given\ndestination IP and/or gateway.\n\nThe return value only applies to the TMM executing the command. It\ndoes not consider cache entries on other TMMs.","examples":"when CLIENT_ACCEPTED {\n    set cwnd [ROUTE::cwnd [IP::remote_addr]]\n    if { $cwnd > 0 } {\n        log local0. \"Destination found in cache. Initializing cwnd to $cwnd\"\n    } else {\n        log local0. \"Destination not found in cache.\"\n    }\n}","returnValue":"The cached congestion window in bytes."},
{"commandName":"ROUTE::domain","description":"Returns the current routing domain of the current connection. Several\ncommands allow an addition rt_domain option: node, snat, LB::status\n\nSyntax\n\nROUTE::domain\n\n     * Returns the current routing domain of the current connection.","examples":"when CLIENT_ACCEPTED {\n    set gateway 10.3.1.11\n    set bandwidth [ROUTE::bandwidth [IP::remote_addr] $gateway%[ROUTE::domain]]\n    if { $bandwidth > 0 } {\n        log local0. \"Destination found in cache, bandwidth = $bandwidth\"\n    }\n}","returnValue":""},
{"commandName":"ROUTE::expiration","description":"Returns the remaining time in seconds. The lifetime of an entry may\nhave been set by the route.metrics.timeout sys db variable, the\ncmetrics-cache-timeout TCP profile attribute, or a\nTCP::rt_metrics_timeout iRule.\n\nThe return value only applies to the TMM executing the command. It\ndoes not consider cache entries on other TMMs.","examples":"when CLIENT_CLOSED {\n    # If the entry almost timed out, keep it a little longer next time.\n    set time_remaining [ROUTE::expiration [IP::remote_addr]]\n    if { $time_remaining > 0 && $time_remaining < 100 } {\n         # Default value is 600\n         TCP::rt_metrics_timeout 700\n    }\n}","returnValue":""},
{"commandName":"ROUTE::mtu","description":"Returns the cached MTU entry for the provided destination and/or gateway.\n\nUnlike other ROUTE::commands, this value is valid across all TMMs.","examples":"when CLIENT_ACCEPTED {\n    set mtu [ROUTE::mtu [IP::remote_addr]]\n    if { $mtu > 0 && $mtu < 300 } {\n        #Ignore extremely small cached MTUs\n        ROUTE::clear [IP::remote_addr]\n    }\n}","returnValue":""},
{"commandName":"ROUTE::rtt","description":"Returns the cached round-trip-time for the destination and/or\ngateway if the relevant TCP profile enables cmetrics-cache.\n\nThe return value only applies to the TMM executing the command. It\ndoes not consider cache entries on other TMMs.\n\nROUTE::rtt returns a value of 0 when there are no statistics available.\n\nNOTE: The returned value is scaled to units of 100ns; to express it\nin the same units as TCP::rtt multiply it by 32/10000.\n\nNOTE: When used with the fastL4 profile, RTT from client/server\nneeds to be enabled and the client and server need to be using TCP\ntimestamps.\n\nSyntax\n\nROUTE::rtt <destination IP address>\n\n     * The cached round-trip estimate for connections to\n       the given destination IP address.\n\nROUTE::rtt <destination IP address> <gateway IP address>\n\n     * The cached round-trip estimate for connections to\n       the given destination IP address reached through the given gateway.","examples":"when CLIENT_ACCEPTED {\n    log local0. \"Cached rtt is: [ROUTE::rtt [IP::remote_addr]]\"\n}\n\nwhen CLIENT_ACCEPTED {\n    set Gateway 10.3.1.11\n       # assume that $Gateway is the gateway address for [IP::remote_addr]\n    log local0. \"Cached rtt is: [ROUTE::rtt [IP::remote_addr] $Gateway]\"\n}","returnValue":"RTT in units of 100ns."},
{"commandName":"ROUTE::rttvar","description":"Returns the cached round-trip-time variance (rttvar) for the\ndestination and/or gateway if the relevant TCP profile enables\ncmetrics-cache.\n\nThe return value only applies to the TMM executing the command. It\ndoes not consider cache entries on other TMMs.\n\nROUTE::rttvar returns a value of 0 when there are no statistics\navailable.\n\nNOTE: The returned value is scaled to units of 100ns; to express it\nin the same units as TCP::rttvar multiply it by 16/10000.\n\nNOTE: When used with the fastL4 profile, RTT from client/server\nneeds to be enabled and the client and server need to be using TCP\ntimestamps.\n\nSyntax\n\nROUTE::rttvar <destination IP address>\n\n     * The cached average variance in smoothed round-trip times for\n       connections to the given destination IP address.\n\nROUTE::rttvar <destination IP address> <gateway IP address>\n\n     * The cached average variance in smoothed round-trip times for\n       connections to the given destination IP address reached through the\n       given gateway.","examples":"when CLIENT_ACCEPTED {\n    log local0. \"Cached rttvar is: [ROUTE::rttvar [IP::remote_addr]]\"\n}\n\nwhen CLIENT_ACCEPTED {\n    set Gateway 10.3.1.11\n       # assume that $Gateway is the gateway address for [IP::remote_addr]\n    log local0. \"Cached rttvar is: [ROUTE::rttvar [IP::remote_addr] $Gateway]\"\n}","returnValue":""},
{"commandName":"RTSP::collect","description":"Collects the amount of data that you specify.\n\nSyntax\n\nRTSP::collect [collect_len]\n\n     * collect_len is the size of data to be collected, optional","examples":"rule xxx {\n    when RTSP_REQUEST {\n        RTSP::collect 10\n    }\n    when RTSP_REQUEST_DATA {\n        RTSP::release\n    }\n}","returnValue":""},
{"commandName":"RTSP::header","description":"Manages headers in RTSP requests and responses.\n\nSyntax\n\nRTSP::header exists <header_name>\n\n     * Returns a value of 0 or 1, indicating whether the specified header\n       is present in the current RTSP request/response. This command is\n       valid in the RTSP_REQUEST and RTSP_RESPONSE events.\n\nRTSP::header insert <header_name> <header_value> ...\n\n     * Inserts one or more headers into the current RTSP request/response.\n       This command accepts either a list of name/value pairs or a single\n       argument that is a TCL list of name/value pairs.\n\nRTSP::header remove <header_name>\n\n     * Removes all instances of the specified header from the current RTSP\n       request/response.\n\nRTSP::header replace <header_name> <value>\n\n     * Removes all instances of the first header, and inserts the second\n       header into the current RTSP request/response.\n\nRTSP::header value <header_name>\n\n     * Returns the value associated with the specified header in the\n       current RTSP request/response. Returns an empty string if the\n       header is not present.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        puts [RTSP::header value \"x-header\"]\n    }\n}","returnValue":""},
{"commandName":"RTSP::method","description":"Returns the method/command (for example, DESCRIBE, PLAY) from the\ncurrent RTSP request.\nSyntax\n\nRTSP::method\n\n     * Returns the method/command (for example, DESCRIBE, PLAY) from the\n       current RTSP request.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        puts [RTSP::method]\n    }\n}","returnValue":"Returns a method/command from the current RTSP request."},
{"commandName":"RTSP::msg_source","description":"Indicates whether the request or response originated from the client or\nthe server. This command returns the string client or server.\n\nSyntax\n\nRTSP::msg_source\n\n     * Indicates whether the request or response originated from the\n       client or the server. This command returns the string client or\n       server.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        puts [RTSP::msg_source]\n    }\n}","returnValue":"Returns the string \"client\" or \"server\"."},
{"commandName":"RTSP::payload","description":"Queries for or replaces content information. With this command, you can\nretrieve content, query for content size, or replace a certain amount\nof content.\n\nSyntax\n\nRTSP::payload [<size>]\n\n     * Returns the content that the RTSP::collect command has collected\n       thus far. If you do not specify a size, the system returns the\n       collected content.\n\nRTSP::payload length\n\n     * Returns the size of the content that the command has collected thus\n       far, not including headers.\n\nRTSP::payload replace <offset> <length> <string>\n\n     * Replaces the amount of content that you specified with the\n       argument, starting at with .","examples":"rule xxx {\n    when RTSP_REQUEST {\n        RTSP::collect\n    }\n    when RTSP_REQUEST_DATA {\n        if {[RTSP::payload length] > 10 } {\n            RTSP::release\n        }\n    }\n}","returnValue":""},
{"commandName":"RTSP::release","description":"Releases the collected data. Unless a subsequent RTSP::collect command\nwas issued, there is no need to use the RTSP::release command inside of\nthe RTSP_REQUEST_DATA and RTSP_RESPONSE_DATA events, since in these\ncases, the data is implicitly released.\n\nSyntax\n\nRTSP::release\n\n     * Releases the collected data.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        RTSP::collect\n    }\n    when RTSP_REQUEST_DATA {\n        if {[RTSP::payload length] > 10 } {\n            RTSP::release\n        }\n    }\n}","returnValue":""},
{"commandName":"RTSP::respond","description":"Sends an RTSP response to the client. The return value of the\nRTSP::msg_source command must be client. When an iRule responds to an\nRTSP request, the RTSP filter performs no further processing on the\nrequest and will not send the RTSP request to the server.\nA maximum of one response is allowed per RTSP request.\n\nSyntax\n\nRTSP::respond <status code> <status string> [<headers/body>]\n\n     * The status code and status string are placed in the first line of\n       the RTSP response. The status code must be a positive integer\n       value.\n       The headers argument is optional and must be a single string\n       value which can contain multiple formatted headers. The header\n       argument can also contain a body. The headers and body must conform\n       to the RTSP header/body format defined in RFC2326 (the rule\n       command does not validate the format). The RTSP CSeq header is\n       automatically added by the RTSP filter.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        RTSP::respond 401 Unauthorized \"x-header\\r\\n\\r\\n  Hey, you need a password\"\n    }\n}","returnValue":""},
{"commandName":"RTSP::status","description":"Returns the HTTP style status code (for example, 200 or 401) from the\ncurrent RTSP response.\n\nSyntax\n\nRTSP::status\n\n     * Returns the HTTP style status code (for example, 200 or 401)\n       from the current RTSP response.","examples":"rule xxx {\n    when RTSP_RESPONSE {\n        puts [RTSP::status]\n    }\n}","returnValue":"Returns the HTTP style status code from the current RTSP response."},
{"commandName":"RTSP::uri","description":"Returns the complete URI of the RTSP request.\n\nSyntax\n\nRTSP::uri\n\n     * Returns the complete URI of the RTSP request.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        puts [RTSP::uri]\n    }\n}","returnValue":"Returns the complete URI of the RTSP request."},
{"commandName":"RTSP::version","description":"Returns the version (for example, RTSP/1.0) in the current RTSP\nrequest/response. You can use this command to determine if RTSP is\nbeing tunneled over HTTP on the RTSP port (the version would be an HTTP\nversion). The command is valid in the RTSP_REQUEST and RTSP_RESPONSE\nevents.\n\nSyntax\n\nRTSP::version\n\n     * Returns the version (for example, RTSP/1.0) in the current RTSP\n       request/response.","examples":"rule xxx {\n    when RTSP_REQUEST {\n        puts [RTSP::version]\n    }\n}","returnValue":"Returns the version in the current RTSP request/response."},
{"commandName":"SCTP::mss","description":"Returns the on-wire Maximum Segment Size (MSS) for an SCTP connection.","examples":"when CLIENT_ACCEPTED {\n        SCTP::collect\n        log local0.info \"Sctp local port is [SCTP::local_port]\"\n        log local0.info \"Sctp client port is [SCTP::client_port]\"\n        log local0.info \"Sctp mss is [SCTP::mss]\"\n        log local0.info \"sctp ppi is [SCTP::ppi]\"\n}","returnValue":""},
{"commandName":"SCTP::ppi","description":"Returns or sets the SCTP payload protocol indicator.","examples":"when CLIENT_ACCEPTED {\n        SCTP::collect\n        log local0.info \"Sctp local port is [SCTP::local_port]\"\n        log local0.info \"Sctp client port is [SCTP::client_port]\"\n        log local0.info \"Sctp mss is [SCTP::mss]\"\n        log local0.info \"sctp ppi is [SCTP::ppi]\"\n}","returnValue":""},
{"commandName":"SCTP::collect","description":"Causes SCTP to start collecting the specified amount of content data. After collecting the data, event CLIENT_DATA will be triggered.\n\nSCTP::collect <length>\n    Causes SCTP to start collecting the specified amount of content data. The parameter specifies the minimum number of bytes to collect.\n\nSCTP::collect\n    When length is not specified, CLIENT_DATA will be triggered for every received packet. To stop collecting data, use SCTP::release.","examples":"1)\nwhen CLIENT_ACCEPTED {\n  SCTP::collect 15\n}\nwhen CLIENT_DATA {\n  if { [SCTP::payload 15] contains \"XYZ\" } {\n     pool xyz_servers\n  } else {\n     pool web_servers\n }\n SCTP::release\n}\n\n2)\nwhen CLIENT_ACCEPTED {\n   log local0.debug \"CLIENT_ACCEPTED\"\n   SCTP::collect\n}\nwhen CLIENT_DATA {\n   set tcplen [SCTP::payload length]\n   log local0.debug \"CLIENT_DATA ($tcplen)\"\n\n   #Assume that you need at least 20 bytes of data for some purpose\n   if { $tcplen >= 20 } {\n     log local0.debug \"Collected at least 20 bytes. releasing\"\n     #Release collected data\n     SCTP::release\n     # Collect new data - CLIENT_DATA will be called again\n     SCTP::collect\n  }\n}","returnValue":""},
{"commandName":"SCTP::release","description":"Causes SCTP to resume processing the connection and flush collected data.","examples":"when CLIENT_ACCEPTED {\n  SCTP::collect 15\n}\nwhen CLIENT_DATA {\n  if { [SCTP::payload 15] contains \"XYZ\" } {\n     pool xyz_servers\n  } else {\n     pool web_servers\n }\n SCTP::release\n}","returnValue":""},
{"commandName":"SCTP::payload","description":"Returns the accumulated SCTP data content, or replaces collected payload with the specified data.\n\nSCTP::payload [<number_of_bytes>]\n    Returns the accumulated SCTP payload data content upto size bytes if provided.\n\nSCTP::payload <offset> <number_of_bytes>\n    Returns upto number_of_bytes bytes of the accumulated SCTP payload data content starting from the offset provided.\n\nSCTP::payload replace <offset> <length> <data>\n    Replaces collected payload data with the given data, starting at offset.\n\nSCTP::payload length\n    Returns the amount of accumulated SCTP data content in bytes.\n\nSCTP::payload sid\n    Returns the stream id.\n\nSCTP::payload ppi\n    Returns the protocol payload identification.\n\nSCTP::unordered <boolean>\n    Returns or sets the value of the unordered delivery flag.\nSCTP::payload replace <offset> <length> <data>\n    Replaces collected payload data with the given data, starting at offset.\n\nSCTP::payload insert <offset> <data>\n    Insert data at offset in payload.\n\nSCTP::payload delete <offset> <len>\n    Delete payload starting at offset for length, len.","examples":"when CLIENT_ACCEPTED {\n  SCTP::collect 15\n}\nwhen CLIENT_DATA {\n  if { [SCTP::payload 15] contains \"XYZ\" } {\n     pool xyz_servers\n  } else {\n     pool web_servers\n }\n SCTP::release\n}","returnValue":""},
{"commandName":"SCTP::respond","description":"Sends the specified data directly to the peer. This command is used to complete a protocol handshake with an iRule.","examples":"when CLIENT_ACCEPTED {\n    SCTP::respond \"sctpdata\" 0 1\n}","returnValue":""},
{"commandName":"SCTP::client_port","description":"Returns the SCTP port/service number of the specified client. This command is equivalent to the command clientside { SCTP::remote_port }.\n\nSCTP::client_port\n    Returns the SCTP port/service number of the specified client.","examples":"when CLIENT_ACCEPTED {\n    if { [SCTP::client_port] > 1000 } {\n        pool slow_pool\n     }\n      else {\n         pool fast_pool\n       }\n}","returnValue":""},
{"commandName":"SCTP::server_port","description":"Returns the SCTP port/service number of the specified server. This command is equivalent to the command serverside { SCTP::remote_port }.\n\nSCTP::server_port\n    Returns the SCTP port/service number of the specified server.","examples":"when SERVER_CONNECTED {\n    if { [SCTP::server_port] > 1000 } {\n        pool slow_pool\n     }\n      else {\n         pool fast_pool\n       }\n}","returnValue":""},
{"commandName":"SCTP::local_port","description":"Returns the local SCTP port/service number. Can specify the port value on clientside or serverside.","examples":"when CLIENT_ACCEPTED {\n        SCTP::collect\n        log local0.info \"Sctp local port is [SCTP::local_port]\"\n        log local0.info \"Sctp client port is [SCTP::client_port]\"\n        log local0.info \"Sctp mss is [SCTP::mss]\"\n        log local0.info \"sctp ppi is [SCTP::ppi]\"\n}","returnValue":""},
{"commandName":"SCTP::remote_port","description":"Returns the remote SCTP port/service number. Can specify the port value on clientside or serverside.","examples":"when CLIENT_ACCEPTED {\n    SCTP::remote_port\n    set x [SCTP::remote_port]\n    SCTP::remote_port clientside\n    SCTP::remote_port serverside\n    SCTP::remote_port client\n    SCTP::remote_port server\n}","returnValue":""},
{"commandName":"SDP::field","description":"This command will get or set the value of a specific SDP field\n\nSyntax\n\nSDP::field field-name <index>\n\n     * Get SDP field \"field-name\" at position index, if index is not\n       present, the first field \"field-name\" will be returned if found\n\nSDP::field field-name <index> \"new value\"\n\n     * Sets SDP field \"field-name\" at position index with user defined\n      \"new value\"","examples":"when SIP_REQUEST {\n    log local0. \"SDP field b: [SDP::field b]\"\n    SDP::field c 0 \"IN IP4 10.10.1.150\"\n}","returnValue":""},
{"commandName":"SDP::media","description":"This command allows you to get or set different aspects of the media\ninformation for your SDP connection.\n\nSyntax\n\nSDP::media attr <media-index> <attr-index>\n\n     * Get SDP attribute attr-index of media media-index e.g. SDP::media\n       attr 0 1 will get SDP attribute 1 of media 0\n\nSDP::media count\n\n     * Return the number of medias\n\nSDP::media <media-index>\n\n     * Get SDP media at index media-index\n\nSDP::media type <media-index>\n\n     * Get SDP media type of media media-index\n\nSDP::media port <media-index>\n\n     * Get SDP media port of media media-index\n\nSDP::media port <media-index> \"new value\"\n\n     * Rewrite SDP media port of media media-index\n\nSDP::media transport <media-index>\n\n     * Get SDP media transport info of media media-index (e.g. RTP/AVP)\n\nSDP::media conn <media-index>\n\n     * Get SDP media connection info of media media-index if its\n       available, else gets connection info of session.\n\nSDP::media conn <media-index> \"new value\"\n\n     * Rewrite SDP media connection info of media media-index","examples":"when SIP_REQUEST {\n    log local0. \"SDP media count: [SDP::media count]\"\n    log local0. \"SDP media transport: [SDP::media transport 0]\"\n    log local0. \"SDP media port: [SDP::media port 0]\"\n    log local0. \"SDP media connection: [SDP::media conn 0]\"\n}","returnValue":""},
{"commandName":"SDP::session_id","description":"This command allows you to get SDP session id for the current\nconnection\n\nSyntax\n\nSDP::session_id\n\n     * Returns the value of the SDP session id","examples":"when SIP_RESPONSE {\n    log local0. \"SDP SessionID: [SDP::session_id]\"\n}","returnValue":"Returns the value of the SDP session id."},
{"commandName":"SIP::call_id","description":"Returns the value of the Call-ID header in a SIP request. Only the\nfirst 256 bytes of the Call-ID will be returned.\n\nSyntax\n\nSIP::call_id\n\n     * Returns the value of the Call-ID header in a SIP request.","examples":"when SIP_REQUEST_SEND {\n    log local0. \"Call ID [SIP::call_id]\"\n}","returnValue":"Returns the value of the Call-ID header in a SIP request"},
{"commandName":"SIP::discard","description":"Discards a SIP message\n\nSIP::discard\n\n     * Discards the current SIP message","examples":"when SIP_RESPONSE {\n  SIP::discard\n}","returnValue":""},
{"commandName":"SIP::from","description":"Returns the value of the From header in a SIP request.\n\nSyntax\n\nSIP::from\n\n     * Returns the value of the From header in a SIP request.","examples":"when SIP_REQUEST {\n    log local0. \"SIP Protocol - REQUEST: Values From & To\"\n    log local0. \"From: [SIP::from] To: [SIP::to]\"\n}","returnValue":"Returns the value of the From header in a SIP request"},
{"commandName":"SIP::header","description":"This set of commands allows you to get or set information in the SIP\nheader.\n\nNote: These commands still work on MBLB (Message Based Load\nBalancing) SIP post 11.6+, but there are new commands that only\nrun on MRF (Message Routing Framework) SIP and were introduced\nin 11.6.\n\nSyntax\n\nSIP::header \"header-name\" <index>\n\n     * Get SIP header \"header-name\", if index is not provided, the first\n       match is returned.\n\nSIP::header value \"header-name\" <index>\n\n     * Same as above, \"value\" is optional.\n\nSIP::header remove \"header-name\" <index>\n\n     * Remove SIP header \"header-name\", index can be used to indicate\n       which header is in action if there are multiple of them\n\nSIP::header insert \"header-name\" \"header-value\" <index>\n\n     * Insert SIP header-name: header-value pair at position index, if\n       index is not given, it will be inserted prior to any pre-existing\n       (same) headers. If no such header, via header will be inserted at\n       the head of SIP headers, others will be inserted at the tail.\n\nSIP::header count [header-name]\n\n     * Returns the count of the SIP headers. If \"header-name\" is specified\n       count the specific headers.\n       This is an MRF SIP (sipsession profile) command for v11.6+\n\nSIP::header exists \"header-name\"\n\n     * Returns whether SIP header specified by name exists at least once.\n       This is an MRF SIP (sipsession profile) command for v11.6+\n\nSIP::header values [header-name]\n\n     * Returns list of the values of all the instances of SIP header\n       values. If optional argument header-name is specified retrieve\n       all values of the specified header-name.\n       This is an MRF SIP (sipsession profile) command for v11.6+\n\nSIP::header at \"index\"\n\n     * Returns SIP header at \"index\", index is the Nth line from the SIP\n       header. Returns only the name of the header.\n       This is an MRF SIP (sipsession profile) command for v11.6+\n\nSIP::header replace \"header-name\" \"header-value\" [index]\n\n     * Replaces first instance of the header specified by \"header-name\".\n       New entry is added if not present already. If index optional\n       argument is present, replace the header name at indexth\n       position.\n       This is an MRF SIP (sipsession profile) command for v11.6+\n\nSIP::header names\n\n     * Returns list of all the SIP header names.\n       This is an MRF SIP (sipsession profile) command for v11.6+","examples":"when SIP_REQUEST_SEND {\n  log local0. [SIP::method]\n  SIP::header insert Via [format \"SIP/2.0/TCP %s:%s\" [IP::local_addr] [TCP::local_port]]\n  SIP::header insert Y-Header \"it is yyy\"\n}","returnValue":""},
{"commandName":"SIP::method","description":"Returns the type of SIP request method.\n\nSIP::method\n\n     * Returns the type of SIP request method.","examples":"when SIP_REQUEST {\n  log local0. [SIP::uri]\n  log local0. [SIP::header Via 0]\n  if {[SIP::method] == \"INVITE\"} {\n    SIP::respond 401 \"no way\" X-Header \"xxx here\"\n  }\n}","returnValue":"Returns the type of SIP request method"},
{"commandName":"SIP::payload","description":"Returns the accumulated SIP data content.\n\nSyntax\n\nSIP::payload\n\n     * Returns the SIP data accumulated so far","examples":"when SIP_REQUEST {\n    log local0. \"unmodified request [SIP::payload]\"\n}\nwhen SIP_REQUEST_SEND {\n    log local0. \"modified request [SIP::payload]\"\n}","returnValue":"Returns the SIP data accumulated so far"},
{"commandName":"SIP::persist","description":"The SIP::persist command returns the persistence key being used for the\ncurrent message. If new-persist-key is provided, the existing\npersistence key is replaced. The value of the new-persist-key MUST be\none of valid header value in the message. A header name should not be\ngiven as the new-persist-key value.\nOnly valid for MRF SIP (sipsession profile) in 11.6+\n\nSyntax\n\nSIP::persist [new-persist-key]\n        \nGets the persistence key for the current message.\n            \nClear any persistence record stored under the current message's persistence key.\n            \nUse the current persistence record for routing the message if present. If not present, route the message using the route table. On completion of routing, add a new persistence record if one does not exist. If an existing persistence record exists, replace the message's selected route with the destination stored in the persistence entry.\n            \nRoute the message using the route table. On completion of routing, add a new persistence record if one does not exist. If an existing persistence record exists, replace the persistence record with the route selected.\n            \nRoute the message using the route table. On completion of routing, add a new persistence record if one does not exist. If an existing persistence record exists, it will be left unchanged.\n            \nRoute the message using the route table. The results of the routing will not be stored in the persistence table.\n            \nSets or gets the persistence key timeout value. Modifying the persistence key timeout outside of SIP_REQUEST or MR_INGRESS event has no effect on the persistence key timeout.\n            \nSets of gets the persistence keys bidirectional persistence flag.\n            \nSets the persistence key for the current message. Modifying the persistence key\noutside of SIP_REQUEST or MR_INGRESS event has no effect of the persistence\nrecord used or modified when routing.\n            \nSets the persistence key and if the second argument is present, its value set the persistence key timeout value. Modifying the persistence key outside of SIP_REQUEST or MR_INGRESS event has no effect of the persistence record used or modified when routing.","examples":"when SIP_REQUEST {\n                SIP::persist \"[SIP::uri]-[SIP::from]-[SIP::to]\"\n            }","returnValue":""},
{"commandName":"SIP::respond","description":"This command allows you to terminate a SIP request and send a custom\nformatted response directly from the iRule.\n\nSyntax\n\nSIP::respond code <\"phrase\" <\"header-name\" \"header-value\"> >\n\n     * Terminate current SIP request, send back a response with code,\n       phrase and header-name header-value pairs","examples":"when SIP_REQUEST {\n  log local0. [SIP::uri]\n  log local0. [SIP::header Via 0]\n  if {[SIP::method] == \"INVITE\"} {\n    SIP::respond 401 \"no way\" X-Header \"xxx here\"\n  }\n}","returnValue":""},
{"commandName":"SIP::response","description":"These commands allow you to get or rewrite the SIP response code or\nphrase.\n\nSyntax\n\nSIP::response code\n\n     * Get SIP response code, e.g. 200\n\nSIP::response phrase\n\n     * Get SIP response phrase reason, e.g. \"Ok\"\n\nSIP::response rewrite code <phrase>\n\n     * Rewrite the response code and phrase (if provided)","examples":"when SIP_RESPONSE {\n  log local0. [SIP::via 0]\n  SIP::header remove Via 0\n  SIP::response rewrite 123 \"no xxx\"\n}","returnValue":""},
{"commandName":"SIP::route_status","description":"The SIP::route_status command returns the routing status of the current\nmessage. Valid status are:\n  * \"unprocessed\"\n  * \"route found\"\n  * \"no route found\"\n  * \"dropped\"\n  * \"queue full\"\n  * \"no connection\"\n  * \"connection closing\"\n  * \"internal error\"\n\n\"route found\" is based on the SIP RouteTable finding a route. It is not\neffected by the proxy’s ability to create a connection, so even if the\nserver is not listening on the specified address or marked down, it\nmight still return status as \"route found\" if the RouteTable is able to\nfind the route.\nOnly valid for MRF SIP (sipsession profile) in 11.6+\n\nSyntax\n\nSIP::route_status","examples":"when SIP_RESPONSE_SEND {\n  log local0. [SIP::route_status]\n}","returnValue":"Returns routing status of the current message"},
{"commandName":"SIP::message","description":"The SIP::message command returns full content of the SIP request\nor response message.\n\nSyntax\n\nSIP::message","examples":"when SIP_REQUEST {\n  log local0. [SIP::message]\n}","returnValue":"Returns content of the current message"},
{"commandName":"SIP::to","description":"Returns the value of the To header in a SIP request.\n\nSyntax\n\nSIP::to\n\n     * Returns the value of the To header in a SIP request.","examples":"when SIP_REQUEST {\n    log local0.info \"[SIP::to]\"\n}","returnValue":""},
{"commandName":"SIP::uri","description":"Returns or sets the complete URI of the request.\n\nSyntax\n\nSIP::uri\n\n     * Returns the complete URI of the request.\n\nSIP::uri <string>\n\n     * Sets the URI to string.\n\n       Note: The ability to set the SIP uri was added in 9.4.0.","examples":"when SIP_REQUEST {\n  log local0. \"uri: [SIP::uri] via [SIP::header Via 0]\"\n}\n\nwhen SIP_REQUEST {\n   # Check if URI contains xyz.com\n   if {    [SIP::uri] contains \"xyz.com\" }{\n\n      # Replace xyz.com with the VIP address\n      SIP::uri [string map \"xyz.com [IP::local_addr]\" [SIP::uri]]\n   }\n}","returnValue":""},
{"commandName":"SIP::via","description":"This set of commands allows you to get information in the SIP via header.\n\nSyntax\n\nSIP::via <index>\n\n     * Get SIP header \"via\" at index\n\nSIP::via proto <index>\n\n     * Get protocol part of SIP via at index, if index is not provided,\n       the first one is returned.\n\nSIP::via sent_by <index>\n\n     * Get sent_by part of SIP via at index, if index is not provided, the\n       first one is returned.\n\nSIP::via received <index>\n\n     * Get attribute received of SIP via at index, if index is not\n       provided, the first one is returned.\n\nSIP::via branch <index>\n\n     * Get attribute branch of SIP via at index, if index is not provided,\n       the first one is returned.\n\nSIP::via maddr <index>\n\n     * Get attribute maddr of SIP via at index, if index is not provided,\n       the first one is returned.\n\nSIP::via ttl <index>\n\n     * Get attribute ttl of SIP via at index, if index is not provided,\n       the first one is returned.","examples":"when SIP_RESPONSE {\n  log local0. [SIP::via 0]\n  SIP::header remove Via 0\n  SIP::response rewrite 123 \"no xxx\"\n}","returnValue":""},
{"commandName":"SMTPS::disable","description":"Disable SMTPS (STARTTLS for SMTP)","examples":"when CLIENT_ACCEPTED {\n                if { !([IP::addr [IP::client_addr] equals 10.0.0.0/8]) } {\n                    SMTPS::disable\n                }\n            }","returnValue":""},
{"commandName":"SMTPS::enable","description":"Enable SMTPS (STARTTLS for SMTP)","examples":"when CLIENT_ACCEPTED {\n                if { ([IP::addr [IP::client_addr] equals 10.0.0.0/8]) } {\n                    SMTPS::enable\n                }\n            }","returnValue":""},
{"commandName":"SOCKS::allowed","description":"This command allows you to reject a SOCKS request during the SOCKS_REQUEST event.\n\nDetails (Syntax):\nSOCKS::allowed '0' | '1'\n    Sets the state of SOCKS based on the Boolean value.","examples":"# Reject all SOCKS requests:\nwhen SOCKS_REQUEST {\n    SOCKS::allowed 0\n}","returnValue":""},
{"commandName":"SOCKS::destination","description":"This command allows you to get or set the SOCKS host or port, individually, or both at the same time.\n\nDetails (Syntax):\nSOCKS::destination \"hostname:port\"\n    Sets the destination to the given hostname and port tuple.\n\nSOCKS::destination\n    Gets the destination in the format \"hostname:port\".\n\nSOCKS::destination host \"hostname\"\n    Sets the destination to the given hostname, doesn't change the port.\nSOCKS::destination host\n    Gets the destination hostname.  (Without appending the port.)\n\nSOCKS::destination port \"port_number\"\n    Sets the destination port, doesn't change the hostname.\n\nSOCKS::destination port\n    Gets the destination port.","examples":"when SOCKS_REQUEST {\n    SOCKS::destination example.com:1234\n}","returnValue":""},
{"commandName":"SOCKS::version","description":"This command gets the version of the SOCKS protocol, returning one of \"4\", \"4A\" or \"5\".\n\nDetails (Syntax):\nSOCKS::version\n    Gets the version of the protocol.","examples":"when SOCKS_REQUEST {\n    log local0. \"SOCKS is using version [SOCKS::version]\"\n}","returnValue":""},
{},
{},
{},
{},
{},
{},
{},
{},
{"commandName":"SSL::authenticate","description":"Overrides the current setting for authentication frequency or for the maximum depth of certificate chain traversal.\n\nSSL::authenticate <\"once\" | \"always\">\n    Valid in a client-side context only, this command overrides the client-side SSL connection’s current setting regarding authentication frequency.\n\nSSL::authenticate depth <number>\n    When the system evaluates the command in a client-side context, the command overrides the client-side SSL connection’s current setting regarding maximum certificate chain traversal depth.\n    When the system evaluates the command in a server-side context, the command overrides the server-side SSL connection’s current setting regarding maximum certificate chain traversal depth.","examples":"when CLIENT_ACCEPTED {\n    set session_flag 0\n}\nwhen CLIENTSSL_HANDSHAKE {\n    if { [SSL::cert count] != 0 } {\n        log \"Client cert is OK; releasing HTTP request.\"\n        HTTP::release\n    }\n}\nwhen HTTP_REQUEST {\n    if { [HTTP::uri] starts_with \"/secure/\" } {\n        log \"Certificate required for: [HTTP::uri]\"\n        if { [SSL::cert count] == 0} {\n            log \"No cert found. Holding HTTP request until a client cert is presented...\"\n        HTTP::collect\n            set session_flag 1\n            SSL::authenticate always\n            SSL::authenticate depth 9\n            SSL::cert mode require\n            SSL::renegotiate\n        }\n    }\n    else {\n        log \"No certificate needed for: [HTTP::uri]\"\n    }\n}","returnValue":""},
{"commandName":"SSL::cert","description":"Returns data about an X509 SSL certificate, or sets the certificate mode.","examples":"# v10.1 or higher\n# Redirect any client HTTP request with no client certificate or with a cert which is not correctly\n# validated against the trusted root certificate specified in the client SSL profile.\nwhen HTTP_REQUEST {\n    # Check if there is more than one client cert\n    if {[SSL::cert count] > 0}{\n\n        # Check if there was no error in validating the client cert against LTM's server cert\n        if { [SSL::verify_result] == 0 }{\n\n            # Exit this event in this iRule\n            return\n        } else {\n            # Use the SSL status code in the HTTP response (defined here: http://www.openssl.org/docs/apps/verify.html#DIAGNOSTICS)\n            set error_string [X509::verify_cert_error_string [SSL::verify_result]]\n        }\n    } else {\n        set error_string \"No client certificate provided\"\n    }\n    # If we are still executing this iRule, the client did not present a cert or did not present a valid cert\n    HTTP::respond 403 content \"<html>Invalid client certificate: $error_string</html>\"\n}\n\nwhen RULE_INIT {\n    set ::key [AES::key 128]\n}\nwhen CLIENTSSL_CLIENTCERT {\n    session add ssl [SSL::sessionid] [SSL::cert 0] 180\n}\nwhen HTTP_REQUEST {\n    if {! [HTTP::cookie exists EncClientCert]} {\n        if { [SSL::cert count] < 1 } {\n            HTTP::redirect \"http://errorpage.example.com/\"\n            return\n        }\n        set id [SSL::sessionid]\n        if { $id eq \"\" } {\n            reject\n            return\n        } else {\n            set cert [session lookup ssl $id]\n        }\n        if { $cert eq \"\" } {\n            reject\n            return\n        }\n        session delete ssl $id\n        set enccert [b64encode [AES::encrypt $::key $cert]]\n    } else {\n        set cert [AES::decrypt $::key [b64decode [HTTP::cookie EncClientCert]]]\n    }\n    HTTP::header insert ClientCert [b64encode $cert]\n}\nwhen HTTP_RESPONSE {\n    if { [info exists enccert ]} {\n        HTTP::header insert \"Set-Cookie EncClientCert=$enccert\"\n    }\n}","returnValue":"SSL::cert <index>\n    Returns the X509 SSL certificate at the specified index in the peer certificate chain, where index is a value greater than or equal to zero. A value of zero denotes the first certificate in the chain, a value of one denotes the next, and so on. This command is currently applicable only under a client-side context and returns an error within a server-side context.\n\nSSL::cert issuer <index>\n    Returns the issuer certificate of the index of the X509 SSL certificate in the peer certificate chain, where index is a value greater than or equal to zero. A value of zero denotes the first certificate in the chain, a value of one denotes the next, and so on. This command is currently applicable only under a client-side context and returns an error within a server-side context.\n\nSSL::cert count\n    Returns the total number of certificates that the peer has offered.\n\nSSL::cert mode\n    This command has different results depending on whether the system evaluates the command under a client-side or server-side context. When the system evaluates the command under a client-side context, the command overrides the client-side SSL connection’s current setting regarding client certificates. When the system evaluates the command under a server-side context, the command overrides the server-side SSL connection’s current setting regarding server certificates. Only the require and ignore arguments are valid in a server-side context.\n\nNote: As of 10.1.0, as described in CR116806, the following iRule commands now apply to the lifetime of the SSL session, and not only for the connection in which the system receives the client certificate:\n\n    SSL::cert\n    SSL::cert issuer\n    SSL::cert count\n\nWith this change, the system stores the received peer certificate in the SSL session table, so the certificate is available to the specified iRule commands as long as the SSL session is valid. In previous releases, the CLIENTSSL_CLIENTCERT iRule event retrieved the peer certificate; now the stored certificate can also be retrieved inside the HTTP_REQUEST event."},
{"commandName":"SSL::cipher","description":"Returns an SSL cipher name, its version, and the number of secret bits used.","examples":"when HTTP_REQUEST {\n    # Check encryption strength\n    if { [SSL::cipher bits] >= 128 } {\n        pool web_servers\n    } else {\n        # Client is using a weak cipher\n        # Use one of the destination commands\n\n        # Either specify a pool\n        pool sorry_servers\n\n        # or to a specific node\n        node 10.10.10.10\n\n        # or send a 302 response to redirect to a specific URL\n        # Set cache control headers to prevent proxies from caching the response.\n        HTTP::respond 302 Location \"http://some_address/sorry.html\" Cache-Control No-Cache Pragma No-Cache\n    }\n}","returnValue":"SSL::cipher name\n    Returns the current SSL cipher name using the format of the L<OpenSSL SSL_CIPHER_get_name() function|https://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html> (e.g. \"EDH-RSA-DES-CBC3-SHA\" or \"RC4-MD5\").\n\n\nSSL::cipher version\n    Returns the current SSL cipher version using the format of the L<OpenSSL SSL_CIPHER_get_version() function|https://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html> (e.g. \"SSLv2\", \"SSLv3\", \"TLSv1\", \"TLSv1.1\", \"TLSv1.2\").\n\n\nSSL::cipher bits\n    Returns the number of secret bits that the current SSL cipher used, using the format of the L<OpenSSL SSL_CIPHER_get_bits() function|http://www.openssl.org/docs/ssl/SSL_CIPHER_get_name.html> (e.g. 256, 128 or 40)."},
{"commandName":"SSL::collect","description":"Starts the collection of plaintext data either indefinitely or for the specified amount of data. On successful collection, the corresponding data event is triggered. For clientside collection, the CLIENTSSL_DATA event is triggered. For serverside collection, the SERVERSSL_DATA event is triggered.","examples":"when CLIENTSSL_HANDSHAKE {\n    log local0. \"[IP::client_addr]:[TCP::client_port]: SSL handshake completed, collecting SSL payload\"\n    SSL::collect\n}\nwhen CLIENTSSL_DATA {\n    log local0. \"[IP::client_addr]:[TCP::client_port]: Collected bytes [SSL::payload length], releasing payload\"\n    log local0. \"\\[SSL::payload\\]: [SSL::payload]\"\n    SSL::release\n}\n\n\nwhen SERVERSSL_HANDSHAKE {\n    SSL::collect\n}\nwhen SERVERSSL_DATA {\n    set payload [SSL::payload]\n}","returnValue":"SSL::collect [<length>]\n    Starts the collection of plaintext data either indefinitely or for the specified amount of data.\n    When is specified, the data event will not be triggered until that length has been collected."},
{"commandName":"SSL::enable","description":"Re-enables SSL processing.\n\nNote that the proper use of this command is highly protocol dependent and not recommended in the majority of cases. To selectively enable SSL processing, you should instead use an ssl profile and then use SSL::disable to selectively disable SSL processing.\n\nIf a server-side connection is already established, this command will immediately cause the system to generate a Client Hello to a server, even if an iRule subsequently invokes SSL::disable serverside. That is, the command synchronously enables the Server SSL profile, instead of waiting until the end of the current iRule event execution.","examples":"when CLIENT_ACCEPTED {\n    if { !([IP::addr [IP::client_addr] eq 10.0.0.0/8]) } {\n        SSL::enable\n        TCP::release\n        set sslenable 0\n    }\n}","returnValue":"SSL::enable [clientside | serverside]\n    Re-enables SSL processing on one side of the LTM.\n    serverside parameter may optionally be specified to indicate the context in which SSL will be enabled. By default, it will be enabled in the current context (i.e., running \"SSL::enable\" in a clientside event with no context parameter specified will enable clientside SSL)."},
{"commandName":"SSL::disable","description":"Disables SSL processing. This command is useful when using a virtual server that services both SSL and non-SSL traffic, or when you want to selectively re-encrypt traffic to pool members.\n\nNote: Disabling SSL on the serverside only applies before serverside connection has been established (SERVER_CONNECTED) or when the clientside of the connection is in a detached state (e.g., oneconnect, LB::detach).","examples":"when CLIENT_ACCEPTED {\n    if { [TCP::local_port] == 80 } {\n        SSL::disable\n        pool myPool\n    } elseif { [TCP::local_port] == 443 } {\n        pool myPool\n    } else {\n        discard\n    }\n}\n\nwhen HTTP_REQUEST {\n    set usessl 0\n    if { [string tolower [HTTP::uri]] starts_with \"/secure\" } {\n        pool ssl__pool\n        set usessl 1\n    } else {\n        pool static_pool\n        set usessl 0\n    }\n}\nwhen SERVER_CONNECTED {\n    if { $usessl == 0 } {\n        SSL::disable\n    }\n}\n\nwhen HTTP_REQUEST {\n    if { [HTTP::uri] starts_with \"/old\"}{\n        SSL::disable serverside\n        pool TestPool1\n    } else {\n        pool TestPool2\n    }\n}","returnValue":"SSL::disable [clientside | serverside]\n    Disables SSL processing on one side of the LTM. Sends an SSL alert to the peer requesting termination of SSL processing.\n    By default, the side that is disabled is the currently running context (so, running SSL::disable in a client-side event will disable client-side SSL). This can be changed via the \"clientside\" or \"serverside\" parameter."},
{"commandName":"SSL::extensions","description":"Returns or manipulates SSL extensions.","examples":"when CLIENTSSL_HANDSHAKE {\n    log local0.info \"CLIENTSSL_HANDSHAKE\"\n    set ext_count [SSL::extensions count]\n    log local0.info \"SSL::extensions count = $ext_count\"\n\n    for {set i 0} {$i<$ext_count} {incr i} {\n        binary scan [SSL::extensions -index $i] S1S1H* ext_type ext_len ext\n        set ext_type [expr {$ext_type & 0xffff}]\n        set ext_len [expr {$ext_len & 0xffff}]\n        log local0.info \"SSL extension #[expr {$i + 1}]: (type $ext_type len $ext_len) $ext\"\n    }\n\n    binary scan [SSL::extensions] H* exts\n    log local0.info \"SSL extensions: $exts\"\n\n    set ext_exists [SSL::extensions exists -type 35]\n    log local0.info \"SSL extension type 35 exists: $ext_exists\"\n    if {$ext_exists} {\n        set scan [binary scan [SSL::extensions -type 35] S1S1H* ext_type ext_len ext]\n        set ext_type [expr {$ext_type & 0xffff}]\n        set ext_len [expr {$ext_len & 0xffff}]\n        log local0.info \"SSL extension type 35: (scan $scan type $ext_type len $ext_len) $ext\"\n    }\n\n    set ext_exists [SSL::extensions exists -type 0]\n    log local0.info \"SSL extension type 0 exists: $ext_exists\"\n    if {$ext_exists} {\n        set scan [binary scan [SSL::extensions -type 0] S1S1H* ext_type ext_len ext]\n        set ext_type [expr {$ext_type & 0xffff}]\n        set ext_len [expr {$ext_len & 0xffff}]\n        log local0.info \"SSL extension type 0: (scan $scan type $ext_type len $ext_len) $ext\"\n    }\n}\n\nSample log output:\n<CLIENTSSL_HANDSHAKE>: CLIENTSSL_HANDSHAKE\n<CLIENTSSL_HANDSHAKE>: SSL::extensions count = 1\n<CLIENTSSL_HANDSHAKE>: SSL extension #1: (type 65281 len 1) 00\n<CLIENTSSL_HANDSHAKE>: SSL extensions: ff01000100\n<CLIENTSSL_HANDSHAKE>: SSL extension type 35 exists: 0\n<CLIENTSSL_HANDSHAKE>: SSL extension type 0 exists: 0\n\nwhen CLIENTSSL_CLIENTHELLO {\n    set my_ext \"Hello world!\"\n    set my_ext_type 62965\n    SSL::extensions insert [binary format S1S1a* $my_ext_type [string length $my_ext] $my_ext]\n}","returnValue":"SSL::extensions\n    Returns the extensions sent by the peer as a single opaque byte array.\n    Valid in all SSL handshake events (those other than *SSL_DATA).\n\nSSL::extensions count\n    Returns the number of extensions received.\n\nSSL::extensions -index <extension number>\n    Returns the opaque extension byte array corresponding to the specified N-th (zero-indexed) extension.\n\nSSL::extensions -type <extension type value>\n    Returns the opaque extension byte array corresponding to the specified extension type value, or an empty string if not found.\n    Returns only the first instance if the same extension type is present more than once.\n\nSSL::extensions exists -type <extension type value>\n    Returns 0 if no extension corresponding to the specified extension type value was provided, or non-zero if at least one such extension exists.\n\nSSL::extensions insert <opaque extensions>\n    Appends the opaque extension specified by a byte array to the set of extensions to send to the peer.\n\nValid only in SERVERSSL_CLIENTHELLO_SEND and CLIENTSSL_CLIENTHELLO events.\nNo validation of the extension is performed beyond checking that the encoded length matches the extension data.\n\nNote: an byte array includes one or more encoded extension type, size, and data."},
{"commandName":"SSL::forward_proxy","description":"This command sets the SSL forward proxy bypass feature to bypass or intercept, or retrieves the forged certificate.","examples":"when CLIENTSSL_SERVERHELLO_SEND {\n    log local0. 'bypassing'\n    SSL::forward_proxy policy bypass\n}\n\nwhen CLIENTSSL_SERVERHELLO_SEND {\n    log local0. 'intercepting'\n    SSL::forward_proxy policy intercept\n}\n\nwhen CLIENTSSL_SERVERHELLO_SEND {\n    set cert [SSL::forward_proxy cert]\n    log local0. \"Cert issuer - [X509::issuer $cert]\"\n}","returnValue":"SSL::forward_proxy policy <[bypass] | [intercept]>\n    This command sets the policy of SSL Forward Proxy Bypass feature to \"bypass\" or \"intercept\"\n\nSSL::forward_proxy cert\n    Returns the X509 SSL certificate forged by the SSL forward proxy."},
{"commandName":"SSL::handshake","description":"Halts or resumes SSL activity. This is useful for suspending SSL activity while authentication is in progress.","examples":"when CLIENT_ACCEPTED {\n    set auth_ldap_sid [AUTH::start pam default_ssl_cc_ldap]\n    set auth_success 0\n}\nwhen CLIENTSSL_CLIENTCERT {\n    AUTH::cert_credential $auth_ldap_sid [SSL::cert 0]\n    AUTH::authenticate $auth_ldap_sid\n    SSL::handshake hold\n}\nwhen AUTH_SUCCESS {\n    if {$auth_ldap_sid eq [AUTH::last_event_session_id]} {\n        set auth_success 1\n        SSL::handshake resume\n    }\n}\nwhen AUTH_WANTCREDENTIAL {\n    if {$auth_ldap_sid eq [AUTH::last_event_session_id]} {\n        reject\n    }\n}\nwhen AUTH_ERROR {\n    if {$auth_ldap_sid eq [AUTH::last_event_session_id]} {\n        reject\n    }\n}\nwhen AUTH_FAILURE {\n    if {$auth_ldap_sid eq [AUTH::last_event_session_id]} {\n        SSL::handshake resume\n    }\n}\nwhen HTTP_REQUEST {\n    if {$auth_success != 1} {\n        HTTP::redirect \"http://errorserver/certerror.html\"\n    }\n}","returnValue":"SSL::handshake hold\n    Halts any SSL activity. Typically used when an authentication request is made.\n\nSSL::handshake resume\n    Resumes any SSL activity that the system previously halted with the 'SSL::handshake hold' command. Typically used when a successful authentication response has been returned."},
{"commandName":"SSL::is_renegotiation_secure","description":"Returns the current state of SSL Secure Renegotiation.","examples":"when CLIENTSSL_SERVERHELLO_SEND {\n    set secure_renegotiation_enabled [SSL::is_renegotiation_secure]\n}","returnValue":"SSL::is_renegotiation_secure\n\n    Returns the current state of SSL Secure Renegotiation on the flow. A value of zero denotes that SSL Secure Renegotiation was not negotiated with the peer. A value of one denotes that the peer has communicated support for SSL Secure Renegotiation.\n\n    Note that some legacy peer implementations may not have full support for SSL Secure Renegotiation, but instead have been patched to perform just an initial SSL handshake with the necessary protocol changes to comply with RFC5746. These implementations may appear to support Secure Renegotiation, but may be incapable of actually performing a secure mid-connection rehandshake."},
{"commandName":"SSL::mode","description":"Gets the enabled/disabled state of SSL","examples":"when CLIENT_ACCEPTED {\n    if { [TCP::local_port] != 443 } {\n        SSL::disable\n    }\n}\nwhen HTTP_REQUEST {\n    if { [SSL::mode] == 0 } {\n        HTTP::redirect \"https://some.other.site.com/\"\n    }\n}","returnValue":"SSL::mode\n    Gets the enabled/disabled state of SSL. Returns 1 if it is enabled, and 0 if it is disabled."},
{"commandName":"SSL::modssl_sessionid_headers","description":"Returns a list of fields that the system will add to the HTTP headers, in order to emulate modssl behavior. The return type is a Tcl list; this list will be interpreted as a header-name/header-value pair by HTTP::header, for example.","examples":"when HTTP_REQUEST {\n    HTTP::header insert [SSL::modssl_sessionid_headers]\n}","returnValue":"SSL::modssl_sessionid_headers\n    Returns a header name of \"SSLClientSessionId\", and a header value of the session id requested by the client.\n\nSSL::modssl_sessionid_headers initial\n    Returns a header name of \"SSLClientSessionId\", and a header value of the session id requested by the client.\n\nSSL::modssl_sessionid_headers current¶\n    Returns a header name of \"SSLClientCurrentSessionId\", and a header value of the session id that is actually used, i.e. the one returned by the server."},
{"commandName":"SSL::payload","description":"The SSL::payload commands allow you to return and manipulate the data collected via the SSL::collect command. This data is in plaintext format.","examples":"when CLIENTSSL_HANDSHAKE {\n    log local0. \"[IP::client_addr]:[TCP::client_port]: SSL handshake completed, collecting SSL payload\"\n    SSL::collect\n}\nwhen CLIENTSSL_DATA {\n    log local0. \"[IP::client_addr]:[TCP::client_port]: Collected bytes [SSL::payload length]\"\n    log local0. \"[IP::client_addr]:[TCP::client_port]: Decrypted payload (\\[SSL::payload\\]): [SSL::payload]\"\n    log local0. \"[IP::client_addr]:[TCP::client_port]: Parsed first line: [SSL::payload 0 [string first \\r\\n [SSL::payload]]]\"\n    log local0. \"[IP::client_addr]:[TCP::client_port]: Releasing payload\"\n    SSL::release\n}\n\n# Sample log output:\n# : 1.1.1.1 : 1.1.1.1 : 1.1.1.1 : 1.1.1.1 : 1.1.1.1","returnValue":"SSL::payload length\n    Returns the amount of plaintext data collected by the SSL::collect command.\n\nSSL::payload [[<offset>] <length>]\n    Returns the actual plaintext data (optionally at the specified offset and/or for the specified length).\n\nSSL::payload replace <offset> <length> <data>\n    Replaces the specified amount of plaintext data at the specified offset with the provided data."},
{"commandName":"SSL::profile","description":"This command allows you to switch between SSL profiles, both client and server. Note: This should be done before the SSL negotiation occurs, or your rule will require the use of the SSL::renegotiate command.\n\nIn order to switch SSL profiles, a profile must be assigned to the virtual to begin with; switching the clientssl profile requires an existing clientssl profile, and similarly for serverssl profiles. You can also use SSL::disable to use SSL selectively.","examples":"when CLIENT_ACCEPTED {\n    if { [IP::addr [IP::client_addr] eq $specific_ip] } {\n        SSL::profile host1_profile\n    } else {\n        SSL::profile ssl_profile2\n    }\n}\n\nwhen HTTP_REQUEST {\n    SSL::renegotiate\n}\n\nwhen SERVER_CONNECTED {\n    if {[LB::server port] == 443 } {\n        SSL::profile serverssl_profile\n    } else {\n        SSL::disable\n    }\n}","returnValue":"SSL::profile <profile_name>\n    Switch to the defined SSL profile."},
{"commandName":"SSL::release","description":"Releases the collected plaintext data to the next layer/filter up.","examples":"when SERVERSSL_HANDSHAKE {\n    # Trigger collection of the decrypted payload once the SSL handshake has been completed successfully\n    SSL::collect\n}\nwhen SERVERSSL_DATA {\n    # Do something with the decrypted data\n    set payload [SSL::payload]\n\n    # Release the payload\n    SSL::release\n}","returnValue":"SSL::release [<length>]\n    Releases the collected plaintext data to the next layer/filter up."},
{"commandName":"SSL::renegotiate","description":"Controls renegotiation of an SSL connection, often used to enforce new encryption settings or certificate requirements.\n\nThis command has different results depending on whether the BIG-IP system evaluates the command under a client-side or a server-side context. The command only succeeds if SSL is enabled on the connection; otherwise, the command returns an error.","examples":"when CLIENTSSL_HANDSHAKE {\n    if { [SSL::cert count] > 0 } {\n        HTTP::release\n    }\n}\nwhen HTTP_REQUEST {\n    if {[HTTP::uri] starts_with \"/securearea/\" } {\n        if {[SSL::cert count] == 0} {\n        HTTP::collect\n        SSL::session invalidate\n        SSL::authenticate always\n        SSL::authenticate depth 9\n        SSL::cert mode require\n        SSL::renegotiate enable\n        SSL::renegotiate\n        }\n    }\n}\nwhen CLIENTSSL_HANDSHAKE {\n    SSL::renegotiate disable\n}\nwhen SERVERSSL_HANDSHAKE {\n    SSL::renegotiate disable\n}","returnValue":"SSL::renegotiate\n    Renegotiates a client-side or server-side SSL connection, depending on the context.\n    When the system evaluates the command under a client-side context, the system immediately renegotiates a request for the associated client-side connection, if client-side renegotiation is enabled. This renegotiation enforces any SSL settings changed for the connection, including client certificate settings.\n    When the system evaluates the command under a server-side context, the system immediately initiates a renegotiation for the associated server-side connection, using the configuration options for forced SSL renegotiations.\n\nSSL::renegotiate [enable | disable]\n    Enable or disable the ability for the peer to request renegotiation. Renegotiation is enabled by default in BIG-IP versions prior to 10.1.0.\n    When disabled, the peer is not allowed to request SSL renegotiation. Disabling SSL renegotiation can be used to prevent SSL injection vulnerability CVE-2009-3555 in applications which do not require SSL renegotiation.\n    When the system evaluates the disable command under a client-side context, and the system receives a ClientHello message from a SSL client, the system terminates the connection. If a NATIVE cipher is in use, the system transmits a handshake failure alert prior to termination. If a COMPAT cipher is in use, the system does not transmit a handshake failure alert prior to termination. When the system evaluates this command under a server-side context, and the system will ignore HelloRequest messages received from the server.\n\nIn BIG-IP versions 10.0.1 and earlier, the enable and disable commands are available only after applying a hotfix; see SOL10737 on the AskF5 website for more details.\nFor a list of NATIVE and COMPAT ciphers supported by BIG-IP version 9.x, please refer to SOL8802"},
{"commandName":"SSL::respond","description":"Returns the specified plaintext data back to the origin over the encrypted SSL connection.","examples":"when CLIENTSSL_HANDSHAKE {\n              # Trigger collection of the decrypted payload once the SSL or DTLS handshake has been completed successfully\n              SSL::collect\n            }\n\n            when CLIENTSSL_DATA {\n               # Send decrypted payload back to client\n               SSL::respond [SSL::payload]\n\n               # Cleanup payload\n               SSL::payload replace 0 [SSL::payload length] \"\"\n\n               # Release collected data\n               SSL::release\n\n               # Collect new data - CLIENTSSL_DATA will be called again\n               SSL::collect\n            }","returnValue":"SSL::respond <data>\n    Returns the specified plaintext data back to the origin over the encrypted SSL connection."},
{"commandName":"SSL::secure_renegotiation","description":"Controls the SSL Secure Renegotiation mode.","examples":"when CLIENTSSL_CLIENTHELLO {\n                if { [SSL::secure_renegotiation] != 2 } {\n                    SSL::secure_renegotiation require-strict\n                }\n            }","returnValue":"SSL::secure_renegotiation¶\n    Get the current Secure Renegotiation mode for the flow. A return value of zero denotes request mode. A value of one denotes require mode. A value of two denotes require-strict mode.\n\nSSL::secure_renegotiation <request|require|require-strict>¶\n    Set the Secure Renegotiation mode for the flow. Enforcement of the new mode will take effect for any subsequent SSL handshakes on the flow."},
{"commandName":"SSL::session","description":"Invalidates the current session. If no parameter is specified, or the \"drop\" parameter is specified, this commands drops the current SSL session ID from the session cache to prevent reuse of the session. If \"nodrop\" is specified, the current session will be invalidated but the session will not be dropped from the session cache.","examples":"when HTTP_REQUEST {\n    if { [HTTP::uri] contains \"/maint_mode\" } {\n        ## send content and die\n        HTTP::respond 200 content $::error_html Connection Close\n        event HTTP_REQUEST disable\n        SSL::session invalidate\n    }\n}","returnValue":"SSL::session invalidate\n    Invalidates the current session. Specifically, this command drops the current SSL session ID from the session cache to prevent reuse of the session."},
{"commandName":"SSL::sessionid","description":"Gets the SSL session ID.","examples":"when CLIENTSSL_CLIENTCERT {\n    set cert [SSL::cert 0]\n    set sid [SSL::sessionid]\n    if { $sid ne \"\" } {\n        # If this SSL session will be cached, then it may be\n        # resumed later on a new connection. Cache the cert\n        # in the session table in case that happens. Because ID's\n        # are not globally unique, the session id needs to be combined\n        # with something from client address to avoid mismatch.\n        set key [concat [IP::remote_addr]@$sid]\n        session add ssl $key $cert 180\n    }\n}\nwhen HTTP_REQUEST {\n    if { [info exists cert] } {\n        set sn [X509::serial_number $cert]\n    } else {\n        set sid [SSL::sessionid]\n        # We don't have a cert, possibly because this is\n        # a new connection that was a resumption of a\n        # previous SSL session. If that is the reason,\n        # the cert will be in the session table.\n        if { $sid ne \"\" } {\n            # This SSL session was resumed; retreive the cached cert\n            set key [concat [IP::remote_addr]@$sid]\n            set cert [session lookup ssl $key]\n            if { $cert ne \"\" } {\n                set sn [X509::serial_number $cert]\n            } else {\n                # dunno how this happened\n                reject\n                return\n            }\n        }\n    }\n    if { [info exists sn] } {\n        HTTP::header insert Serial $sn\n    } else {\n        # no sn available, reject the client\n        reject\n        return\n    }\n}","returnValue":"SSL::sessionid\n    Returns the current connection's SSL session ID if it exists in the session cache.\n    In version 10.x and higher, if the session ID does not exist in the cache, returns a null string.\n    In version 9.x, if the session ID does not exist in the cache, returns a string of 64 zeroes. (This Known Issue is documented in SOL11987 )\n\nNote: It appears that the session ID will never be added to the SSL cache if the client SSL profile is set to always validate the client certificate (as opposed to validating once per session)."},
{"commandName":"SSL::sessionticket","description":"This command returns the session ticket associated with the SSL flow.","examples":"when CLIENTSSL_HANDSHAKE {\n    set st [SSL::sessionticket]\n    set stlen [string length $st]\n    log local0. \"stlen $stlen\"\n    log local0. \"st $st\"\n}","returnValue":"This command returns the session ticket associated with the SSL flow."},
{"commandName":"SSL::unclean_shutdown","description":"Sets the value of the Unclean Shutdown setting. This command only affects the current connection, and only affects the current context (e.g., when run in a client-side context, it only affects the current client-side connection).","examples":"# Note that for this iRule, unclean shutdown should be disabled in the clientssl profile\nwhen HTTP_REQUEST {\n    if { [HTTP::header \"User-Agent\"] contains \"MSIE\" } {\n        SSL::unclean_shutdown enable\n    }\n}","returnValue":"SSL::unclean_shutdown <\"enable\" | \"disable\">\n    Sets the value of the current client-side or server-side SSL connection’s Unclean Shutdown setting."},
{"commandName":"SSL::verify_result","description":"Gets or sets the result code for peer certificate verification. Result codes use the same values as those of OpenSSL's X509 verify_result (X509_V_ERR_*) definitions.","examples":"when CLIENTSSL_CLIENTCERT {\n    set cert [X509::verify_cert_error_string [SSL::verify_result]]\n}\nwhen HTTP_REQUEST {\n    if { [info exists cert] } {\n        HTTP::header insert ClientCert $cert\n    }\n}","returnValue":"SSL::verify_result\n    Gets the result code from peer certificate verification. The returned code uses the same values as those of OpenSSL's X509 verify_result (X509_V_ERR_) definitions.\n\nSSL::verify_result <result_code>\n    Sets the result code for peer certificate verification. The argument uses the same values as those of OpenSSL's X509 verify_result (X509_V_ERR_) definitions.\n\n    The values for OpenSSL's verify result codes are listed at the bottom of this page and can be found at: http://www.openssl.org/docs/apps/verify.html#DIAGNOSTICS"},
{"commandName":"SSL::alpn","description":"Sets or retrieves the Application Layer Protocol Negotiation (ALPN) string.\n\nSSL::alpn\n  Retrieve the selected ALPN string\n\nSSL::alpn set str1[ str2...]\n  Set the advertised ALPN string","examples":"when CLIENTSSL_CLIENTHELLO {\n    SSL::alpn set \"spdy/1\" \"spdy/2\" \"http/2\"\n}\nwhen CLIENTSSL_HANDSHAKE {\n    log local0.info \"negotiated protocol: [SSL::alpn]\"\n}","returnValue":"SSL::alpn\n    Returns the negotiated ALPN string\nSSL::alpn set ...\n    There is no return value."},
{"commandName":"SSL::clientrandom","description":"Return the ClientRandom value from the Client hello.","examples":"when CLIENTSSL_HANDSHAKE {\n    log local0.info \"negotiated protocol: [SSL::clientrandom]\"\n}","returnValue":"The ClientRandom value."},
{},
{"commandName":"SSL::sessionsecret","description":"Return data about SSL handshake master secret.","examples":"when CLIENTSSL_HANDSHAKE {\n    log local0. \"ClientSSL: Secret for [SSL::sessionid] is -> [SSL::sessionsecret]\"\n}\nwhen SERVERSSL_HANDSHAKE {\n    log local0. \"ServerSSL: Secret for [SSL::sessionid] is -> [SSL::sessionsecret]\"\n}\n\nSample log output:\n<CLIENTSSL_HANDSHAKE>: ClientSSL: Secret for 0a2ab9cb944a147b173641e1e9db54e0ac09d6a26a00ea468eda1c4607648700 is -> 03038ad67cc5e78f0de0125d06fb0908ac018c22f457c9f915f1bc425347f86021b40f50bb7369a867c9a99aa897f85c\n<SERVERSSL_HANDSHAKE>: ServerSSL: Secret for 0a2ab9cb944a1478173641e1e9db57e0f5a5cd3433acf1de8eda1c4607648059 is -> 03d4584cd4251f8b911dfc9798017630f0f1b39e41e40e47f0dc0df73249b898d867b0b2567858b4767b353478ad6922d10e3c1a1cd471bc12e3b44bbe6524e9","returnValue":"SSL::sessionsecret\n    Returns the current SSL handshake master secret."},
{"commandName":"SSL::sni","description":"Returns a Server Name Indication name, and require SNI support.","examples":"when HTTP_REQUEST {\n    log local0.info \"SNI name: [SSL::sni name]\"\n    log local0.info \"SNI required: [SSL::sni required]\"\n}\n\nSample log output:\n<HTTP_REQUEST>: SNI name: f5.com\n<HTTP_REQUEST>: SNI required: 1","returnValue":"SSL::sni name\n    Returns the current Server Name Indication.\nSSL::sni required\n    Returns the require SNI support."},
{"commandName":"SSL::maximum_record_size","description":"SSL::maximum_record_size\n  Returns the currently set maximum egress record size.\nSSL::maximum_record_size #####\n  Set the maximum egress record size.","examples":"when CLIENT_ACCEPTED {\n    SSL::maximum_record_size 1234\n}","returnValue":"SSL::maximum_record_size\n              Returns the currently set maximum egress record size.\n            SSL::maximum_record_size #####\n              There is no return value."},
{"commandName":"SSL::allow_dynamic_record_sizing","description":"SSL::allow_dynamic_record_sizing\n  Returns the currently set value for allowing dynamic record sizing\nSSL::allow_dynamic_record_sizing ( 0 | 1 )\n  0 disables dynamic record sizing, 1 enables it.\n  Dynamic record sizing, when using protocols such as HTTP, can increase respnonsiveness of a website.","examples":"when CLIENT_ACCEPTED {\n    SSL::allow_dynamic_record_sizing 1\n}","returnValue":"SSL::allow_dynamic_record_sizing\n              Returns the currently set dynamic record sizing value.\n            SSL::allow_dynamic_record_sizing [0|1]\n              There is no return value."},
{"commandName":"STATS::get","description":"Retrieves the value of the specified field of the specified Statistics\nprofile.\n\n\nSTATS::get <profile> <field>\n\n     * Retrieves the value of the specified field of the specified\n       Statistics profile.","examples":"when HTTP_REQUEST {\n  if {[string tolower [HTTP::uri]] starts_with \"/check\"} {\n    STATS::get stats_profile_1 \"my_first_field\"\n  }\n}","returnValue":"Returns the value of the specified field of the specified Statistics profile"},
{"commandName":"STATS::incr","description":"Increments the value of the specified setting (field), in the specified\nStatistics profile, by the specified value. If you do not specify a\nvalue, the system increments by 1. It is possible to set a negative\nvalue in order to decrement the counter. Returns the current value of\nthe field which was incremented.\n\nSyntax\n\nSTATS::incr <profile> <field> [<value>]\n\n     * Increments or decrements (negative value) the value of a Statistics profile setting.\n\n     * <profile> - the name of the profile. Even though you provide the name, you\n       must have the profile applied to the Virtual Server.\n     * <field> - The NAME of the field to increment. Fields are numbered from 1 to\n       32, but you must provide the NAME of the field for it to work.\n     * <value> - Amount to increment/decrement. If not provided, LTM will increment by 1.","examples":"#Check initial page of website to see if connection is from IE6, IE7, or other browser.\n#Easy to add more.\n#Andre Padua\n#a.padua@f5.com\n#\n#ADD a STATS Profile to LTM and apply it to the Virtual Server.\n#\n#profile stats browser_version {\n#   defaults from stats\n#   field1 IE6\n#   field2 IE7\n#   field3 Other\n#}\n#\nwhen HTTP_REQUEST {\n    if { [HTTP::uri] ends_with \"Default.aspx\" } {\n        #log local0. \"Requested URL was Default.aspx\"\n        switch -glob [string tolower [HTTP::header User-Agent]] {\n            \"*msie 6.0*\" {\n            #log local0. \"Browser is IE6\"\n            STATS::incr browser_version IE6\n            }\n            \"*msie 7.0*\" {\n            #log local0. \"Browser is IE7\"\n            STATS::incr browser_version IE7\n            }\n            \"*\"  {\n            #log local0. \"Browser is not IE6 or IE7\"\n            STATS::incr browser_version Other\n            }\n        }\n    }\n}\n\n# Note: this won't work as it is posted in 9.4.x/10.0.x as STATS::set cannot reused in the RULE_INIT event.\n# See the STATS::set page for a workaround:\n\n#\n# Simple rule showing how to intialize, increment and decrement a stats profilefield\n#\nwhen RULE_INIT {\n\n   # Initialise the number of unanswered HTTP requests at 0\n   log local0. \"Initialize the count of unanswered requests: [STATS::set my_stats_profile_name \"current_count\" 0]\"\n}\nwhen HTTP_REQUEST {\n\n   # Increment the number of unanswered HTTP requests\n   log local0. \"Incremented the current count to: [STATS::incr my_stats_profile_name \"current_count\"]\"\n}\nwhen HTTP_RESPONSE {\n\n   # Increment the number of unanswered HTTP requests\n   log local0. \"Decremented the current count to: [STATS::incr my_stats_profile_name \"current_count\" -1]\"\n}\n\nSample log output:\n\nRule: Initialize the count of unanswered requests: 0\nRule stats_rule <HTTP_REQUEST>:  Incremented the current count to: 100\nRule stats_rule <HTTP_RESPONSE>: Decremented the current count to: 99","returnValue":"Returns the current value of the field which was incremented."},
{"commandName":"STATS::set","description":"Sets the value of the specified setting (field), in the specified\nStatistics profile, to the specified value. If you do not specify a\nvalue, the BIG-IP system sets the value to 0.\n\nSyntax\n\nSTATS::set <profile> <field> [<value>]\n\n     * Sets the value of a Statistics profile field.","examples":"when HTTP_REQUEST {\n  if {[string tolower [HTTP::uri]] starts_with \"/enable\"} {\n    STATS::set stats_profile_1 \"my_first_field\" \"val1\"\n  }\n}\n\n\n# Workaround for CR117956 (see version specific notes below for details)\nwhen RULE_INIT {\n    set ::stats_rst 1\n}\nwhen CLIENT_ACCEPTED {\n   if { $::stats_rst == 1 }{\n      STATS::set profilename fieldname 0\n      set ::stats_rst 0\n   }\n}","returnValue":""},
{"commandName":"STATS::setmax","description":"Ensures that the value of the specified Statistics profile setting\n(field) is at the least value.\n\nSyntax\n\nSTATS::setmax <profile> <field> [<value>]\n\n     * Ensures that the value of the specified Statistics profile setting\n       (field) is at the least value.","examples":"","returnValue":""},
{"commandName":"STATS::setmin","description":"Ensures that the value of the specified Statistics profile setting\n(field) is at the most value.\n\nSyntax\n\nSTATS::setmin <profile> <field> [<value>]\n\n     * Ensures that the value of the specified Statistics profile setting\n       (field) is at the most value.","examples":"","returnValue":""},
{"commandName":"STREAM::disable","description":"Disables the stream filter for this connection.\n\nSyntax\n\nSTREAM::disable\n\n     * Disables the stream filter for this connection or until\n       STREAM::enable is called.\n\n   Configuration requirements:\n   1. To perform the response data replacement, the default, unconfigured\n   stream profile must be configured on the virtual server\n   2. For all versions up to 9.4.0, you must force BIG-IP to use chunking\n   and therefore remove the response content length header. This can be\n   done by applying a custom HTTP profile to the virtual server with\n   Response Chunking set to \"Rechunk\". (See SOL6422 for details.)","examples":"See the STREAM::expression page for additional examples.\nTo check HTTP responses with a Content-Type that contains text, and\nreplace http:// with https://:\n\nwhen HTTP_REQUEST {\n   # Explicitly disable the stream profile for each request so it doesn't stay\n   #   enabled for subsequent HTTP requests on the same TCP connection.\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n   STREAM::disable\n   # Apply stream profile against text responses from the application\n   if { [HTTP::header value Content-Type] contains \"text\" }{\n\n      # Look for http:// and replace it with https://\n      STREAM::expression {@http://@https://@}\n\n      # Enable the stream profile\n      STREAM::enable\n   }\n}\n\n# This section only logs matches, and should be removed before using the rule in production.\nwhen STREAM_MATCHED {\n    log local0. \"Matched: [STREAM::match]\"\n}\n\nIf you only want to replace some http:// links with https://, you can\nspecify a more complex regular expression in the 'find' portion of the\nSTREAM::expression. For example, to match all http:// links except\nhttp://schemas.microsoft.com/intellisense/ie5, you can use a negative\nlook behind in the regex:\n\nhttp:(?!//schemas\\.microsoft\\.com/intellisense/ie5)","returnValue":""},
{"commandName":"STREAM::enable","description":"Enables the stream filter for the life of the current TCP connection or\nuntil disabled with STREAM::disable.\n\nSyntax\n\nSTREAM::enable\n\n     * Enables the stream filter for the life of the current TCP\n       connection or until disabled with STREAM::disable.\n\n   Configuration requirements:\n   1. To perform the response data replacement an unconfigured stream\n   profile must be configured on the virtual server\n   2. For all versions up 9.4.0, you must force BIG-IP to use chunking and\n   therefore remove the response content length header. This can be done\n   by applying a custom HTTP profile to the virtual server with Response\n   Chunking set to \"Rechunk\". (See SOL6422 for details.)\n\nVersion Specific Notes\n\n   * LTM 9.2 - 9.2.4 The Stream filter uses TCL to parse and replace data.\n   TCL has a 4Mb limit for a single allocation or connection. When this\n   limit is exceeded, TMM will crash. See SOL6741 (CR55382 and\n   CR70146) for details and a workaround. This issue was resolved in\n   9.2.5, 9.3 and 9.4+\n\n   * LTM 9.3.1+, 9.4.2+ STREAM::enable must be called after\n   STREAM::expression. See CR79374","examples":"See the STREAM::expression page for additional examples.\nTo check HTTP responses with a Content-Type that contains text, and\nreplace http:// with https://:\n\nwhen HTTP_REQUEST {\n\n   # Explicitly disable the stream profile for each request so it doesn't stay\n   #   enabled for subsequent HTTP requests on the same TCP connection.\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n   # Apply stream profile against text responses from the application\n   if { [HTTP::header value Content-Type] contains \"text\" }{\n\n      # Look for http:// and replace it with https://\n      STREAM::expression {@http://@https://@}\n\n      # Enable the stream profile\n      STREAM::enable\n   }\n}\n# This section only logs matches, and should be removed before using the rule in production.\nwhen STREAM_MATCHED {\n    log local0. \"Matched: [STREAM::match]\"\n}\n\nIf you only want to replace some http:// links with https://, you can\nspecify a more complex regular expression in the 'find' portion of the\nSTREAM::expression. For example, to match all http:// links except\nhttp://schemas.microsoft.com/intellisense/ie5, you can use a negative\nlook behind in the regex:\n\nhttp:(?!//schemas\\.microsoft\\.com/intellisense/ie5)","returnValue":""},
{"commandName":"STREAM::encoding","description":"Specifies non-default content encoding. The default value is ascii.\n\nSyntax\n\nSTREAM::encoding <ascii | utf-8 | unicode>\n\n   Specifies non-default content encoding. The default value is ascii.","examples":"when STREAM_MATCHED {\n    set stream_match [STREAM::match]\n    log local0. \"$stream_match\"\n    STREAM::encoding utf-8\n    # The ?/? represents unicode characters.\n    if { $stream_match contains \"hello?/?\" } {\n        STREAM::replace \"hello hey\"\n        log local0. \"stream match is [STREAM::match]\"\n    }\n}","returnValue":""},
{"commandName":"STREAM::expression","description":"Replaces the stream expression in the Stream profile with the specified\nvalue. The syntax is identical to the profile syntax.\nNote that this change affects this connection only and is sticky\nfor the duration of the connection.\n\nSyntax\n\nSTREAM::expression <expression>\n\n     * Replaces the stream expression in the Stream profile with the\n       specified value. The syntax is identical to the profile syntax.\n\n   The stream expression is constructed as a list of search/replacement\n   pairs in the following format:\n\n   <delim><search><delim>[<replace>]<delim> [<delim><search><delim>[<replace>]<delim>...]\n\n   You must Start, Separate, AND End your search/replace string with an\n   appropriate delimiter, per the pattern above. In addition note that\n   there may NOT be space between the TCL argument delimiter and the\n   argument . This will result in no error at all, but it will not match\n   the \"search\" string and will appear to not work. Example is given just\n   below to demonstrate this error.\n\n      # This will work\n      STREAM::expression {@IE@Apache@ @Windows@Linux@}\n\n      # This will NOT work - notice the space between the 'curly brace' and the '@'\n      STREAM::expression { @IE@Apache@ @Windows@Linux@ }\n\n   The first character defines the delimiter. Most examples use the \"@\"\n   character, but any of the following characters are allowed as a\n   delimiter: .*/-:_?=@& (period, asterisk, forward slash, dash, colon,\n   underscore, question mark, equals, at sign, ampersand) The replacement\n   value is optional, and may be omitted if you wish to delete the search\n   value from the data stream. (The end delimiter is still required,\n   resulting in 2 consecutive delimiters with no intervening whitespace.)\n   Multiple replacements may be performed by a single expression by adding\n   additional pairs.\n   If you use variables in the stream expression, you must not use curly\n   braces to enclose the expression as these prevent variable expansion\n   and command execution:\n\n      # This will work to replace the $find variable value with $replace variable value\n      STREAM::expression \"@$find@$replace@\"\n\n      # This will NOT work - curly braces prevent variable expansion and command execution\n      STREAM::expression {@$find@$replace@}\n\n   If the delimiter is present in the search or replace string, the\n   instance in the string can be escaped (a preceding '\\') so the\n   expression will be parsed correctly.\n   To perform the response data replacement, a stream profile must already\n   be configured on the virtual server. (The default, unconfigured stream\n   profile is recommended.)\n\n   Version Specific Notes\n       * LTM 9.2 - 9.2.4 The Stream filter uses TCL to parse and replace data.\n       TCL has a 4Mb limit for a single allocation or connection. When this\n       limit is exceeded, TMM may restart. See SOL6741 (CR55382 and\n       CR70146) for details and a workaround. This issue was resolved in\n       9.2.5, 9.3.0 and 9.4.0\n\n       * LTM 9.0-10.x When performing stream replacements where the original and\n       replacement strings are different lengths, you must force BIG-IP to\n       discard the server's Content-Length header and chunk the data before\n       sending the response onto the client. This can be done by applying a\n       custom HTTP profile to the virtual server with Response Chunking set to\n       \"Rechunk\". See SOL6422 for details.","examples":"# Example which replaces http:// with https:// in response content\n# Prevents server compression in responses\nwhen HTTP_REQUEST {\n\n   # Disable the stream filter for all requests\n   STREAM::disable\n\n   # LTM does not uncompress response content, so if the server has compressionenabled\n   # and it cannot be disabled on the server, we can prevent the server from\n   # sending a compressed response by removing the compression offerings from the client\n   HTTP::header remove \"Accept-Encoding\"\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Replace http:// with https://\n      STREAM::expression {@http://@https://@}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\n\nReplace IE with Apache, Windows with Linux:\n\nwhen HTTP_REQUEST {\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Replace IE with Apache, Windows with Linux\n      STREAM::expression \"@IE@Apache@ @Windows@Linux@\"\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\n\nReplace IP addresses in response content with the string: 0.0.0.0:\n\nwhen HTTP_REQUEST {\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Replace IP addresses in response content with the string: 0.0.0.0\n      STREAM::expression \\d{1,3}\\.\\d{1,3}\\.\\d{1,3}\\.\\d{1,30.0.0.0@}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\n\nReplace any http:// instance with https://, unless the original string\nis http://example.com:\n\nwhen HTTP_REQUEST {\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Replace any http:// instance with https://, unless the original string is http://example.com\n      STREAM::expression {@http:(?!//example\\.com)@https://@}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\n\nNote that the following examples use a lazy wildcard match .*? which\nmay use more resources than a non-wildcard stream expression. It would\nbe ideal to performance test this before using in production.\nReplace any http:// instance with https://, unless the original string\nis http://*example.com:\n\nwhen HTTP_REQUEST {\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Replace any http:// instance with https://, unless the original string is http://*example.com:\n      STREAM::expression {@http://(?!.*?example\\.com)@https://@}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\n\nThis example shows how you can use STREAM::match in the\nSTREAM_MATCHED event to check if the matched string meets some\ncondition that can't easily be checked for using a single regex in\nSTREAM::expression.\n\nwhen HTTP_REQUEST {\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Match an http://*example.com string and replace it with nothing yet\n      STREAM::expression {&http://.*?example\\.com&&}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\nwhen STREAM_MATCHED {\n\n   # Check if the matched string meets some condition that can't easily be checked for using a single regex in STREAM::expression\n   if {[STREAM::match] starts_with \"host1\"}{\n\n      # Replace http:// with https:// and do the replacement\n      STREAM::replace \"[string map {http:// https://} [STREAM::match]]\"\n      log local0. \"[IP::client_addr]:[TCP::local_port]: matched: [STREAM::match], replaced with: [string map {http:// https://} [STREAM::match]]\"\n   }\n}\n\nLog output:\n\nRule stream_expression_rule <STREAM_MATCHED>: 10.0.0.1:3413: matched: http://test.example.com, replaced with: https://test.example.com\nRule stream_expression_rule <STREAM_MATCHED>: 10.0.0.1:3413: matched: http://example.com, replaced with: https://example.com","returnValue":""},
{"commandName":"STREAM::match","description":"Returns the matching characters.\n\nSyntax\n\nSTREAM::match\n\n     * Returns the matching characters.","examples":"Log each stream filter match (as configured in a stream profile or in\nan iRule using STREAM):\n\nwhen STREAM_MATCHED {\n   # Log each match found by the stream filter\n   log local0. \"Stream filter matched: [STREAM::match]\"\n}\n\nReplace any http:// instance with https:// only if the original string\nis http://*example.com.\n\nwhen HTTP_REQUEST {\n\n   # Disable the stream filter for all requests\n   STREAM::disable\n}\nwhen HTTP_RESPONSE {\n\n   # Disable the stream filter by default\n   STREAM::disable\n\n   # Check if response type is text\n   if {[HTTP::header value Content-Type] contains \"text\"}{\n\n      # Match any http:// instance and replace it with nothing\n      STREAM::expression {\\@\\@http://.*?example\\.com@@}\n\n      # Enable the stream filter for this response only\n      STREAM::enable\n   }\n}\nwhen STREAM_MATCHED {\n    log local0. \"[IP::client_addr]:[TCP::local_port]: matched: [STREAM::match], replaced with: [string map {http:// https://} [STREAM::match]]\"\n    STREAM::replace \"[string map {http:// https://} [STREAM::match]]\"\n}","returnValue":"Returns the matching characters."},
{"commandName":"STREAM::max_matchsize","description":"Sets the maximum size, in bytes, that the system can buffer during\npartial matches. The default value is 4096.\nThe STREAM profile will buffer data for partial matches; if more than\nmax_matchsize would be buffered, the connection will be torn down. This\nway a regex like foobarbaz+ won't keep matching until the box runs\nout of memory. The default is 4K, and STREAM::max_matchsize can be\nuse to set it to something else.\n\nSyntax\n\nSTREAM::max_matchsize <size>\n\n     * Sets the maximum size, in bytes, that the system can buffer during\n       partial matches. The default value is 4096.","examples":"when HTTP_RESPONSE {\n    STREAM::max_matchsize 2048\n}","returnValue":""},
{"commandName":"STREAM::replace","description":"Changes the specified target replacement string in the Stream profile.\nThis command is not sticky and is applied only once during the current\nmatch. If the target expression is missing, the replacement is skipped.\n\nSyntax\n\nSTREAM::replace [<target>]\n\n     * Changes the specified target replacement string in the Stream\n       profile. This command is not sticky and is applied only once during\n       the current match. If the target expression is missing, the\n       replacement is skipped.","examples":"when STREAM_MATCHED {\n    set server [string tolower [STREAM::match]]\n    if {$server contains \"mail\"} {\n        STREAM::replace \"webmail.yourdomain.com/$mailhost\"\n    }\n}","returnValue":""},
{"commandName":"TCP::abc","description":"This command will enable or disable TCP Appropriate Byte Counting. Increases congestion window in accordance with bytes actually acknowledged, rather than allowing small acknowledgements to increase the window by an entire segment.\n\nSyntax\n\nTCP::abc <enable|disable>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # If an HTTP connection, enable ABC on the client side and\n    # disable ABC on the server side.\n    if { [server_port] == 80 } {\n        clientside {\n            TCP::abc enable\n            log local0. \"Client MSS: [TCP::mss]\"\n        }\n        serverside {\n            TCP::abc disable\n            log local0. \"Server MSS: [TCP::mss]\"\n        }\n    }\n}","returnValue":"None."},
{"commandName":"TCP::analytics","description":"Enables or disables AVR TCP stat reporting (\"analytics\") for this connection and/or assigns user-defined keys.\n\nTCP::analytics enable\n    Enables analytics on this connection. AVR must be provisioned and the virtual must have a tcp-analytics profile attached. Collection will use the configuration in the profile. If the profile is configured to disable analytics by default, this gives users the ability to collect statistics by exception only.\n\nTCP::analytics disable\n    Disables analytics on this connection. If AVR is provisioned and the virtual has a tcp-analytics profile that enables analytics by default, this allows users to disable collection by exception only.\n\nTCP::analytics key <string>\n    Attaches a user-provided string as an analytics entity. All statistics reported after executing this command will be separable from all statistics that do not have the key attached. Replaces any existing key attached to this connection. If analytics is not enabled, AVR is provisioned, and the virtual has a tcp-analytics profile attached, this command also enables analytics.\n\nTCP::analytics key\n    Removes any user-provided analytics entity attached via a previous TCP::analytics command. If analytics is not enabled, AVR is provisioned, and the virtual has a tcp-analytics profile attached, this command also enables analytics.","examples":"# start collection for one subnet only.\n     when CLIENT_ACCEPTED {\n         if [IP::addr [IP::client_addr]/8 equals 10.0.0.0] {\n             TCP::analytics enable\n         }\n     }\n     when HTTP_REQUEST {\n         # must check subnet again to avoid starting for all\n         # connections\n         if [IP::addr [IP::client_addr]/8 equals 10.0.0.0] {\n             # make stats queryable by URI\n             TCP::analytics key \"[HTTP::uri]\"\n         }\n     }","returnValue":""},
{"commandName":"TCP::autowin","description":"Sets the send and receive buffer dynamically in accordance with measured connection parameters.\n\nSyntax\n\nTCP::autowin <enable|disable>","examples":"when HTTP_REQUEST {\n    # Enable auto buffer tuning on HTTP request(s).\n    log local0. \"Send buffer: [TCP::sendbuf] Receive Window: [TCP::recvwnd]\"\n    log local0. \"HTTP request, auto buffer tuning enabled.\"\n    TCP::autowin enable\n    log local0. \"Send buffer: [TCP::sendbuf] Receive Window: [TCP::recvwnd]\"\n}","returnValue":"None."},
{"commandName":"TCP::bandwidth","description":"Returns the estimated bandwidth measured as \"congestion window\" / \"the measured round trip time\".\nThe values returned are only estimates, and can vary even during the connection.\n\nNote: Starting with BIG-IP v9.4.2, client bandwidth calculations are unavailable, always returning 0. Starting with BIG-IP v12.0 nonzero values are returned.\n\nSyntax\n\nTCP::bandwidth\n\n     * Returns the estimated bandwidth in kilobits per second.","examples":"when CLIENT_DATA {\nif {[HTTP::uri] starts_with \"/xxx.css\"}{\n      set bandwidth [TCP::bandwidth]\n      if {$bandwidth < XXX} {\n         HTTP::uri \"/boring-xxx.css\"\n      }\n   }\n}","returnValue":"The estimated bandwidth in kilobits per second."},
{"commandName":"TCP::client_port","description":"Returns the TCP port/service number of the clientside TCP\nconnection. This command is equivalent to the TCP::remote_port\ncommand in a clientside context, and to the BIG-IP 4.x variable\nclient_port.\n\nSyntax\n\nTCP::client_port\n\n     * Returns the TCP port/service number of the clientside TCP\n       connection.","examples":"when SERVER_CONNECTED {\n   # This logs information about:\n   #  * the clientside part of the client<->LTM connection, and\n   #  * the serverside part of the LTM<->server connection.\n   log local0.info \"Complete connection: [IP::client_addr]:[TCP::client_port]<->LTM<->[IP::server_addr]:[TCP::server_port]\"\n}","returnValue":"The port advertised by the client. Even on SERVER events, it still returns the client port from the clientside."},
{"commandName":"TCP::close","description":"Sends the FIN byte to gracefully close the connection.\n\nSyntax\n\nTCP::close\n\n     * Closes the TCP connection. Specifically, a segment is generated\n       with the FIN bit set.\n     * After the connection is closed, the system table connection entry\n       is removed.","examples":"when HTTP_REQUEST {\n    set my_loc \"http://www.i-want-a-bigip-for-christmas.com\"\n    TCP::respond \"HTTP/1.1 302 Found\\r\\nLocation: $my_loc\\r\\nConnection: close\\r\\nContent-Length: 0\\r\\n\\r\\n\"\n    TCP::close\n}","returnValue":"None."},
{"commandName":"TCP::collect","description":"Collects the specified amount of data before triggering a CLIENT_DATA or SERVER_DATA event. This data is not delivered to the upper layer until the event fires.\n\nAfter collecting the data in a clientside event, the CLIENT_DATA\nevent will be triggered. When collecting the data in a serverside\nevent, the SERVER_DATA event will be triggered.\n\nIt is important to note that, when an explicit length is not specified,\nthe semantics of TCP::collect and TCP::release are different than\nthose of the HTTP::collect and HTTP::release commands. With\nTCP::collect, the event for processing the data (CLIENT_DATA or\nSERVER_DATA) will fire without TCP::release being called,\nwhereas with HTTP::collect, the event (HTTP_REQUEST_DATA or\nHTTP_RESPONSE_DATA) will not fire without HTTP::release being\ncalled.\n\nSyntax\n\nTCP::collect [<collect_bytes> [<skip_bytes>]]\n\nTCP::collect\n\n     * Collect TCP payload data. The CLIENT_DATA or SERVER_DATA\n       event will be triggered for every received packet. To stop\n       collecting and forward collected or modified payload data, use\n       TCP::release.\n\nTCP::collect <collect_bytes>\n\n     * Collect the specified amount of TCP payload data. The\n       <collect_bytes> parameter specifies the minimum number of bytes to\n       collect. The CLIENT_DATA or SERVER_DATA event will be\n       triggered when the data collection is complete.\n\nTCP::collect <collect_bytes> <skip_bytes>\n\n     * Collect the specified amount of TCP payload data, after skipping\n       the specified amount. The <collect_bytes> parameter specifies the\n       minimum number of bytes to collect, and the <skip_bytes> parameter\n       specifies the number of bytes to skip. The CLIENT_DATA event\n       will be triggered when the data collection is complete, and also\n       when the specified number of bytes have been skipped. In the latter\n       case, there may not be any bytes yet collected ( TCP::payload\n       is empty).\n     * Note that the use of the <skip_bytes> parameter changes the timing\n       of serverside connection initiation: Ordinarily, TCP::collect\n       causes the server-side connection to be delayed until the requested\n       data is received. If the <skip_bytes> parameter is specified, even\n       if the value is 0, the serverside connection is not delayed by the\n       TCP profile (other profiles, such as the HTTP profile, may also\n       delay the serverside connection, however). This may be useful in\n       trying to use the same virtual server for both client-initiated\n       protocols (like HTTP) and server-initiated protocols (like SSH). If\n       a load balancing decision needs to be made on client data after\n       <skip_bytes>, it may be necessary to use the LB::detach\n       command to sever the serverside connection before making a new\n       selection. See this post for more details on using\n       TCP::collect in this way.-->\n     * Since the use of the <skip_bytes> requires a serverside connection\n       to be established, there must be a valid load balancing target\n       available. Attempting to use this parameter without a server\n       available to complete the backend handshake (no default pool\n       specified, all servers in pool down, etc.) will result in a RST on\n       the clientside connection.\n\n   Note: The <skip_bytes> parameter has not yet been extensively tested.\n   There are also some important known issues associated with it, such as\n   CR95439 (some commands do not work if the <skip_bytes> parameter is\n   used; fixed in v9.4.5) and CR101100 (if a packet splits contains enough\n   data to meet <skip_bytes> but not enough to meet <collect_bytes>,\n   CLIENT_DATA may not fire; not yet fixed).","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # First collect 50000 bytes before passing data to the client.\n    TCP::collect 50000\n}\nwhen SERVER_DATA {\n    set datalen [TCP::offset]\n    log local0. \"Collected $datalen bytes.\"\n    # Release 50000+ bytes to the client.\n    TCP::release\n    log local0. \"Server, cwnd: [TCP::snd_cwnd], rtt: [TCP::rtt]\"\n}","returnValue":"None."},
{"commandName":"TCP::congestion","description":"Changes the TCP congestion control algorithm and initializes any state variables unique to the new algorithm.\n\nSyntax\n\n\nTCP::congestion [<none|reno|newreno|highspeed|scalable|vegas\n                |cdg|chd|illinois|woodside|cubic|westwood>]\n\nTCP::congestion <none>\n\n     * Specifies that the system does not use a network-congestion-control\n       mechanism, even when congestion occurs.\n\nTCP::congestion <reno>\n\n     * Specifies that the system uses an implementation of the TCP Fast\n       Recovery algorithm, which is based on the implementation in the BSD\n       Reno release.\n\nTCP::congestion <newreno>\n\n     * Specifies that the system uses a modification to the Reno algorithm\n       that responds to partial acknowledgements when SACKs are\n       unavailable.\n\nTCP::congestion <highspeed>\n\n     * Specifies that the system uses a more aggressive, loss-based\n       algorithm.\n\nTCP::congestion <scalable>\n\n     * Specifies that the system uses a TCP algorithm modification that\n       adds a scalable, delay-based and loss-based component into the Reno\n       algorithm.\n\nTCP::congestion <vegas>\n\n     * Specifies that the system uses a TCP algorithm modification that\n       adds a delay-based and loss-based component into the Reno\n       algorithm.\n\nTCP::congestion <cdg>\n\n     * Specifies that the system uses a delay based TCP that senses onset\n       of congestion by variations in round trip time (RTT).\n\nTCP::congestion <chd>\n\n     * Specifies that the system uses a TCP algorithm that aims to keep\n       network queuing delays below a particular threshold\n       (queue_threshold) and decides to reduce the congestion window\n       (cwnd) probabilistically based on its estimate of the network\n       queuing delay.\n\nTCP::congestion <illinois>\n\n     * Specifies that the system uses a TCP algorithm that is especially\n       targeted at high-speed, long-distance networks.\n\nTCP::congestion <woodside>\n\n     * Specifies that the system uses a TCP algorithm that is especially\n       targeted at high-speed, long-distance networks with enhanced\n       congestion recovery.\n\nTCP::congestion <cubic>\n\n     * Specifies that the system uses a TCP algorithm that is optimized\n       for high bandwidth, high delay networks.\n\nTCP::congestion <westwood>\n\n     * Specifies that the system uses a TCP algorithm based on a bandwidth\n       estimation metric.","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side congestion control to Woodside.\n    clientside {\n        log local0. \"Client: congestion [TCP::congestion] to woodside\"\n        TCP::congestion woodside\n    }\n    # Set server-side congestion control to High-Speed.\n    serverside {\n        log local0. \"Server: congestion [TCP::congestion] to highspeed\"\n        TCP::congestion highspeed\n    }\n}","returnValue":"TCP::congestion returns the current congestion control algorithm."},
{"commandName":"TCP::delayed_ack","description":"Enables or disables TCP delayed acknowledgements.\nWhen enabled, minimizes acknowledgment traffic from BIG-IP by waiting 100ms for additional data to arrive, allowing aggregated ACKs. Can have negative performance implications for some remote hosts depending on their congestion control implementation.\n\nSyntax\n\nTCP::delayed_ack <enable|disable>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side delayed ACKs to enabled.\n    clientside {\n        TCP::delayed_ack enable\n    }\n    # Set server-side delayed ACKs to disabled.\n    serverside {\n        TCP::delayed_ack disable\n    }\n}","returnValue":"None."},
{"commandName":"TCP::dsack","description":"Enables or disables TCP duplicate selective acknowledgements.\nWhen enabled, accepts D-SACKs from remote hosts, which explicitly acknowledge duplicate packets and allow more accurate reaction to out-of-order and late packets.  See RFC3708 for details.\n\nSyntax\n\nTCP::dsack <enable|disable>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side D-SACKs to enabled.\n    clientside {\n        TCP::dsack enable\n    }\n    # Set server-side D-SACKs to disabled.\n    serverside {\n        TCP::dsack disable\n    }\n}","returnValue":"None."},
{"commandName":"TCP::earlyrxmit","description":"Early retransmit allows TCP to assume a packet is lost after fewer than the standard number of duplicate ACKs, if there is no way to send new data and generate more duplicate ACKs (specified in RFC 5827).\n\nSyntax\n\nTCP::earlyrxmit [<enable|disable>]","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side early retransmit to enabled.\n    clientside {\n        log local0. \"Client: earlyrxmit [TCP::earlyrxmit], enabling\"\n        TCP::earlyrxmit enable\n    }\n    # Set server-side early retransmit to disabled.\n    serverside {\n        log local0. \"Server: earlyrxmit [TCP::earlyrxmit], disabling\"\n        TCP::earlyrxmit disable\n    }\n}","returnValue":"TCP::earlyrxmit returns whether TCP early retransmit is enabled."},
{"commandName":"TCP::ecn","description":"Enables or disables TCP explicit congestion notification.\nWhen enabled, respond to explicit router notification of congestion by invoking the TCP congestion response.\nSee RFC3168 for details.\n\nSyntax\n\nTCP::ecn <enable|disable>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    TCP::ecn disable\n}","returnValue":"None."},
{"commandName":"TCP::enhanced_loss_recovery","description":"Enables or disables enhanced loss recovery which recovers from random packet loss more effectively.\n\nSyntax\n\nTCP::enhanced_loss_recovery <enable|disable>","examples":"when CLIENT_ACCEPTED {\n    TCP::enhanced_loss_recovery enable\n}","returnValue":"None."},
{"commandName":"TCP::idletime","description":"Sets the number of seconds before BIG-IP deletes connections with no traffic. A value of zero indicates no time limit.\n\nSyntax\n\nTCP::idletime <timeval>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set server-side idletime to 100.\n    TCP::idletime 100\n}","returnValue":"None."},
{"commandName":"TCP::limxmit","description":"Enables or disables TCP limited transmit recovery, which sends new data in response to duplicate acks. See RFC3042 for details.\n\nSyntax\n\nTCP::limxmit <enable|disable>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set server-side limited transmit to disable.\n    TCP::limxmit disable\n}","returnValue":"None."},
{"commandName":"TCP::local_port","description":"Returns the local port/service number of the specified side, or the current context (client or server) if there is no argument.\nThis command is equivalent to the BIG-IP 4.X variable local_port. When used\nin a clientside context, this command returns the client-side TCP\ndestination port. When used in a serverside context, this command\nreturns the server-side TCP source port.\n\nSyntax\n\nTCP::local_port [ clientside | serverside ]\n\nTCP::local_port\n\n     * Returns the local TCP port/service number of the current context's\n       TCP connection.\n\nTCP::local_port clientside\n\n     * Returns the local TCP port/service number of the client-side TCP\n       connection.\n\nTCP::local_port serverside\n\n     * Returns the local TCP port/service number of the server-side TCP\n       connection.","examples":"when SERVER_CONNECTED {\n  # This logs information about the TCP connections on *both* sides of the fullproxy\n  set client_remote \"[IP::client_addr]:[TCP::client_port]\"\n  set client_local  \"[IP::local_addr clientside]:[TCP::local_port clientside]\"\n  set server_local  \"[IP::local_addr]:[TCP::local_port]\"\n  set server_remote \"[IP::server_addr]:[TCP::server_port]\"\n  log local0. \"Got connection: Client($client_remote)<->($client_local)LTM($server_local)<->($server_remote)Server\"\n}\n\nExample output:\n\n<SERVER_CONNECTED>: Got connection: Client(10.3.3.20:33798)<->(10.3.3.111:80)LTM(10.1.1.110:33798)<->(10.1.1.200:80)Server","returnValue":"The local port."},
{"commandName":"TCP::lossfilter","description":"Sets the maximum size burst loss (in packets) and maximum number of packets per million lost before triggering congestion response.\n  * Burst range is valid from 0 to 32. Higher values decrease the\n    chance of performing congestion control.\n  * Rate range is valid from 0 to 1,000,000. Rate is X packets lost per\n    million before congestion control kicks in.\n\nSyntax\n\nTCP::lossfilter <rate> <burst>","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side loss filter.\n    # Ignore up to 150 losses per million packets and burst losses of up to 10 packets.\n    clientside {\n        TCP::lossfilter 150 10\n    }\n    # No loss filter on server-side.\n    serverside {\n        TCP::lossfilter 0 0\n    }\n}","returnValue":"None."},
{"commandName":"TCP::lossfilterrate","description":"Gets the maximum number of packets per million lost before triggering congestion response.\n  * Rate range is valid from 0 to 1,000,000. Rate is X packets lost per\n    million before congestion control kicks in.\n\nSyntax\n\nTCP::lossfilterrate","examples":"when SERVER_CONNECTED {\n    # Remove loss filter if present\n    if { [TCP::lossfilterrate] > 0 } {\n        TCP::lossfilter 0 0\n    }\n}","returnValue":"TCP Loss Ignore Rate in packets per million."},
{"commandName":"TCP::lossfilterburst","description":"Gets the maximum size burst loss (in packets) before triggering congestion response.\n  * Burst range is valid from 0 to 32. Higher values decrease the\n    chance of performing congestion control.\n\nSyntax\n\nTCP::lossfilterburst","examples":"when SERVER_CONNECTED {\n    # Set loss filter burst to a maximum of 3\n    if { [TCP::lossfilterburst] > 3 } {\n        TCP::lossfilter [TCP::lossfilterrate] 3\n    }\n}","returnValue":"TCP Loss Ignore Burst in packets."},
{"commandName":"TCP::mss","description":"Returns the initial connection negotiated MSS. It does not deduct bytes for any common TCP options present in data packets are not deducted. In other words, it is the minimum of the MSS options in the SYN and SYN-ACK packets, or the MSS default of 536 bytes if one packet is missing the option.\n\nSyntax\n\nTCP::mss\n\n     * Returns the MSS for a TCP connection.","examples":"when HTTP_REQUEST {\n  if { [TCP::mss] >= 1280 } {\n    COMPRESS::disable\n  }\n}","returnValue":"MSS in bytes."},
{"commandName":"TCP::nagle","description":"Enables or disables the Nagle algorithm on the current TCP connection.\nNagle waits for additional data before sending undersized packets, see RFC896 for details.\nThe auto option enables or disables Nagle based on connection conditions.\n\nSyntax\n\nTCP::nagle [enable | disable | auto]\n\n     * Enables or disables the Nagle algorithm on the current TCP connection.\n     * The auto option enables or disables Nagle based on connection conditions.","examples":"# Disable Nagle for SSH and telnet\nwhen CLIENT_ACCEPTED {\n  switch [TCP::client_port] {\n    22 -\n    23 { TCP::nagle disable }\n    default { TCP::nagle enable }\n  }\n}\n\n# Change the TCP Nagle mode to auto.\nwhen CLIENT_ACCEPTED {\n    TCP::nagle auto\n}","returnValue":"None."},
{"commandName":"TCP::naglemode","description":"Returns the Nagle mode of a TCP flow.\n\nSyntax\n\nTCP::naglemode","examples":"# Get the TCP Nagle mode of the TCP flow.\nwhen CLIENT_ACCEPTED {\n    log local0. \"TCP Nagle mode: [TCP::naglemode]\"\n}","returnValue":"- enabled\n- disabled\n- auto"},
{"commandName":"TCP::naglestate","description":"If the Nagle mode is \"enabled\" or \"disabled\", it returns that mode. If \"auto\", it returns the current selection of the autotuning.","examples":"# Get the TCP Nagle state of the TCP flow.\nwhen CLIENT_ACCEPTED {\n    log local0. \"TCP Nagle state: [TCP::naglestate]\"\n}","returnValue":"The string \"disabled\" or \"enabled\""},
{"commandName":"TCP::notify","description":"This command has two uses, which are unrelated to one another:\n  1. to indicate the end of a message when TCP message-based load-balancing is in effect;\n  2. to raise the USER_REQUEST or USER_RESPONSE event.\n\nThe BIG-IP LTM module supports TCP message-based load-balancing. This is enabled by applying an mblb profile to an LTM Virtual Server that also has a tcp profile applied. Note that currently (up to and including 11.4.1), the mblb profile can only be added using tmsh. There is no mechanism for adding it via the Web UI. When an mblb profile is applied, the Virtual Server provides TCP message-based load-balancing. Normally, TCP is a stream-oriented protocol rather than a message-oriented protocol (like UDP). When a single TCP connection is used to deliver multiple discreet messages, TMOS must be able to distinguish individual messages in order to load-balance them. This requires TMOS to reliably find each message boundary. Unless TMOS has built-in handling code for the underlying application protocol (as it does for Diameter and SIP, for example), an iRule must be used to indicate to the connection handling code where message boundaries occur.\n\nTCP::notify is used for this purpose. In particular, when TCP::collect is invoked, the system begins collecting incoming TCP data into a buffer. The data in this buffer may may be accessed using TCP::payload, and it may be removed from the buffer by invoking TCP::release. When TCP::notify is invoked in the same event as TCP::release, it notifies TMOS that the data released constitutes a single message. NOTE: it is safest – and strongly recommended – that TCP::notify be called immediately after TCP::release. For this purpose, TCP::release should also always be invoked with its <length> parameter, since it is possible for the payload buffer to contain data beyond a single message boundary.\n\nIt is necessary to use TCP::notify request if the command is invoked in the client-side context (usually in CLIENT_DATA), and TCP::notify response if the command is invoked in the server-side context (usually in SERVER_DATA). A compile\\/load error will be raised otherwise. Aside from this, for TCP message-based load-balancing, there is no functional difference between the request and response sub-commands.\n\nIf TCP::notify is used in an iRule not associated with a TCP mblb Virtual Server, the command causes either the USER_REQUEST or the USER_RESPONSE event to be raised. The event may or may not be raised immediately upon calling TCP::notify. In particular, the USER_REQUEST event will not be raised until the server-side TCP connection is complete, and, if there is data waiting to be sent to the server, it will not be raised until those data are sent. Similarly, if there is data waiting to be sent to the client, the USER_RESPONSE event will not be raised until the data are sent. The concept of \"data waiting to be sent\" is very difficult to precisely define; it refers to application data that has finished client-side processing.\n\nSyntax\n\nTCP::notify [request | response | eom]\n\nTCP::notify request\n\n     * Causes the USER_REQUEST event to be raised; or\n     * Indicates that data released from the payload buffer is a single\n       message in the clientside context.\n\nTCP::notify response\n\n     * Causes the USER_RESPONSE event to be raised; or\n     * Indicates that data released from the payload buffer is a single\n       message in the serverside context.\n\nTCP::notify eom\n\n     * Introduced in v11.5\n     * Indicates end of message to the proxy.","examples":"Provide TCP message-based load-balancing for SUPL ILP messages.\nIn these messages, the first two bytes are an unsigned\ninteger that provides the message length in octets. The next three\nbytes are the ILP message version. The four-bytes following are assumed\nto be a session identifier (in ILP, it can be more complicated than\nthis for the session ID, but this simplifying assumption is made for\nthe purposes of this example). This code persists messages (rather than\nconnections) based on the message session ID:\n\nwhen CLIENT_ACCEPTED {\n        set message_length              0\n        set collected_length            0\n        set at_msg_start                1\n\n        TCP::collect\n}\n\n\nwhen CLIENT_DATA {\n        set data [TCP::payload]\n\n        set collected_length [TCP::payload length]\n        if { $at_msg_start } {\n                # it is possible that not enough data have yet been collected to\n                # extract the message length and session ID.  If so, keep collecting\n                # until there is enough data in the payload buffer\n                if { $collected_length < 11 } {\n                        TCP::collect\n                        return\n                }\n\n                binary scan $data \"S1x3W\" message_length slc_session\n\n                #log local0. \"Start of message, length = $message_length, collected = ($collected_length), slc_session = $slc_session\"\n\n                # notice that persistence is per-message (because of the mblb profile) rather\n                # than per-connection, as one would typically find with a tcp VS\n                persist uie $slc_session\n\n                # binary scan does not support unsigned types in the version of\n                # Tcl used by iRules, so the bitwise-and (&) below casts the extracted\n                # value to an unsigned two-byte integer\n                set message_length [expr { $message_length & 0xffff }]\n                set at_msg_start 0\n        }\n        #else {\n        #        log local0. \" ... collected = ($collected_length)\"\n        #}\n\n        if { $collected_length >= $message_length } {\n                #log local0. \" ... end of message, collected = ($collected_length)\"\n                set at_msg_start 1\n\n                TCP::release $message_length\n                TCP::notify request\n                #log local0. \" ... after purge, length = ([TCP::payload length])\"\n        }\n\n        TCP::collect\n}\n\n\nDetach the serverside connection after all the data has\nbeen delivered to the client:\n\nwhen SERVER_DATA {\n    log local0.debug \"Received SERVER response ... [TCP::payload]\"\n    if { [TCP::payload] ends_with $EOT } {\n        TCP::notify response\n    }\n    TCP::release\n    TCP::collect\n}\n\nwhen USER_RESPONSE {\n    LB::detach\n    log local0.debug \"Detaches server connection ... \"\n    if {[TCP::payload length] > 0} {\n        # %TODO%\n        # Process additional client requests here ...\n    }\n}","returnValue":"None."},
{"commandName":"TCP::offset","description":"Returns the number of bytes currently held in memory via\nTCP::collect. This data is available via TCP::payload.\n\nSyntax\n\nTCP::offset\n\n     * Returns the number of bytes currently held in memory via\n       TCP::collect.","examples":"when CLIENT_ACCEPTED {\n  TCP::collect\n}\nwhen CLIENT_DATA {\n  set datalen [TCP::offset]\n  log local0.info \"Collected $datalen bytes of data!\"\n  TCP::release\n}","returnValue":"The number of bytes collected."},
{"commandName":"TCP::option","description":"Gets or sets the value of the specified option of the TCP header.\nThe TCP::option get command is only functional when BIG-IP has been configured to collect options before the iRule is called. In v10, this is done with a db variable and is effective only on the clientside. When called in the serverside context it returns an error indicating that the specified option was not configured for collection.\n\nIn v11, this is configured through the TCP profile and the command can be used in either the serverside context or the clientside, depending on the profile configuration. TCP::option set is available only in v11 and can be used in either context.\n\nSyntax\n\nTCP::option get <option>\n\n     * Returns the specified TCP option kind value. If the requested\n       option kind was not configured for collection, an error indicating\n       so is returned instead. If the option kind was specified but has\n       not yet been seen on the current connection, the command returns\n       null. If the requested option kind has been configured for\n       collection and has been seen on the connection, the command returns\n       the raw option kind value. See version-specific sections below\n       regarding configuring option kinds for collection.\n\nTCP::option set <option number> <value> <next|all>\n\n     * Introduced in v11\n     * Allows you to set (or add) TCP option information for the specified\n       option field\n\nTCP::option noset <option number>\n\n     * Introduced in v11\n     * Allows you to specify particular TCP options that should not be\n       set.\n\n\nConfiguring for TCP option collection - BIG-IP version >= 10.2.0-HF2 and < 11.0.0\n\n   The Rules.tcpoption.settings database variable must be configured in\n   order to use the TCP::option command in 10.2.0HF2 < 11.0, specifying\n   the option values to be collected. In TMOS versions 10.2.0 HF2 through\n   10.2.2, the BIG-IP system must be restarted using the bigstart restart\n   command after setting or modifying the variable. Starting with release\n   10.2.2 HF1 the restart is no longer required.\n   Configure the db variable Rules.Tcpoption.settings with a string in the\n   following format:\n   [option,<first|last>],[option,<first|last>],[option,<first|last>]...\n\n   Note: Do not change the unrelated db setting Rules.tcpoption.virtuals\n   from its default value of null in 10.2.0-hf2. This will cause tmm to\n   repeatedly restart.\n\nConfiguring for TCP option collection - BIG-IP version 11.0.0 and up\n\n   Beginning with v11.0.0 the 'db variable Rules.TCPoption.settings' no\n   longer exists and this functionality has been 'baked in'. It is now\n   part of the tcp profile and is configured as follows:\n\n   create ltm profile tcp PROFILE_NAME tcp-options \"{option <first|last>} {option<first|last>}\"\n      option\n         * A number between 2 and 255 (inclusive) that indicates the TCP\n           option kind to be collected.\n\n      first | last\n         * Indicates whether the system will retain the first instance of the\n           specified option kind, or the most recent.\n\n   When an option kind is marked first, the system will search for the\n   specified option kind only until it has been seen on the current\n   connection. Once seen, the TCP::option command will return that value\n   for the life of the connection.\n\n   When an option kind is marked last, the system will continue to search\n   for the specified option kind over the lifetime of the connection. The\n   TCP::option command will return the last value seen at the time it is\n   called.\n\n   If all option kinds are marked first, and all specified option kinds\n   have been seen on that TCP connection, no further searching will be\n   performed for the life of the connection.\n\n   For example, the following command configures the BIG-IP system to save\n   the value of the first instance of option kind 8, and the value of the\n   last seen instance of option kind 28:\n    v10: b db Rules.Tcpoption.settings [8,first],[28,last]\n    v11: create ltm profile tcp tcp_options profile-name \"{8 first} {28\n   last}\"","examples":"#Accessing TCP Options\nwhen CLIENT_ACCEPTED {\n  set INPUT_OPTION [TCP::option get 28]\n  binary scan $INPUT_OPTION c ver\n  set ver [expr { $ver & 0xff }]\n  set forwarded_ip [IP::addr parse $INPUT_OPTION 1]\n  log local0. \"The IP address was $forwarded_ip for version $ver\"\n}\n\n#Insert the client REAL IP (mostly used when the client IP is SNATted).\nwhen SERVER_CONNECTED {\n    scan [IP::client_addr] {%d.%d.%d.%d} a b c d\n    TCP::option set 29 [binary format cccc $a $b $c $d] all\n}","returnValue":"With the \"get\" keyword, returns the specified TCP option kind value. If the requested option kind was not configured for collection, an error indicating so is returned instead. If the option kind was specified but has not yet been seen on the current connection, the command returns null. If the requested option kind has been configured for collection and has been seen on the connection, the command returns the raw option kind value."},
{"commandName":"TCP::pacing","description":"Rate pacing limits the data send rate to the physical limitations of the interface to reduce the chance of queue drops.\n\nSyntax\n\nTCP::pacing [<enable|disable>]","examples":"when SERVER_CONNECTED {\n    log local0. \"Client: [client_addr]:[client_port] - Server: [server_addr]:[server_port].\"\n    # Set client-side rate pacing to enabled.\n    clientside {\n        log local0. \"Client: pacing [TCP::pacing], enabling\"\n        TCP::pacing enable\n    }\n    # Set server-side rate pacing to disabled.\n    serverside {\n        log local0. \"Server: pacing [TCP::pacing], disabling\"\n        TCP::pacing disable\n    }\n}","returnValue":"TCP::pacing returns whether TCP rate pacing is enabled."},
{"commandName":"TCP::payload","description":"Returns the accumulated TCP data content, or replaces collected payload with the specified data.\n\nSyntax\n\nTCP::payload [<size>]\n\n     * Returns the accumulated TCP data content. If <size> is specified,\n       and more than <size> bytes are available, only the first <size>\n       bytes of collected data are returned.\n\nTCP::payload replace <offset> <length> <data>\n\n     * Replaces <length> bytes of the collected payload data starting at\n       <offset> with the given <data>.\n\nTCP::payload length\n\n     * Returns the amount of accumulated TCP data content in bytes.\n\n   Note: Currently, iRules usually treats binary data in TCL variables as\n   UTF-8 strings. Therefore, care must be taken when processing binary TCP\n   payloads. In particular, do not assign the result of TCP::payload to a\n   variable if non-text data should be processed literally. See the third\n   example below for a way to do a binary search-and-replace in a\n   TCP::payload. TCL variables explicitly created as binary data (e.g. via\n   the binary format command) are not treated as UTF-8 strings. There is\n   an outstanding enhancement request (tracked as CR47762 / BZ273220) to\n   treat TCL variables as binary data (rather than UTF-8 strings) as\n   appropriate.","examples":"when CLIENT_ACCEPTED {\n  TCP::collect 15\n}\nwhen CLIENT_DATA {\n  if { [TCP::payload 15] contains \"XYZ\" } {\n     pool xyz_servers\n  } else {\n     pool web_servers\n }\n TCP::release\n}\n\n\nwhen CLIENT_ACCEPTED {\n  TCP::collect\n}\nwhen CLIENT_DATA {\n  # empty payload entirely so there is no packet to send to the server\n  TCP::payload replace 0 [TCP::payload length] \"\"\n\n  # craft a string to hold our  packet data, 0x01 0x00 0x00 0x00 0x02 0x00 0x000x00 0x03 0x00 0x00 0x00\n  set packetdata [binary format i1i1i1 1 2 3 ]\n\n  # then fill payload with our own data from arbitrary length string called packetdata to send to the server\n  # this actually inserts it at the start of the packet, but because we emptiedthe packet above it becomes the new packet\n  TCP::payload replace 0 0 $packetdata\n\n  # release the payload to the server\n  TCP::release\n\n  # set up to grab the next packet\n  TCP::collect\n}\n\n\nwhen CLIENT_ACCEPTED {\n  TCP::collect\n}\nwhen CLIENT_DATA {\n  #\n  # Do a regex search and replace of binary TCP data\n  #\n  if { [regexp -indices \"\\x61\\x62\\x63\\x64\\x65\\x66\" [TCP::payload] firstmatch] }{\n    set matchlen [expr [lindex $firstmatch 1] - [lindex $firstmatch 0] + 1]\n    set replacement [binary format c* {97 98 99 0 100 101 102}]\n    TCP::payload replace [lindex $firstmatch 0] $matchlen $replacement\n    TCP::release\n  }\n}","returnValue":""},
{"commandName":"TCP::proxybuffer","description":"Sets thresholds at which the proxy buffer accepts (low) and stops accepting (high) new data, in bytes.\n\nSyntax\n\nTCP::proxybuffer <low> <high>","examples":"when SERVER_CONNECTED {\n    TCP::proxybuffer 100000 500000\n}","returnValue":"None."},
{"commandName":"TCP::proxybufferhigh","description":"Gets the threshold at which the proxy buffer stops accepting new data, in bytes.\n\nSyntax\n\nTCP::proxybufferhigh","examples":"when SERVER_CONNECTED {\n    log local0.debug \"[TCP::proxybufferhigh]\"\n}","returnValue":"The proxy buffer high threshold."},
{"commandName":"TCP::proxybufferlow","description":"Gets the threshold at which the proxy buffer starts sending new data, in bytes.\n\nSyntax\n\nTCP::proxybufferlow","examples":"when SERVER_CONNECTED {\n    log local0.debug \"[TCP::proxybufferlow]\"\n}","returnValue":"The proxy buffer low threshold."},
{"commandName":"TCP::push_flag","description":"TCP::push_flag returns the PUSH flag mode of a TCP connection.\nTCP::push_flag mode sets the PUSH flag mode to specified mode.\n\nSyntax\n\n\nTCP::push_flag [<default|none|one|auto>]\n\nTCP::push_flag\n\n     * Returns the PUSH flag mode of a TCP connection.\n\nTCP::push_flag <default>\n\n     * Sets the PUSH flag mode of a TCP connection to default.\n\nTCP::push_flag <none>\n\n     * Sets the PUSH flag mode of a TCP connection to none.\n\nTCP::push_flag <one>\n\n     * Sets the PUSH flag mode of a TCP connection to one.\n\nTCP::push_flag <auto>\n\n     * Sets the PUSH flag mode of a TCP connection to auto.","examples":"# get/set the PUSH flag mode of the TCP flow.\nwhen CLIENT_ACCEPTED {\n    log local0. \"TCP set PUSH flag mode: [TCP::push_flag auto]\"\n    log local0. \"TCP get PUSH flag more: [TCP::push_flag]\"\n}","returnValue":"TCP::push_flag returns the PUSH flag mode."},
{"commandName":"TCP::rcv_scale","description":"Returns the receive window scale advertised by the remote host.\n\nSyntax\n\nTCP::rcv_scale","examples":"when CLIENT_ACCEPTED {\n    # Log rcv_scale.\n    log local0. \"rcv_scale: [TCP::rcv_scale]\"\n}","returnValue":"The bitshift associated with the remote host window scale."},
{"commandName":"TCP::rcv_size","description":"TCP configuration limits the advertised received window to control the memory impact of any single connection.\n\nSyntax\n\nTCP::rcv_size","examples":"when CLIENT_ACCEPTED {\n    # Get BIGIP's receive window size.\n    log local0. \"BIGIP's rcv wnd size: [TCP::rcv_size]\"\n}\nwhen CLIENT_CLOSED {\n    # Get BIGIP's receive window size.\n    log local0. \"BIGIP's rcv wnd size: [TCP::rcv_size]\"\n}","returnValue":"The maximum receive window in bytes."},
{"commandName":"TCP::recvwnd","description":"TCP::recvwnd returns the receive window size of a TCP connection.\nTCP::recvwnd WINDOW_SIZE sets the receive window to WINDOW_SIZE bytes.","examples":"# Get the receive window size of the TCP flow.\n    when CLIENT_ACCEPTED {\n        log local0. \"TCP set receive window: [TCP::recvwnd 100000]\"\n        log local0. \"TCP get receive window: [TCP::recvwnd]\"\n    }","returnValue":"TCP::recvwnd returns the number of bytes that can be stored at the receive window."},
{"commandName":"TCP::release","description":"Causes TCP to release and flush collected data, and allow other\nprotocol layers to resume processing the connection.\n\nReturns the number of bytes actually released. If specified, up to length bytes are released; the return value will tell you how many bytes actually were.\n\nSyntax\n\nTCP::release [<length>]\n\n     * Causes TCP to release and flush collected data, and allow other\n       protocol layers to resume processing the connection. Returns the\n       number of bytes actually released. If specified, up to length bytes\n       are released; the return value will tell you how many bytes\n       actually were.","examples":"when CLIENT_ACCEPTED {\n  TCP::collect 15\n}\nwhen CLIENT_DATA {\n  if { [TCP::payload 15] contains \"XYZ\" } {\n     pool xyz_servers\n  } else {\n     pool web_servers\n }\n # HTTP_REQUEST will not fire until we release the collected TCP data\n TCP::release\n}","returnValue":"The number of bytes released."},
{"commandName":"TCP::remote_port","description":"Returns the remote TCP port/service number of a TCP connection. This\ncommand is equivalent to the BIG-IP 4.X variable remote_port. When used\nin a clientside context, this command returns the client-side TCP\nsource port, and is equivalent to the TCP::client_port command.\nWhen used in a serverside context, this command returns the server-side\nTCP destination port, and is equivalent to the TCP::server_port\ncommand.\n\nSyntax\n\nTCP::remote_port [ clientside | serverside ]\n\nTCP::remote_port\n\n     * Returns the remote TCP port/service number of the current context's\n       TCP connection.\n\nTCP::remote_port clientside\n\n     * Returns the remote TCP port/service number of the client-side TCP\n       connection.\n\nTCP::remote_port serverside\n\n     * Returns the remote TCP port/service number of the server-side TCP\n       connection.","examples":"when HTTP_REQUEST {\n  if { [HTTP::uri] contains \"/secure/\" } {\n    pool ssl_pool\n  } else {\n    pool http_pool\n  }\n}\nwhen SERVER_CONNECTED {\n  if {[TCP::remote_port] != 443} {\n    SSL::disable\n  }\n}\n\n\nwhen SERVER_CONNECTED {\n  # This logs information about the TCP connections on *both* sides of the fullproxy\n  set client_remote \"[IP::client_addr]:[TCP::client_port]\"\n  set client_local  \"[IP::local_addr clientside]:[TCP::local_port clientside]\"\n  set server_local  \"[IP::local_addr]:[TCP::local_port]\"\n  set server_remote \"[IP::server_addr]:[TCP::server_port]\"\n  log local0. \"Got connection: Client($client_remote)<->($client_local)LTM($server_local)<->($server_remote)Server\"\n}\n\nExample output:\n\n<SERVER_CONNECTED>: Got connection: Client(10.3.3.20:33798)<->(10.3.3.111:80)LTM(10.1.1.110:33798)<->(10.1.1.200:80)Server","returnValue":""},
{"commandName":"TCP::respond","description":"Sends the specified data directly to the peer. This command can be used\nto complete a protocol handshake via an iRule.\n\nSyntax\n\nTCP::respond <data>\n\n     * Sends the specified data directly to the peer.","examples":"when HTTP_REQUEST {\nif {([HTTP::method] eq \"POST\") && [HTTP::header exists \"Expect\"] } {\n      HTTP::header remove \"Expect\"\n      TCP::respond \"HTTP/1.1 100 Continue\\r\\n\\r\\n\"\n   }\n}\n\n\nwhen SERVER_CONNECTED {\n    peer { TCP::collect 4 }\n}\nwhen CLIENT_DATA {\n    if { [TCP::payload] starts_with \"EHLO\" } {\n        TCP::respond \"500 5.3.3 Unrecognized command\\r\\n\"\n        TCP::payload replace 0 [TCP::payload length] \"\"\n    }\n    TCP::release\n}","returnValue":"None."},
{"commandName":"TCP::rt_metrics_timeout","description":"If the TCP profile enables cmetrics-cache, then the entries there remain for a number of seconds equivalent to cmetrics-cache-timeout. This iRule supercedes that setting.\n\nSyntax\n\nTCP::rt_metrics_timeout <timeout>","examples":"when CLIENT_CLOSED {\n    TCP::rt_metrics_timeout 300\n}","returnValue":"None."},
{"commandName":"TCP::rto","description":"Returns the last setting to which the retransmit timer was set in milliseconds. It does not include time elapsed since the timer was set.","examples":"when CLIENT_CLOSED {\n    set rto [TCP::rto]\n    log local0. \"Final RTO value is $rto\"\n}","returnValue":"Retransmit timer value in milliseconds."},
{"commandName":"TCP::rtt","description":"Returns the smoothed round-trip time estimate for a TCP connection.\n\nSyntax\n\nTCP::rtt\n\n     * Returns the smoothed round-trip time estimate for a TCP connection.\n\n       Note that the value returned is in units of \"1/32 of a millisecond\".\n       (Divide the returned value by 32 to get the actual round trip time in milliseconds.)\n       Note that the rtt takes some time to converge, so we recommend using ROUTE::rttvar\n       to get the statistical variance of rtt in 1/16 ms intervals & cull outliers.","examples":"when HTTP_RESPONSE {\nclientside { set rtt [TCP::rtt] }\nif {$rtt < 1600 } {\n      log \"NOcompress rtt=$rtt\"\n      COMPRESS::disable\n   }\nelse {\n      log \"compress rtt=$rtt\"\n      COMPRESS::enable\n      COMPRESS::gzip level 9\n   }\n}","returnValue":""},
{"commandName":"TCP::rttvar","description":"Returns the Round Trip Time Variance, which is an indication of path jitter. TCP uses this figure, combined with RTT, to compute the RTO.\n\nNote that the value returned is in units of \"1/16 of a millisecond\". Divide the returned value by 16 to get the actual variance in milliseconds.","examples":"when CLIENT_CLOSED {\n    # Log rttvar.\n    log local0. \"rttvar: [TCP::rttvar]\"\n}","returnValue":"The measured RTT variance in units of \"1/16 of a millisecond\". Divide the returned value by 16 to get the actual variance in milliseconds."},
{"commandName":"TCP::sendbuf","description":"TCP::sendbuf returns the send buffer size of a TCP connection.\nTCP::sendbuf BUFFER_SIZE sets the send buffer size to BUFFER_SIZE bytes.","examples":"# Get the send buffer size of the TCP flow.\n    when CLIENT_ACCEPTED {\n        log local0. \"TCP set send buffer: [TCP::sendbuf 100000]\"\n        log local0. \"TCP get send buffer: [TCP::sendbuf]\"\n    }","returnValue":"TCP::sendbuf returns the number of bytes that can be stored at the send buffer."},
{"commandName":"TCP::rexmt_thresh","description":"TCP::rexmt_thresh returns the retransmission threshold of a TCP connection.\nTCP::rexmt_thresh TCP_REXMT_THRESH_VALUE sets the retransmission threshold to specified value.","examples":"# Get/set the retransmission threshold of the TCP flow.\n    when CLIENT_ACCEPTED {\n        log local0. \"TCP set rtx thresh: [TCP::rexmt_thresh 100]\"\n        log local0. \"TCP get rtx thresh: [TCP::rexmt_thresh]\"\n    }","returnValue":"TCP::rexmt_thresh returns the retransmission threshold of a TCP connection."},
{"commandName":"TCP::server_port","description":"Returns the remote TCP port/service number of the serverside TCP\nconnection. This command is equivalent to the TCP::remote_port command\nin a serverside context, and to the BIG-IP 4.x variable server_port.\n\nSyntax\n\nTCP::server_port\n\n     * Returns the remote TCP port/service number of the serverside TCP\n       connection.","examples":"when SERVER_CONNECTED {\n   # This logs information about:\n   #  * the clientside part of the client<->LTM connection, and\n   #  * the serverside part of the LTM<->server connection.\nlog local0.info \"Complete connection: [IP::client_addr]:[TCP::client_port]<->LTM<->[IP::server_addr]:[TCP::server_port]\"\n}","returnValue":""},
{"commandName":"TCP::setmss","description":"This iRule command sets the TCP max segment size in bytes.\nThe MSS does not consider the length of any common TCP options.\nUsers should set MSS to the desired path IP packet size, minus the\nIP header length (typically 20 bytes), minus the minimum TCP header\nlength of 20 bytes.\n\nTCP will automatically apply the length of common options when\npartitioning data for delivery.\n\nSyntax\n\nTCP::setmss <mssval>","examples":"# Match clientside MSS to serverside MSS\nwhen SERVER_CONNECTED {\n    set cli_mss [clientside { TCP::mss }]\n    set svr_mss [TCP::mss]\n    if { $cli_mss > $svr_mss } {\n        clientside { TCP::setmss $svr_mss }\n    }\n}","returnValue":""},
{"commandName":"TCP::snd_cwnd","description":"Returns the TCP congestion window (cwnd), the maximum\nunacknowledged data the connection can send due to the congestion\ncontrol algorithm.\n\nThe actual amount of outstanding data may be lower, due to lack of\napplication data to send, the remote host's advertised receive\nwindow, or the size of the BIG-IP send buffer.","examples":"when CLIENT_ACCEPTED {\n    # Get BIGIP's initial congestion window.\n    log local0. \"BIGIP's cwnd: [TCP::snd_cwnd]\"\n}\nwhen CLIENT_CLOSED {\n    # Get BIGIP's last congestion window.\n    log local0. \"BIGIP's cwnd: [TCP::snd_cwnd]\"\n}","returnValue":"The cwnd in bytes."},
{"commandName":"TCP::snd_scale","description":"Returns the receive window scale advertised by the local host.\n\nSyntax\n\nTCP::snd_scale","examples":"when CLIENT_ACCEPTED {\n    # Log snd_scale.\n    log local0. \"snd_scale: [TCP::snd_scale]\"\n}","returnValue":"The bitshift associated with the local host window scale."},
{"commandName":"TCP::snd_ssthresh","description":"The slow start threshold (ssthresh) is the point at which the\ncongestion window (cwnd) grows less aggressively. When the cwnd is\nless than ssthresh, it roughly doubles for every cwnd worth of\nacknowledged data. When cwnd is greater than ssthresh, it increases\nby approximately one MSS for each cwnd worth of acknowledged data.\n\nssthresh starts at 1,073,725,440 bytes unless there is a cmetrics\ncache entry. When TCP detects packet loss it usually sets ssthresh\nto a value between 1/2 cwnd and cwnd, depending on  connection\nconditions and the congestion control algorithm.","examples":"when CLIENT_ACCEPTED {\n    # Get BIGIP's initial slow-start threshold.\n    log local0. \"BIGIP's ssthresh: [TCP::snd_ssthresh]\"\n}\nwhen CLIENT_CLOSED {\n    # Get BIGIP's last slow-start threshold.\n    log local0. \"BIGIP's ssthresh: [TCP::snd_ssthresh]\"\n}","returnValue":"The connection slow start threshold in bytes."},
{"commandName":"TCP::snd_wnd","description":"Returns the remote host's advertised receive window. If smaller\nthan the congestion window (cwnd) and send buffer size, this limits\nthe amount of outstanding data on the connection.","examples":"when CLIENT_ACCEPTED {\n    # Get Client's initial advertised window.\n    log local0. \"Client's advertised rwnd: [TCP::snd_wnd]\"\n}\nwhen CLIENT_CLOSED {\n    # Get Client's last advertised window.\n    log local0. \"Client's advertised rwnd: [TCP::snd_wnd]\"\n}","returnValue":"The advertised receive window (rwnd) in bytes."},
{"commandName":"TCP::unused_port","description":"Returns an unused TCP port for the specified IP tuple, using the value\nof <hint_port> as a starting point if it is supplied. If no appropriate\nunused local port could be found, 0 is returned.\n\nSyntax\n\n\nTCP::unused_port <remote_addr> <remote_port> <local_addr> [<hint_port>]\nTCP::unused_port <remote_addr> <remote_port> <local_addr> [<hint_port> <min_port>]\nTCP::unused_port <remote_addr> <remote_port> <local_addr> [<hint_port> <min_port> <max_port>]\n\n   * Returns an unused TCP port for the specified IP tuple, using the value\n   of <hint_port> as a starting point if it is supplied. If no appropriate\n   unused local port could be found, 0 is returned.","examples":"rule rule_unused_port1 {\n    when HTTP_REQUEST {\n    log local0. [TCP::unused_port 192.168.1.124 80 192.168.1.146]\n    }\n}\n\n# 192.168.1.124:80 is a pool member\n# 192.168.1.146 is a self ip\n# The result on /var/log/ltm is like this\n# Aug 22 09:47:44 local/tmm info tmm: Rule rule_unused_port1 <HTTP_REQUEST>: 26479","returnValue":""},
{},
{},
{"commandName":"TMM::cmp_count","description":"This command provides the active number of TMM instances running.\nTo determine the blade the iRule is currently executing on, see the\nTMM::cmp_group page. To determine the CPU ID an iRule is currently\nexecuting on within a blade, see the TMM::cmp_unit page.\n\nSyntax\n\nTMM::cmp_count","examples":"when CLIENT_ACCEPTED {\n  if { [TMM::cmp_count] >= 2 } {\n    set cmpstatus 1\n  } else { set cmpstatus 0 }\n}","returnValue":"Returns the active number of TMM instances running."},
{"commandName":"TMM::cmp_group","description":"This command returns the number (0-x) of the group of the CPU currently\nexecuting the rule. Typically, a group refers to the blade number on a\nchassis system, and is always 0 on other platforms. New meanings may be\nadded for future platform architectures.\nThis is helpful if you believe one CPU is doing something it shouldn't\nand you want to isolate the issue rather than see an aggregate of all\nCPUs.\nTo determine the total number of TMM instances running, see the\nTMM::cmp_count page. To determine the CPU ID an iRule is current\nexecuting on within a blade, see the TMM::cmp_unit page.\n\nNote that use of this command in the RULE_INIT event is restricted\nby the validator in versions prior to v10.2.3 and v11.1.0 (ID342860).\nIt is valid in all other events, and this limitation can be worked\naround in prior versions, as shown in an example below.\n\nSyntax\n\nTMM::cmp_group","examples":"# Note this example won't work in 10.1.0 - 10.2.2 and 11.0.x\n# as the iRule parser doesn't allow these commands in RULE_INIT\nwhen RULE_INIT {\n\n   # Check if we're running on the first CPU right now\nif { [TMM::cmp_unit] == 0 && [TMM::cmp_group] == 0 } {\n      # This execution is happening on the first TMM instance\n      # Conduct any initialization functionality just once here\n      log local0. \"some code\"\n   }\n}\n\n# Instead, you can use an alternate method to hide the TMM::cmp_unit\n# and TMM::cmp_group commands from the parser:\nwhen RULE_INIT {\n\nset tmm_unit_cmd TMM::cmp_unit\nset tmm_group_cmd TMM::cmp_group\n   # Check if we're running on the first CPU right now\nif {[eval $tmm_unit_cmd] == 0 && [eval $tmm_group_cmd] == 0}{\n      # This execution is happening on the first TMM instance\n      # Conduct any initialization functionality just once here\n      log local0. \"some code\"\n   }\n}","returnValue":"Returns the number (0-x) of the group of the CPU executing the rule."},
{"commandName":"TMM::cmp_groups","description":"","examples":"","returnValue":""},
{"commandName":"TMM::cmp_primary_group","description":"","examples":"","returnValue":""},
{"commandName":"TMM::cmp_unit","description":"This command returns the number (0-x) of the CPUs executing the rule.\nHelpful if you believe one of the CPUs is doing something it shouldn't\nand you want to isolate the issue rather than see an aggregate of all\nCPUs.\nTo determine the total number of TMM instances running, see the\nTMM::cmp_count page. To determine which blade an iRule is current\nexecuting on, see the TMM::cmp_group page.\n\nNote that in versions v10.1.0 through v10.2.2 and v11.0.0, this command\nis valid in all events except RULE_INIT. This limitation was\nremoved in v10.2.3 and v11.1.0 (ID 342860). You can work around this\nlimitation as shown in the example below.\n\nSyntax\n\nTMM::cmp_unit","examples":"# Note this example won't work in 10.1.0 - 10.2.x\n# as the iRule parser doesn't allow TMM::cmp_unit in RULE_INIT\nwhen RULE_INIT {\n\n   # Check if we're running on the first CPU right now\nif {[TMM::cmp_unit] == 0}{\n      # This execution is happening on the first TMM instance\n      # Conduct any initialization functionality just once here\n      log local0. \"some code\"\n   }\n}\n\n# Instead, you can use an alternate method to hide the TMM::cmp_unit\n# command from the parser:\nwhen RULE_INIT {\n\nset tmm_cmd TMM::cmp_unit\n   # Check if we're running on the first CPU right now\nif {[eval $tmm_cmd] == 0}{\n      # This execution is happening on the first TMM instance\n      # Conduct any initialization functionality just once here\n      log local0. \"some code\"\n   }\n}","returnValue":"Returns the number (0-x) of the CPU executing the rule."},
{"commandName":"UDP::client_port","description":"Returns the UDP port/service number of the client system. This command\nis equivalent to the command clientside { UDP::remote_port }.\n\nSyntax\n\nUDP::client_port\n\n     * Returns the UDP port/service number of the client system.","examples":"when CLIENT_DATA {\n  if { [UDP::payload 50] contains \"XYZ\" } {\n    pool xyz_servers\n    persist uie \"[IP::client_addr]:[UDP::client_port]\" 300\n  } else {\n    pool web_servers\n  }\n}\n\n\nwhen SIP_REQUEST {\n  SIP::header insert \"Via\" \"[lindex [split [SIP::via 0] \";\"] 0]received=[IP::client_addr]rport=[UDP::client_port][lindex [split [SIP::via 0] \";\"] 1]\"\n  SIP::header remove \"Via\" 1\n}","returnValue":"Returns the UDP port/service number of the client system"},
{"commandName":"UDP::drop","description":"Drops the current UDP packet without removing the flow from the\nconnection table\n\nSyntax\n\nUDP::drop\n\n     * Drops the current UDP packet without removing the flow from the\n       connection table","examples":"when SERVER_DATA {\n    if { [UDP::payload contains \"badstring\"] }{\n        UDP::drop\n    }\n}","returnValue":""},
{"commandName":"UDP::local_port","description":"Returns the local UDP port/service number.\n\nSyntax\n\nUDP::local_port\n\n     * Returns the local UDP port/service number.\n\nUDP::local_port clientside\n\n     * Returns the local UDP port/service number of the clientside\n       connection.\n\nUDP::local_port serverside\n\n     * Returns the local UDP port/service number of the serverside\n       connection.","examples":"when CLIENT_ACCEPTED {\n  if { [matchclass [UDP::local_port] equals $::ValidUDPPorts ] } {\n    pool udp_pool\n  } else {\n     discard\n  }\n}","returnValue":"Returns the local UDP port/service number"},
{"commandName":"UDP::mss","description":"Returns the on-wire Maximum Segment Size (MSS) for a UDP connection.\n\nSyntax\n\nUDP::mss\n\n     * Returns the on-wire Maximum Segment Size (MSS) for a UDP\n       connection.","examples":"when CLIENT_ACCEPTED {\n  if { [UDP::mss] < 1000 } {\n    pool small_req_pool\n  } else {\n    pool large_req_pool\n  }\n}","returnValue":"Returns the on-wire Maximum Segment Size (MSS) for a UDP connection"},
{"commandName":"UDP::payload","description":"Returns the content or length of the current UDP payload.\nNotice that, unlike TCP, there is no need to trigger a collect, and there is no\ncorresponding release. Moreover, this command is valid not only in\nCLIENT_DATA and SERVER_DATA, but may be invoked within\nCLIENT_ACCEPTED. In that case, it will evaluate to the data\ncontained in the segment that triggered the CLIENT_ACCEPTED event\n- though not necessarily every segment in a UDP stream (see\nCLIENT_ACCEPTED event description for more details).\n\nSyntax\n\nUDP::payload [<offset>] [<size>]\n\n     * Returns the content of the current UDP payload. If <size> is\n       specified, and more than <size> bytes are available, only the first\n       <size> bytes of collected data are returned.\n\nUDP::payload replace <offset> <length> <data>\n\n     * Replaces <length> bytes of the collected payload data starting at\n       <offset> with the given <data>.\n\nUDP::payload length\n\n     * Returns the length, in bytes, of the current UDP payload.","examples":"when CLIENT_DATA {\n  # empty payload entirely so there is no packet to send to the server\n  UDP::payload replace 0 [UDP::payload length] \"\"\n\n  # craft a string to hold our  packet data, 0x01 0x00 0x00 0x00 0x02 0x00 0x000x00 0x03 0x00 0x00 0x00\n  set packetdata [binary format i1i1i1 1 2 3 ]\n\n  # then fill payload with our own data from arbitrary length string called packetdata to send to the server\n  # this actually inserts it at the start of the packet, but because we emptiedthe packet above it becomes the new packet\n  UDP::payload replace 0 0 $packetdata\n\n  # Unlike TCP, UDP has no \"collect\" or \"release\"\n}\n\n   In at least BIG-IP 9.3.0 you can't use UDP::payload replace 0 0\n   $packetdata after emptying the payload entirely\n   A workaround is to insert your data at the start of the packet, then\n   empty the old data from the end\n\nwhen CLIENT_DATA {\n  # remember how big the incoming packet was\n  set oldlength [UDP::payload length]\n\n  # craft a string to hold our  packet data, 0x01 0x00 0x00 0x00 0x02 0x00 0x000x00 0x03 0x00 0x00 0x00\n  set packetdata [binary format i1i1i1 1 2 3 ]\n\n  # then fill payload with our own data from arbitrary length string called packetdata to send to the server\n  # this actually inserts it at the start of the packet, but because we emptiedthe packet above it becomes the new packet\n  UDP::payload replace 0 0 $packetdata\n\n  # now empty the old packet off the end\n  UDP::payload replace [string length $packetdata] [expr [UDP::payload length] - [string length $packetdata]] \"\"\n}","returnValue":""},
{"commandName":"UDP::remote_port","description":"Returns the remote UDP port/service number.\n\nSyntax\n\nUDP::remote_port\n\n     * Returns the remote UDP port/service number.\n\nUDP::remote_port clientside\n\n     * Returns the remote UDP port/service number of the clientside\n       connection.\n\nUDP::remote_port serverside\n\n     * Returns the remote UDP port/service number of the serverside\n       connection.","examples":"when SIP_REQUEST {\n  SIP::header insert \"Via\" \"[lindex [split [SIP::via 0] \";\"] 0]received=[IP::client_addr]rport=[UDP::remote_port][lindex [split [SIP::via 0] \";\"] 1]\"\n  SIP::header remove \"Via\" 1\n}","returnValue":"Returns the remote UDP port/service number"},
{"commandName":"UDP::respond","description":"Sends the specified data directly to the peer. This command can be used\nto complete a protocol handshake inside an iRule.\n\nSyntax\n\nUDP::respond <data>\n\n     * Sends the specified data directly to the peer.","examples":"when CLIENT_DATA {\n  set payload \"Error: Client not allowed.\"\n  if { [IP::remote_addr] eq 10.10.10.1 } {\n    UDP::drop\n    UDP::respond $payload\n  }\n}\n\n\nwhen CLIENT_ACCEPTED {\n  set packet [binary format S {0x0000}]\n  UDP::respond $packet\n}","returnValue":""},
{"commandName":"UDP::server_port","description":"Returns the UDP port/service number of the server. This command is\nequivalent to the command serverside { UDP::remote_port }.\n\nSyntax\n\nUDP::server_port\n\n     * Returns the UDP port/service number of the server.","examples":"when SERVER_CONNECTED {\n    set client [IP::client_addr]:[UDP::client_port]\n    set node [IP::server_addr]:[UDP::server_port]\n    log local0. \"client: $client, server: $server\"\n}","returnValue":""},
{"commandName":"UDP::unused_port","description":"Returns an unused UDP port for the specified IP tuple.\n\nSyntax\n\nUDP::unused_port <remote_addr> <remote_port> <local_addr> [<hint_port>] [<min_port>] [<max_port>]\n\n     * Returns an unused UDP port for the specified IP tuple, using the\n       value of <hint_port> as a starting point if it is supplied. If no\n       appropriate unused local port could be found, 0 is returned.","examples":"when CLIENT_ACCEPTED {\n  set port [UDP::unused_port [IP::remote_addr] [UDP::remote_port] [IP::local_addr]]\n  UDP::respond \"Next unused port: $port\"\n}","returnValue":""},
{"commandName":"URI::basename","description":"Extracts the basename part of a given uri string.\nFor the following URI:\n/main/index.jsp?user=test&login=check\n\nThe basename is:\n\nindex.jsp\n\n\nSyntax\n\n\nURI::basename <uri>\n\n     * Extracts the basename part of a given uri string.","examples":"when HTTP_REQUEST {\n  set base [URI::basename [HTTP::uri]]\n  log local0. \"Basename of uri [HTTP::uri] is $base\"\n}","returnValue":"Return the basename part of a given uri string."},
{"commandName":"URI::compare","description":"Compares two URI's as recommended by RFC2616 section 3.2.3.\n\n3.2.3 URI Comparison\n\n   When comparing two URIs to decide if they match or not, a client\n   SHOULD use a case-sensitive octet-by-octet comparison of the entire\n   URIs, with these exceptions:\n\n      - A port that is empty or not given is equivalent to the default\n        port for that URI-reference;\n\n        - Comparisons of host names MUST be case-insensitive;\n\n        - Comparisons of scheme names MUST be case-insensitive;\n\n        - An empty abs_path is equivalent to an abs_path of \"/\".\n\n   Characters other than those in the \"reserved\" and \"unsafe\" sets (see\n   RFC 2396 ) are equivalent to their \"\"%\" HEX HEX\" encoding.\n\n   For example, the following three URIs are equivalent:\n\n      http://abc.com:80/~smith/home.html\n      http://ABC.com/%7Esmith/home.html\n      http://ABC.com:/%7esmith/home.html\n\n\nSyntax\n\nURI::compare <uri1> <uri2>\n\n     * Compare two URI's as recommended by RFC2616 section 3.2.3.","examples":"when HTTP_REQUEST {\n  set uri_to_check \"/dir1/somepath\"\n  if { [URI::compare [HTTP::uri] $uri_to_check] } {\n    log local0. \"URI's are equal!\"\n  }\n}","returnValue":"Returns 1 if URIs match; 0 otherwise."},
{"commandName":"URI::decode","description":"Returns a URI decoded version of a given URI.\nFor details on URI encoding, see RFC3986, section 2.1. Percent-Encoding.\n\nThis command is equivalent to the BIG-IP 4.X variable decode_uri.\n\nSyntax\n\nURI::decode <uri>\n\n     * Returns a decoded version of a given URI.","examples":"when HTTP_REQUEST {\n  log local0. \"The decoded version of \\\"[HTTP::query]\\\" is \\\"[URI::decode [HTTP::query]]\\\"\"\n}\n\nLog output:\n\nThe decoded version of \"parameter=my%20URL%20encoded%20parameter%20value%20with%20metacharacters%20(%26*%40%23%5b%5d)\" is \"parameter=my URL encoded parameter value with metacharacters (&*@#[])\"","returnValue":"Returns a decoded version of a given URI."},
{"commandName":"URI::encode","description":"Returns the encoded version of the given URI.\nFor details on URI encoding, see RFC3986, section 2.1. Percent-Encoding.\n\nThis command is equivalent to the BIG-IP 4.X variable encode_uri.\n\nSyntax\n\nURI::encode <uri>\n\n     * Returns the encoded value of the given uri.","examples":"when HTTP_REQUEST {\n  set my_parameter_value \"my URL encoded parameter value with metacharacters (&*@#[])\"\n  log local0. \"The encoded version of \\\"$my_parameter_value\\\" is \\\"[URI::encode $my_parameter_value]\\\"\"\n  HTTP::redirect \"/path?parameter=[URI::encode $my_parameter_value]\"\n}\n\nLog output:\n\nThe encoded version of \"my URL encoded parameter value with metacharacters (&*@#)\" is \"my%20URL%20encoded%20parameter%20value%20with%20metacharacters%20(%26*%40%23)\"","returnValue":"Returns an encoded version of a given URI."},
{"commandName":"URI::host","description":"Returns the host portion of a given URI.\n\nSyntax\n\nURI::host <uri>\n\n     * Returns the host portion of a given URI.","examples":"when RULE_INIT {\n        # Loop through some test URLs and URIs and log the URI::host value\n        foreach uri [list \\\n                http://example.com/file.ext \\\n                http://example.com:80/file.ext \\\n                https://example.com:443/file.ext \\\n                ftp://example.com/file.ext \\\n                sip://example.com/file.ext \\\n                myproto://example.com/file.ext \\\n                /example.com \\\n                /uri?url=http://example.com/uri \\\n        ] {\n                log local0. \"\\[URI::host $uri\\]: [URI::host $uri]\"\n        }\n}\n\n# Log output:\n[URI::host http://example.com/file.ext]: example.com\n[URI::host http://example.com:80/file.ext]: example.com\n[URI::host https://example.com:443/file.ext]: example.com\n[URI::host ftp://example.com/file.ext]: example.com\n[URI::host sip://example.com/file.ext]: example.com\n[URI::host myproto://example.com/file.ext]: example.com\n[URI::host /example.com]:\n[URI::host /uri?url=http://example.com/uri]:\n\nSample log output from the above rule:\n     * Host of url http://www.foo.com/app/file.ext is www.foo.com\n     * Protocol of url http://www.foo.com/app/file.ext is http","returnValue":"Returns the host portion of a given URI."},
{"commandName":"URI::path","description":"Returns the path portion of the given URI.\n\nSyntax\n\nURI::path <uri>\n\n     * Returns the path portion of the given URI excluding the basename.\n\nURI::path <uri> depth\n\n     * Returns the path depth\n\nURI::path <uri> <start>\n\n     * Returns the path portion of the given URI starting from 'start' depth\n\nURI::path <uri> <start> <end>\n\n     * Returns the path portion of the given URI over the range 'start' depth to\n       'end' depth (with start >= 1).","examples":"A simple test rule which demonstrates uses of the URI::query commands¶\n\n\nwhen RULE_INIT {\n\n    # You can use URI::query against a static string and not in a client-triggered event!\n    log local0. \"\\[URI::query \\\"?param1=val1&param2=val2\\\" param1\\]: [URI::query \"?param1=val1&param2=val2\" param1]\"\n\n    # This doesn't work, as URI::query expects a query string to start with a question mark\n    log local0. \"\\[URI::query \\\"param1=val1&param2=val2\\\" param1\\]: [URI::query \"param1=val1&param2=val2\" param1]\"\n}\nwhen HTTP_REQUEST {\n\n    # Log the test URI\n    log local0. \"\\[HTTP::uri\\]: [HTTP::uri]\"\n\n    log local0. \"\\[URI::basename \\[HTTP::uri\\]\\]: [URI::basename [HTTP::uri]]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\]\\]: [URI::path [HTTP::uri]]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\] depth\\]: [URI::path [HTTP::uri] depth]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 1\\]: [URI::path [HTTP::uri] 1]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 2\\]: [URI::path [HTTP::uri] 2]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 3\\]: [URI::path [HTTP::uri] 3]\"\n\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 1 3\\]: [URI::path [HTTP::uri] 1 3]\"\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 2 3\\]: [URI::path [HTTP::uri] 2 3]\"\n\n    # This isn't a valid range, so expect a TCL error!  Ranges start with 1.\n    log local0. \"\\[URI::path \\[HTTP::uri\\] 0 3\\]: [URI::path [HTTP::uri] 0 3]\"\n}\n\nAnd the corresponding log output:\n\n\n  Rule : [URI::query \"?param1=val1&param2=val2\" param1]: val1\n  Rule : [URI::query \"param1=val1&param2=val2\" param1]:\n  <HTTP_REQUEST>: [HTTP::uri]: /path/to/file.ext?param=value\n  <HTTP_REQUEST>: [URI::basename [HTTP::uri]]: file.ext\n  <HTTP_REQUEST>: [URI::path [HTTP::uri]]: /path/to/\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] depth]: 2\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] 1]: /path/to/\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] 2]: /to/\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] 3]: /\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] 1 3]: /path/to/\n  <HTTP_REQUEST>: [URI::path [HTTP::uri] 2 3]: /to/\n  01220001<!--:3: TCL error: test_uri_query_rule <HTTP_REQUEST> - while executing \"URI::path [HTTP::uri] 0 3\"-->","returnValue":"Returns the path portion of the given URI."},
{"commandName":"URI::port","description":"Returns the host port from the given URI.\n\nSyntax\n\nURI::port <uri>\n\n     * Returns the port from the given URI. Returns 80 by default for URIs\n       without a protocol or 0 if the protocol is unknown.","examples":"when HTTP_REQUEST {\n  set port [URI::port [HTTP::uri]]\n  log local0. \"Host port of uri [HTTP::uri] is $port\"\n}\n\nThe default seems to be port 80 if a port isn't specified in the URI.\nHere are a few tests (on 10.2.4):\n\nwhen RULE_INIT {\n        # Loop through some test URLs and URIs and log the URI::port value\n        foreach uri [list \\\n                http://example.com/file.ext \\\n                http://example.com:80/file.ext \\\n                https://example.com:443/file.ext \\\n                https://example.com:8443/file.ext \\\n                ftp://example.com/file.ext \\\n                sip://example.com/file.ext \\\n                myproto://example.com/file.ext \\\n                /example.com \\\n                /uri?url=http://example.com/uri \\\n        ] {\n                log local0. \"\\[URI::port $uri\\]: [URI::port $uri]\"\n        }\n}\n\nLog output\n\n[URI::port http://example.com/file.ext]: 80\n[URI::port http://example.com:80/file.ext]: 80\n[URI::port https://example.com:443/file.ext]: 443\n[URI::port https://example.com:8443/file.ext]: 8443\n[URI::port ftp://example.com/file.ext]: 21\n[URI::port sip://example.com/file.ext]: 5060\n[URI::port myproto://example.com/file.ext]: 0\n[URI::port /example.com]: 80\n[URI::port /uri?url=http://example.com/uri]: 80","returnValue":"Returns the host port from the given URI."},
{"commandName":"URI::protocol","description":"Returns the protocol of the given URI.\n\nSyntax\n\nURI::protocol <uri>\n\n     * Returns the protocol of the given URI by parsing the characters up\n       to the first :// instance.","examples":"when RULE_INIT {\n        # Loop through some test URLs and URIs and log the URI::protocol value\n        foreach uri [list \\\n                http://test.com \\\n                https://test.com \\\n                ftp://test.com \\\n                sip://test.com \\\n                myproto://test.com \\\n                /test.com \\\n                /uri?url=http://test.example.com/uri \\\n        ] {\n                log local0. \"\\[URI::protocol $uri\\]: [URI::protocol $uri]\"\n        }\n}\n\n\n# Log results:\n[URI::protocol http://test.com]: http\n[URI::protocol https://test.com]: https\n[URI::protocol ftp://test.com]: ftp\n[URI::protocol sip://test.com]: sip\n[URI::protocol myproto://test.com]: myproto\n[URI::protocol /test.com]:\n[URI::protocol /uri?url=http://test.example.com/uri]:","returnValue":"Returns the protocol of the given URI."},
{"commandName":"URI::query","description":"Returns the query string portion of the given URI or the value of a\nquery string parameter.\n\nSyntax\n\n   URI::query <uri>\n     * Returns the query string portion of the given URI.\n\n   URI::query <uri> <param_name>\n     * Returns the value of a query string parameter from a given URI\n       based on the parameter name. If the query string does not contain\n       the parameter name, an empty string is returned.\n\n     * This command expects the query string to start with a question mark\n       with the following format:\n\n\n?parameter_name1=parameter_value1&parameter_name2=parameter_value2\n\n     * For POST requests with a content type of x-www-form-urlencoded, you\n       can use [URI::query \"?$payload\" $param_name] to parse a specific\n       parameter value given the parameter name. Note that you prepend a ?\n       to the payload to allow it to be parsed as a query string. See the\n       second example below for details.","examples":"when HTTP_REQUEST {\n    log local0. \"Query string of URI [HTTP::uri] is [URI::query [HTTP::uri]]\"\n}\n\nLog output:\n\nQuery string of URI /path/to/file.ext?param1=value1&param2=value2 is param1=value1&param2=value2\n\n\nwhen RULE_INIT {\n\n    log local0. \"\\[URI::query \\\"?param1=val1&param2=val2\\\" param1\\]: [URI::query \"?param1=val1&param2=val2\" param1]\"\n    log local0. \"\\[URI::query \\\"param1=val1&param2=val2\\\" param1\\]: [URI::query \"param1=val1&param2=val2\" param1]\"\n}\n\nLog output:\n\n[URI::query \"?param1=val1&param2=val2\" param1]: val1\n[URI::query \"param1=val1&param2=val2\" param1]:\n\nNote that the first log statement returns the correct value for the\nparameter named param1. This is because the test \"payload\" has a\nquestion mark prepended to it. This type of functionality could be used\nto parse parameter values after collecting the payload.","returnValue":"Returns the query string portion of the given URI or the value of a query string parameter."},
{"commandName":"VALIDATE::protocol","description":"This command allows you to validate payload (traffic) to match given classification application.\n\nNote: the APM / AFM / PEM license is required for functionality to work.","examples":"when CLIENT_ACCEPTED {\n  TCP::collect 32\n}\n\nwhen CLIENT_DATA {\n  if { [VALIDATE::protocol http [TCP::payload 32] ] } {\n     pool web_servers\n  } else {\n     pool xyz_servers\n  }\n  TCP::release\n}","returnValue":"Returns TRUE in case of match, FALSE otherwise."},
{},
{},
{"commandName":"WAM::disable","description":"Disables the WAM plugin for the current TCP connection. WAM will remain\ndisabled on the current TCP connection until it is closed or\nWAM::enable is called.\n\nSyntax\n\nWAM::disable\n\n     * Disables plugin processing for the duration of the TCP connection\n       or until WAM::enable is called.\n\n   Note: WAM::disable deprecates PLUGIN::disable WAM","examples":"# Disable WAM for HTTP paths ending in .php\nwhen HTTP_REQUEST {\n  if { [HTTP::path] ends_with \".php\" } {\n    WAM::disable\n  } else {\n    WAM::enable\n  }\n}","returnValue":""},
{"commandName":"WAM::enable","description":"Enables the WAM plugin for the current TCP connection. WAM will remain\nenabled on the current TCP connection until it is closed or\nWAM::disable is called.\n\nSyntax\n\nWAM::enable\n\n     * Enables Web Accelerator plugin processing for the duration of the\n       TCP connection or until WAM::disable is called.\n\n   Note: WAM::enable deprecates PLUGIN::enable WAM","examples":"# Disable WAM for HTTP paths ending in .php\nwhen HTTP_REQUEST {\n  WAM::enable\n  if { [HTTP::path] ends_with \".php\" } {\n    WAM::disable\n  }\n}","returnValue":""},
{"commandName":"WEBSSO::disable","description":"This command causes APM to forward a request without doing SSO\nprocessing on it. If APM receives HTTP 401 response from server, 401\nresponse is forwarded to the end user. The scope of this iRule command\nis per HTTP request. Admin needs to execute it for each HTTP request.\n\nSyntax\n\nWEBSSO::disable","examples":"","returnValue":""},
{"commandName":"WEBSSO::enable","description":"This command causes APM to do the SSO processing on the HTTP request.\nThis is to allow admin to re-enable WEBSSO processing for a request if\nit was disabled before by doing WEBSSO::disable for the request. The\nscope of this iRule command is per HTTP request. Admin needs to execute\nit for each HTTP request.\n\nSyntax\n\nWEBSSO::enable","examples":"","returnValue":""},
{"commandName":"WEBSSO::select","description":"This command causes APM to use specified SSO configuration object to do\nSSO for the HTTP request. Admin should make sure that the selected SSO\nmethod works for the specified request (and is enabled on backend\nserver request is going to). The scope of this iRule command is per\nHTTP request. Admin needs to execute it for each HTTP request.\n\nSyntax\n\nWEBSSO::select <sso_config_object_name>","examples":"when ACCESS_ACL_ALLOWED {\n    set req_uri [HTTP::uri]\n    if { $req_uri starts_with \"/owa\" } {\n        if { $req_uri eq \"/owa/auth/logon.aspx?url=https://mysite.com/owa/&reason=0\" } {\n            WEBSSO::select owa_form_base_sso\n        } elseif { $req_uri eq \"/owa/auth/logon.aspx?url=https://mysite.com/ecp/&reason=0\" } {\n            WEBSSO::select ecp_form_base_sso\n        }\n    }\n    unset req_uri\n}","returnValue":""},
{"commandName":"WS::frame","description":"WS::frame eom\n    The command can be used to determine whether current frame is last one in the Websocket message.\n\nWS::frame orig_masked\n    The command can be used to determine whether current frame received from the client or server was masked.\n\nWS::frame type\n    The command can be used to determine the type of current frame received from the client or server.\n\nWS::frame mask\n    The command can be used to determine the mask of the current frame.\n\nWS::frame drop\n    The command can be used to drop the current frame.\n\nWS::frame insert <frame-type> <payload> <mask>\n    Insert a text/binary frame. The new frame will be inserted before the current frame. Length is determined from payload. EOM is set to TRUE by default. Mask is an optional parameter. If mask is specified, the frame will be masked and mask bit in the header will be set.\n\nWS::frame prepend <payload>\n    Prepend specified data to the frame payload. This option is not available when preserve masking is configured in the Websocket profile.\n\nWS::frame append <payload>\n    Append specified data to the frame payload. This option is not available when preserve masking is configured in the Websocket profile.\n\nWS::frame replace <payload>\n    Replace contents of the current frame payload with the specified data. This option is not available when preserve masking is configured in the Websocket profile.","examples":"when WS_CLIENT_FRAME {\n    set mask [expr { int(20 * rand()) }]\n    log local0. \"Websocket frame eom: [WS::frame eom]\"\n    log local0. \"Websocket frame received mask: [WS::frame orig_masked]\"\n    log local0. \"Websocket frame type: [WS::frame type]\"\n    log local0. \"Websocket frame mask: [WS::frame mask]\"\n    WS::frame drop\n    WS::frame insert 1 \"abcdefghi\" $mask\n    WS::frame prepend \"Using WS I sent \"\n    WS::frame append \"message was sent\"\n    WS::frame replace \"replaced\"\n}\nwhen WS_SERVER_FRAME {\n    log local0. \"Websocket frame eom: [WS::frame eom]\"\n    log local0. \"Websocket frame received mask: [WS::frame orig_masked]\"\n    log local0. \"Websocket frame type: [WS::frame type]\"\n    log local0. \"Websocket frame mask: [WS::frame mask]\"\n    WS::frame drop\n    WS::frame insert 1 \"abcdefghi\"\n    WS::frame prepend \"Using WS I sent \"\n    WS::frame append \"message was sent\"\n    WS::frame replace \"replaced\"\n}","returnValue":"The eom, orig_masked, type and mask commands return the values of corresponding fields in the Websockets frame header. Drop, insert, prepend, append and replace can be used to manipulate the frame contents."},
{"commandName":"WS::enabled","description":"WS::enabled\n    This can be used to determine whether the Websocket processing is enabled or disabled for a particular connection.\n\nWS::enabled false\n    This can be used to disable the Websocket processing for a particular connection.","examples":"when WS_REQUEST {\n    WS::enabled false\n    log local0. \"Websocket state: [WS::enabled]\"\n}\nwhen WS_RESPONSE {\n    WS::enabled false\n    log local0. \"Websocket state: [WS::enabled]\"\n}\nwhen HTTP_REQUEST {\n    WS::enabled false\n}","returnValue":"WS::enabled command returns TRUE if Websocket processing is enabled for a particular connection, FALSE otherwise."},
{"commandName":"WS::request","description":"WS::request protocol\n    Returns the value of Sec-WebSocket-Protocol header field in client request.\n\nWS::request extension\n    Returns the value of Sec-WebSocket-Extensions header field in client request.\n\nWS::request version\n    Returns the value of Sec-WebSocket-Version header field in client request.\n\nWS::request key\n    Returns the value of Sec-WebSocket-Key header field in client request.","examples":"when WS_REQUEST {\n    if { [WS::request protocol] equals \"chat\" } {\n        WS::enabled false\n    }\n}","returnValue":"This command can be used to lookup the values of various Websocket header fields seen in a client request."},
{"commandName":"WS::response","description":"WS::response protocol\n    Returns the value of Sec-WebSocket-Protocol header field in server response.\n\nWS::response extension\n    Returns the value of Sec-WebSocket-Extensions header field in server response.\n\nWS::response version\n    Returns the value of Sec-WebSocket-Version header field in server response.\n\nWS::response key\n    Returns the value of Sec-WebSocket-Accept header field in server response.\n\nWS::response valid\n    Returns whether the client request and server response resulted in a successful Websocket upgrade.","examples":"when WS_RESPONSE {\n    if { [WS::response key] equals \"s3pPLMBiTxaQ9kYGzzhZRbK+xOo=\"} {\n        WS::enabled false\n    }\n}","returnValue":"This command can be used to lookup the values of various Websocket header fields seen in a server response."},
{"commandName":"WS::message","description":"WS::message drop\n    Drop an entire Websocket message.","examples":"when WS_CLIENT_FRAME {\n    WS::message drop\n}\nwhen WS_SERVER_FRAME {\n    WS::message drop\n}","returnValue":""},
{"commandName":"WS::masking","description":"WS::masking preserve\n    The WebSockets module will not unmask the payload. Data received from the end-points will be sent untouched to other modules for further processing.\n\nWS::masking remask\n    The data received from the end-points is unmasked and sent to other modules for further processing. The client-to-server frame's payload is then masked with the specified mask before sending data out on the wire again.","examples":"when WS_REQUEST {\n    WS::masking preserve\n    WS::masking remask\n}\nwhen WS_RESPONSE {\n    WS::masking preserve\n    WS::masking remask\n}","returnValue":""},
{"commandName":"WS::disconnect","description":"WS::disconnect <close-reason> <reason>\n    The Websocket connection is disconnected by sending a close frame to both end-points when the current frame is done. The specified code and reason will be sent in the header and payload of the frame respectively.","examples":"when WS_CLIENT_FRAME_DONE {\n    WS::disconnect 1000 \"some random reason\"\n}\nwhen WS_SERVER_FRAME_DONE {\n    WS::disconnect 1000 \"some random reason\"\n}","returnValue":""},
{"commandName":"WS::collect","description":"WS::collect frame\nCollects the entire Websocket frame payload.\n\nNote that if multiple iRules invoke WS::collect simultaneously,\n(perhaps by being called by the same event in multiple iRule scripts)\nthen the result is undefined.  This is because the amount of payload\ncollected for the WS_CLIENT_DATA or WS_SERVER_DATA event cannot\nsatisfy the perhaps differing amounts wanted by the callers. iRules\nshould arbitrate amoungst themselves to prevent this situation from\noccuring, and have only one WS::collect call outstanding at a time.\n\nWS::collect frame <length>\n    Collects an amount of Websocket frame payload, optionally specified with the <length> argument.","examples":"when WS_CLIENT_FRAME {\n    WS::collect frame\n}\nwhen WS_CLIENT_FRAME {\n    WS::collect frame 1000\n}","returnValue":""},
{"commandName":"WS::release","description":"WS::release\n    Releases the data collected via WS::collect. Unless a subsequent WS::collect command was issued, there is no need to use the WS::release command inside of the WS_CLIENT_DATA and WS_SERVER_DATA events, since (in these cases) the data is implicitly released.","examples":"when WS_CLIENT_FRAME {\n    WS::collect frame 1000\n    set clen 1000\n}\n\nwhen WS_CLIENT_DATA {\n    regsub -all \"oursite\" [WS::payload] \"oursitedev\" newdata\n    log local0. \"Replacing payload with new data.\"\n    WS::payload replace 0 $clen $newdata\n    WS::release\n}","returnValue":""},
{"commandName":"WS::payload","description":"WS::payload <length>\n    Returns the content that the WS::collect command has collected thus far, up to the number of bytes specified. If you do not specify a size, the system returns the entire collected content.\n\nWS::payload <offset> <length>\n    Returns the content that the WS::collect command has collected thus far from the specified offset, up to the number of bytes specified.\n\nWS::payload length\n    Returns the size of the content that has been collected thus far, in bytes.\n\nWS::payload replace <offset> <length> <string>\n    Replaces the amount of content that you specified with the <length> argument, starting at <offset> with <string>, adjusting the frame length in frame header appropriately. The length argument should be the length of original content to replace. In order to replace the entire payload, the offset should be 0 and the length should be the original size in bytes of the payload.","examples":"when WS_CLIENT_FRAME {\n    WS::collect frame 1000\n    set clen 1000\n}\n\nwhen WS_CLIENT_DATA {\n    regsub -all \"oursite\" [WS::payload] \"oursitedev\" newdata\n    log local0. \"Replacing payload with new data.\"\n    WS::payload replace 0 $clen $newdata\n    WS::release\n}","returnValue":""},
{"commandName":"X509::cert_fields","description":"When given a valid certificate, returns a TCL list of field names and\nvalues which can be added to the HTTP headers in order to emulate\nModSSL behavior. The output can be passed to 'HTTP::header insert\n$list' as a list for insertion in the HTTP request or response.\n\n\nSyntax\n\n\nX509::cert_fields <X509 certificate> <verify error code> [<field identifier>]\n\n    * Returns a list of fields to be added to the HTTP headers in order\n       to emulate ModSSL behavior. The return type is a Tcl list that the\n       system then interprets as a header-name/header-value pair.\n\n    Optional <field identifier> can be a list of one or more of the following fields:\n     * hash | issuer | serial | sigalg | subject | subpubkey | validity |\n       versionnum | whole","examples":"when RULE_INIT {\n\n   # Session timeout. Length of time (in seconds) to store the client cert in the session table.\n    set ::session_timeout 3600\n\n   # SSL::sessionid returns 64 0's if the session ID doesn't exist, so set a tocheck for this\n    set ::null_sessionid [string repeat 0 64]\n}\nwhen CLIENTSSL_CLIENTCERT {\n\n   #################################################\n   # Need to first check if there is a cert and that it's valid\n   # ...\n   #################################################\n\n   # Save the first cert in the client request\n    set cert [SSL::cert 0]\n\n   # Save the cert fields to a list\n    set fields [X509::cert_fields $cert [SSL::verify_result] hash issuer serial sigalg subject subpubkey validity versionnum whole]\n    log local0. \"Client certificate fields - $fields\"\n\n   # Add the cert to the session table for use in subsequent HTTP requests.  Use the SSL session ID as the key.\n    session add ssl [SSL::sessionid] [list $cert $fields] $::session_timeout\n}\nwhen HTTP_REQUEST {\n\n   # Check if there is an existing SSL session ID and if the cert is in the session table\n    if {[SSL::sessionid] ne $::null_sessionid && [session lookup ssl [SSL::sessionid]] ne \"\"}{\n\n      # Insert SSL cert details in the HTTP headers\n      HTTP::header insert [lindex [session lookup ssl [SSL::sessionid]] 1]\n\n   } else {\n\n      # Send a response back to the client indicating they didn't present a valid cert.\n      HTTP::respond 200 content [subst {<html>Invalid request with SSL session ID [SSL::sessionid]</html>}]\n   }\n}\n\n\nwhen CLIENTSSL_CLIENTCERT {\n    if { [SSL::cert count] > 0 } {\n        session add ssl [SSL::sessionid] [X509::cert_fields [SSL::cert 0] [SSL::verify_result] whole] $timeout\n    }\n}","returnValue":"Returns a list of X509 certificate fields to be added to HTTP headers."},
{"commandName":"X509::extensions","description":"Returns the X509 extensions set on the specified X509 certificate.\n\nSyntax\n\nX509::extensions <X509 certificate>\n\n     * Returns the X509 extensions set on the specified X509 certificate.\n       If the certificate does not have any extensions, the output is \"(no\n       extensions)\".\n       If an invalid certificate is supplied, a runtime TCL\n       error is generated.","examples":"when CLIENTSSL_CLIENTCERT {\n    set myCert [SSL::cert 0]\n    set result [X509::extensions $myCert]\n    log local0. \"X509::extensions $result\"\n\n    if { $result matches_glob \"*X509v3 extensions:*X509v3 Basic*\" } {\n        log local0. \"match\"\n    } else {\n        log local0. \"no match\"\n    }\n}","returnValue":"Returns the X509 extensions set on an X509 certificate."},
{"commandName":"X509::hash","description":"Returns the MD5 hash (fingerprint) of the specified X509 certificate.\n\nSyntax\n\nX509::hash <X509 certificate>\n\n     * Returns the MD5 hash (fingerprint) of the specified X509\n       certificate.","examples":"# v10.1+ example:\nwhen HTTP_REQUEST {\n  # Save the first cert the client presents as $cert\n  if { [set cert [SSL::cert 0]] ne \"\" } {\n\n    # Get the md5 hash of the client cert\n    set cert_hash [X509::hash [SSL::cert 0]]\n\n    # Check if the hash matches a specific string\n    if { $cert_hash equals \"XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX\"} {\n\n      # Remove any pre-existing headers\n      HTTP::header remove cert_hash\n\n      # Insert a new cert header\n      HTTP::header insert cert_hash $cert_hash\n\n      # Exit this event to avoid the redirect below for invalid certs\n      return\n    }\n  }\n  # Redirect all other requests to another URL\n  HTTP::redirect \"https://someothersite/\"\n}\n\n\n# Pre-v10.1 example which checks if the client cert's md5 hash matches a specific string\n# This should be updated to manually store the hash in the session table using 'session add [SSL::session_id] [X509::hash $client_cert]'\nwhen CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n  log local0. \"Cert hash - [X509::hash $client_cert]\"\n  set cert_hash [X509::hash $client_cert]\n}\nwhen HTTP_REQUEST {\n  if { [info exist cert_hash] } {\n    if { $cert_hash equals \"XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX:XX\"} {\n      HTTP::redirect \"https://somesite/\"\n    } else {\n      HTTP::redirect \"https://someothersite/\"\n    }\n  }\n}","returnValue":"Returns the MD5 hash (fingerprint) of an X509 certificate."},
{"commandName":"X509::issuer","description":"Returns the issuer of the specified X509 certificate.\n\nSyntax\n\nX509::issuer <X509 certificate>\n\n     * Returns the issuer of the specified X509 certificate.","examples":"when SERVERSSL_HANDSHAKE {\n  set ssl_cert [SSL::cert 0]\n  log local0. \"Cert issuer - [X509::issuer $ssl_cert]\"\n}\n\n\nwhen HTTP_REQUEST {\n  log local0. \"Cert issuer - [X509::issuer $client_cert]\"\n  if { [X509::issuer $client_cert] eq \"someValue\" } {\n    pool pool1\n  } else {\n    HTTP::redirect \"https://some_other_site.com/\"\n  }\n}","returnValue":"Returns the issuer of an X509 certificate."},
{"commandName":"X509::not_valid_after","description":"Returns the not-valid-after date of the specified X509 certificate.\n\nSyntax\n\nX509::not_valid_after <X509 certificate>\n\n     * Returns the not-valid-after date of the specified X509 certificate.","examples":"when SERVERSSL_HANDSHAKE {\n  set server_cert [SSL::cert 0]\n  log local0. \"Server Certificate Valid Date -\n   [X509::not_valid_before $server_cert] -\n   [X509::not_valid_after $server_cert]\"\n}","returnValue":"Returns the not-valid-after date of an X509 certificate."},
{"commandName":"X509::not_valid_before","description":"Returns the not-valid-before date of the specified X509 certificate.\n\nSyntax\n\nX509::not_valid_before <X509 certificate>\n\n     * Returns the not-valid-before date of the specified X509\n       certificate.","examples":"when SERVERSSL_HANDSHAKE {\n  set server_cert [SSL::cert 0]\n  log local0. \"Server Certificate Valid Date -\n   [X509::not_valid_before $server_cert] -\n   [X509::not_valid_after $server_cert]\"\n}","returnValue":"Returns the not-valid-before date of an X509 certificate."},
{"commandName":"X509::serial_number","description":"Returns the serial number of the specified X509 certificate.\n\nSyntax\n\nX509::serial_number <X509 certificate>\n\n     * Returns the serial number of the specified X509 certificate.\n\n   See AskF5 SOL9843: iRule command X509::serial_number returns SN\n   with leading zeroes truncated","examples":"when HTTP_REQUEST {\n    log local0. \"Certificate Serial Number: [X509::serial_number cert_x]\"\n}\n\n\nwhen HTTP_REQUEST {\n    set ssl_cert [SSL::cert 0]\n    HTTP::header insert SSLClientCertSN [X509::serial_number $ssl_cert]\n}","returnValue":"Returns the serial number of an X509 certificate."},
{"commandName":"X509::signature_algorithm","description":"Returns the signature algorithm of the specified X509 certificate.\n\nSyntax\n\nX509::signature_algorithm <X509 certificate>\n\n     * Returns the signature algorithm of the specified X509 certificate.","examples":"when SERVERSSL_HANDSHAKE {\n    set ssl_cert [SSL::cert 0]\n    log local0. \"SIGNATURE ALGORITHM: [X509::signature_algorithm $ssl_cert]\"\n}","returnValue":"Returns the signature algorithm of an X509 certificate."},
{"commandName":"X509::subject","description":"Returns the subject of the specified X509 certificate.\n\nSyntax\n\nX509::subject <X509 certificate>\n\n     * Returns the subject of the specified X509 certificate.","examples":"when CLIENTSSL_HANDSHAKE {\n\n  # Check if the client supplied one or more client certs\n  if {[SSL::cert count] > 0}{\n\n    # Check the first client cert subject\n    if { [X509::subject [SSL::cert 0]] equals \"someSubject\" } {\n      log local0. \"X509 Certificate Subject [X509::subject [SSL::cert 0]]\"\n      pool my_pool\n    }\n  }\n}","returnValue":"Returns the subject of an X509 certificate."},
{"commandName":"X509::subject_public_key","description":"Returns the subject’s public key of the specified X509 certificate.\n\nSyntax\n\nX509::subject_public_key <X509 certificate>\n\n     * Returns the subject’s public key of the specified X509 certificate.\n\nv11.5+\n\nX509::subject_public_key type <X509 certificate>\n\n     * Returns the type of subject public key of the specified X509\n       certificate e.g. RSA, DSA or EC.\n\nX509::subject_public_key bits <X509 certificate>\n\n     * Returns the size of subject public key in bits of the specified\n       X509 certificate e.g. 2048. Valid for public key type RSA and DSA\n       only. EC public key certificates are not supported by this command.\n\nX509::subject_public_key curve_name <X509 certificate>\n\n     * Returns the curve-name of EC subject public key of the specified\n       X509 certificate. An error message will be show if the certificate\n       is not of type EC.","examples":"when CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n  log local0. \"Cert subject - [X509::subject $client_cert]\"\n  log local0. \"Cert public key - [X509::subject_public_key $client_cert]\"\n}\n\n\nwhen CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n\n  log local0. \"key - [X509::subject_public_key $client_cert]\"\n  log local0. \"key type - [X509::subject_public_key type $client_cert]\"\n  log local0. \"key bits - [X509::subject_public_key bits $client_cert]\"\n  log local0. \"key curve_name - [X509::subject_public_key curve_name $client_cert]\"\n}","returnValue":""},
{"commandName":"X509::subject_public_key_RSA_bits","description":"Returns the size, in bits, of the subject’s public RSA key of the\nspecified X509 certificate. This command is only applicable when the\npublic key type is RSA. Otherwise, the command generates an error.\n\nSyntax\n\nX509::subject_public_key_RSA_bits <X509 certificate>\n\n     * Returns the size, in bits, of the subject’s public RSA key of the\n       specified X509 certificate.","examples":"when CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n  log local0. \"Cert subject - [X509::subject $client_cert]\"\n  log local0. \"Cert subject public key RSA bits - [X509::subject_public_key_RSA_bits $client_cert]\"\n  if { [X509::subject_public_key_RSA_bits $client_cert] <= 1024 } {\n    SSL::verify_result 50\n  }\n  set error_code [SSL::verify_result]\n  log local0. \"Cert verify result - [X509::verify_cert_error_string $error_code]\"\n}\nwhen HTTP_REQUEST {\n  if { [info exist error_code] } {\n    if { $error_code > 0 } {\n      HTTP::redirect \"https://some_other_site/\"\n    }\n  }\n}","returnValue":"Returns the size of the subject’s public RSA key of an X509 certificate."},
{"commandName":"X509::subject_public_key_type","description":"Returns the subject’s public key type of the specified X509\ncertificate. The returned value can be either RSA, DSA, or unknown.\n\nSyntax\n\nX509::subject_public_key_type <X509 certificate>\n\n     * Returns the subject’s public key type of the specified X509\n       certificate. The returned value can be either RSA, DSA, or unknown.","examples":"when CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n  log local0. \"Cert subject - [X509::subject $client_cert]\"\n  log local0. \"Cert public key type - [X509::subject_public_key_type $client_cert]\"\n  if { [X509::subject_public_key_type $client_cert] equals \"unknown\" } {\n    SSL::verify_result 50\n  }\n  set error_code [SSL::verify_result]\n  log local0. \"Cert verify result - [X509::verify_cert_error_string $error_code]\"\n}","returnValue":"Returns the subject’s public key type of an X509 certificate."},
{"commandName":"X509::verify_cert_error_string","description":"Returns the same result as the OpenSSL function\nX509_verify_cert_error_string(). Values for the <X509 verify error\ncode> argument must be the same values as those that the SSL::verify\nresult command returns.\n\nSyntax\n\nX509::verify_cert_error_string <X509 verify error code>\n\n     * Returns the same result as the OpenSSL function\n       X509_verify_cert_error_string(). Values for the <X509 verify error\n       code> argument must be the same values as those that the\n       SSL::verify result command returns.","examples":"when CLIENTSSL_CLIENTCERT {\n  set cert [SSL::cert 0]\n  log local0. \"Cert subject - [X509::subject $cert]\"\n  set error_code [SSL::verify_result]\n  log local0. \"Cert verify result - [X509::verify_cert_error_string $error_code]\"\n}","returnValue":"Returns an X509 certificate error string."},
{"commandName":"X509::version","description":"Returns the version number of the specified X509 certificate (an\ninteger).\n\nSyntax\n\nX509::version <X509 certificate>\n\n     * Returns the version number of the specified X509 certificate (an\n       integer).","examples":"when HTTP_REQUEST {\n  log local0. \"Cert version - [X509::version ssl_cert]\"\n  if { [X509::version ssl_cert] eq 3 } {\n    pool v3_pool\n  } else {\n    pool default_pool\n  }\n}","returnValue":"Returns the version number of an X509 certificate."},
{"commandName":"X509::whole","description":"Returns the specified X509 certificate, in its entirety, in PEM format.\n\nSyntax\n\nX509::whole <X509 certificate>\n\n     * Returns the specified X509 certificate, in its entirety, in PEM\n       format.","examples":"when CLIENTSSL_CLIENTCERT {\n  set client_cert [SSL::cert 0]\n  log local0. \"[X509::whole $client_cert]\"\n}\n\n\nwhen HTTP_REQUEST {\n    if { [SSL::cert count] > 0 } {\n        HTTP::header insert \"X-ENV-SSL_CLIENT_CERTIFICATE\" [X509::whole [SSL::cert 0]]\n    }\n}","returnValue":"Returns an X509 certificate in PEM format."},
{"commandName":"XML::disable","description":"Changes the XML plugin from full patching mode to passthrough.","examples":"","returnValue":""},
{"commandName":"XML::enable","description":"Changes the XML plugin from passthrough to full patching mode.","examples":"","returnValue":""},
{"commandName":"XML::payload","description":"Queries for or manipulates XML payload.","examples":"","returnValue":""}
]
